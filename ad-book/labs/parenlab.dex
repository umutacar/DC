\documentclass{course}
\title{Parallel and Sequential Algorithms}

% Course number must be unique in the database
\coursenumber{15210}

\semester{Spring 2018}
\picture{/210/course/air-pavilion.jpg}
\website{http://www.cs.cmu.edu/~15210}

% Provides book
% This must be provided
% The name should be relative to course number.
\providesbook{S18}

\providesassignment{2}

\begin{book}
\title{Algorithm Design: Parallel and Sequential}
\authors{Umut A. Acar and Guy Blelloch}

\begin{assignment}
\title{ParenLab (Written)}
\duedate{26 January 2018}


\begin{asstproblem}
\title{Analysis}

\begin{questionfr}
\points 14
\prompt
Analyze your brute force implementation of \texttt{parenDist},
giving tight Big-$O$ bounds for its work and span. For cost bounds of sequence
functions, you should assume the \texttt{ArraySequence} implementation. Your score
for this problem will depend on the correctness of your code (i.e. you cant
just ignore Task 4.1 and expect to get free points here for correctly stating
that your code is $O(1)$).

\answer
We need to analyze the helper functions first. \texttt{parensClosed} does $O(n)$ work, $O(1)$ span creating \texttt{init} and $O(n)$ work, $O(\log n)$ in the final \texttt{reduce} (work shown in next problem) giving $O(n)$ work $O(\log n)$ span. \texttt{optMax} is obviously $O(1)$ work and span. \texttt{allSufficesOf} and \texttt{allPrefixesOf} are both $O(n)$ work and $O(1)$ span for tabulating an $O(1)$ function on $n$ indices. Finally \texttt{trySubseq} is $O(n)$ work and $O(\log n)$ span for performing \texttt{parensClosed} twice.

Then \texttt{parenDist} calculates \texttt{all} by generating all prefixes of \texttt{parens} ($O(n)$ work, $O(1)$ span), calculating all suffixes of each of these prefixes ($O(n)*O(n) = O(n^2)$ work, $O(1)$ span), and flattening all these elements together ($O(n^2)$ work, $O(\log(n^2)) = O(\log n)$ span), in total taking $O(n^2)$ work and $O(\log n)$ span. We perform one \texttt{parensClosed} which is $O(n)$ and $O(\log n)$. In the worst case, we \texttt{map trySubseq} on all $O(n^2)$ elements getting $O(n^3)$ work and $O(\log n)$ span. Finally, \texttt{reduce optMax} applied to that is $O(n^2)$ work and $O(\log n)$. Adding all the costs together gives us $O(n^3)$ work and $O(\log n)$ span.

\end{questionfr}
\end{asstproblem}

\begin{asstproblem}
\title{Changing Implementations}
\info
\noindent For each of the following, solve the given work and span recurrences.
Show your work, and give your answers as tight Big-$O$ bounds in terms of $n$,
the length of the input. Review the \emph{Algorithm Analysis} lecture notes
to see techniques for solving recurrences. \textbf{Do not use the Master
Theorem}. (If you don't know what that is: great!)

\begin{questionfr}
\points 14
\prompt
These recurrences were given in Task 4.2. Solve them to
determine the asymptotic runtime behavior of your code. You may use any method
from class: tree, brick, or substitution.
\begin{align*}
  W(n) &= 2\;W\left(\frac n 2 \right) + O(1) \\
  S(n) &= S\left(\frac n 2 \right) + O(1)
\end{align*}

\answer
  \textbf{Work}:
  At level $i$ we do $2^i$ work so the work done geometrically increases by a factor of 2 each level. Thus since there are $\log n$ levels the amount of work done at the leaves is $O(2^{\log n}) = O(n)$, which by brick method is the total work of the tree.
%    \[ W(n) = 2\;W\left(\frac n 2 \right) + O(1)
%            \in O\left(\sum_{i=0}^{\log n} 2^i \right) = O(n) \]

  \textbf{Span}:
  At level $i$ we do $1$ work, so we simply sum up the work done on all $\log n$ levels.
    \[ S(n) = S\left(\frac n 2 \right) + O(1)
            \in O\left(\sum_{i=0}^{\log n} 1 \right) = O(\log n) \]

\end{questionfr}

\begin{questionfr}
\points 18
\prompt
In Task 4.2, we assumed \texttt{Seq} = \texttt{ArraySequence}. If we
instead used \texttt{TreeSequence}, then your work and span might have looked
something like the following.

\noindent Solve the work recurrence using the \emph{substitution} method. You
may use any of tree, brick, or substitution for the span recurrence.
\begin{align*}
  W(n) &= 2\;W\left(\frac n 2 \right) + O(\log n) \\
  S(n) &= S\left(\frac n 2 \right) + O(\log n)
\end{align*}

\answer
  \textbf{Work}:
  \[ W(n) = 2\;W\left(\frac n 2\right) + \log_2 n \]
  We want to show that $W(n) \in O(n)$. Specifically, we'll show
  that $W(n) = 3 n - \log_2 n - 2$, assuming $W(1) = 1$.

  When $n=1$, we have $W(n) = 1 = 3 n - \log_2 n - 2$.

  For $n>1$, we have
  \begin{align*}
    W(n) &= 2\;W\left(\frac n 2 \right) + \log_2 n \\
    &= 2\left(3 \frac n 2 - \log_2 \frac n 2 - 2\right) + \log_2 n \\
    &= 3 n - 2 \left(\log_2 n - 1) - 4 + \log_2 n \\
    &= 3 n - 2 \log_2 n - 2
  \end{align*}

  \textbf{Span}:
  Level $i$ does $\log \frac{n}{2^i} = \log n - i\log 2$. Sum up all levels of the tree.
  \begin{align*}
    S(n) &= S\left(\frac n 2\right) + O(\log n) \\
         &\in O\left(\sum_{i=1}^{\log_2 n} \log n - i\right)\\
         &= O\left( \sum_{i=1}^{\log_2 n} \log i \right) \\
         &= O\left( \log^2 n \right)
  \end{align*}
\end{questionfr}

\begin{questionfr}
\points 14

\prompt
Finally, if we used \texttt{ListSequence}, then your work and span
might look like the following. Solve these recurrences using any method from
class: tree, brick, or substitution.
\begin{align*}
  W(n) &= 2\;W\left(\frac n 2 \right) + O(n) \\
  S(n) &= S\left(\frac n 2 \right) + O(n)
\end{align*}

\answer
  \textbf{Work}
  At each level we do exactly $n$ work. There are $\log n$ levels so we simply sum up the tree.
\[ W(n) = 2W(\frac{n}{2}) + O(1) \in O(\sum_{i=0}^{\log n} n) = O(n\log n)\]

  \textbf{Span}
  At level $i$ we do $\frac{n}{2^i}$ work so the tree geometrically decreases by a factor of 2. Then by brick method this tree is root dominated and the span is $O(n)$.
\end{questionfr}
\end{asstproblem}
\end{assignment}
\end{book}
