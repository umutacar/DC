<?xml version='1.0' encoding='UTF-8'?>
<block name="chapter">
<field name="title">
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> 
<field name="title_src">
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> 
<field name="label">
ch:bsts
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[

]]>
</field> 
<field name="intro_src">
<![CDATA[
\picture{/210/bsts/abstract-tree.jpg}
]]>
</field> 
<block name="section">
<field name="title">
<![CDATA[
Motivation
]]>
</field> 
<field name="title_src">
<![CDATA[
Motivation
]]>
</field> 
<field name="label">
sec:motivation
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[
<p>Searching is one of the most important operations in computer science. Of the many search data structures that have been designed and are used in practice, search trees, more specifically balanced binary search trees, occupy a coveted place because of their broad applicability to many different sorts of problems. For example, in this book, we rely on binary search trees to implement set and table (dictionary) abstract data types (Chapter <a href="#ch:sets-tables" data-reference-type="ref" data-reference="ch:sets-tables">[ch:sets-tables]</a>), which are then used in the implementation of many algorithms, including for example graph algorithms.</p>
]]>
</field> 
<field name="intro_src">
<![CDATA[
Searching is one of the most important operations in computer science.
Of the many search data structures that have been designed and are
used in practice, search trees, more specifically balanced binary
search trees, occupy a coveted place because of their broad
applicability to many different sorts of problems.  For example, in
this book, we rely on binary search trees to implement set and table
(dictionary) abstract data types
(\chref{sets-tables}),
which are then used in the
implementation of many algorithms, including for example graph
algorithms.
]]>
</field> 
<block name="subsection">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
sec:motivation
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>If we are interested in searching a static or unchanging collection of elements, then we can use a simpler data structure such as sequences. For example, we can use a sequence with the array-based cost specification to implement an efficient search function by representing the collection as a sorted sequence and by using binary search. Such an implementation would yield a logarithmic-work search operation. If, however, we want to support dynamic collections, where for example, we insert new elements and delete existing elements, sequences would require linear work. Binary search trees, or  <span style="color: black"><span><strong><em>BSTs</em></strong></span></span> for short, make it possible to compute with dynamic collections by using insertions, deletions, as well as searches all in logarithmic number of tree operations.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
If we are interested in searching a static or unchanging collection of
elements, then we can use a simpler data structure such as sequences.
%
For example, we can use a sequence with the array-based cost
specification to implement an efficient search function by
representing the collection as a sorted sequence and by using binary
search.  
%
Such an implementation would yield a logarithmic-work search
operation.
%
If, however, we want to support dynamic collections, where for
example, we insert new elements and delete existing elements,
sequences would require linear work.
% 
Binary search trees, or~\defn{BSTs} for short, make it possible to
compute with dynamic collections by using insertions, deletions, as
well as searches all in logarithmic number of tree operations.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>In the traditional treatment of algorithms, which focuses on sequential algorithms, binary search trees revolve around three operations: insertion, deletion, and search. While these operations are important, they are not sufficient for parallelism, since they perform a single update at a time. We therefore consider aggregate update operations, such as union and difference, which can be used to insert and delete (respectively) many elements atonce.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
In the traditional treatment of algorithms, which focuses on
sequential algorithms, binary search trees revolve around three
operations: insertion, deletion, and search.
%
While these operations are important, they are not sufficient for
parallelism, since they perform a single update at a time.
% 
We therefore consider aggregate update operations, such as union and
difference, which can be used to insert and delete (respectively) many
elements atonce.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>In this section (Section <a href="#sec:motivation" data-reference-type="ref" data-reference="sec:motivation">[sec:motivation]</a>), we motivated the topic. The rest of this chapter is organized as follows. We first define binary search trees (Section <a href="#sec:bst::prelim" data-reference-type="ref" data-reference="sec:bst::prelim">[sec:bst::prelim]</a>) and present an ADT for them. (Section <a href="#sec:bst::adt" data-reference-type="ref" data-reference="sec:bst::adt">[sec:bst::adt]</a>). We then present a parametric implementation of the ADT (Section <a href="#sec:bst::parametric" data-reference-type="ref" data-reference="sec:bst::parametric">[sec:bst::parametric]</a>) by using only two operations, <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>, which respectively split a tree at a given key and join two trees. In Section <a href="#sec:bst::cost" data-reference-type="ref" data-reference="sec:bst::cost">[sec:bst::cost]</a>, we present a cost specification based on the parametric implementation, which achieves strong bounds as long as the <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations have logarithmic work and span. As a result, we are able to reduce the problem of implementing the BST ADT to the problem of implementing just the functions <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>. We finish the chapter by presenting a specific instance of the parametric implementation using Treaps (Section <a href="#sec:bst::treaps" data-reference-type="ref" data-reference="sec:bst::treaps">[sec:bst::treaps]</a>). Other possible implementation techniques are also described (Section <a href="#sec:bst::bsts-review" data-reference-type="ref" data-reference="sec:bst::bsts-review">[sec:bst::bsts-review]</a>)</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
In this section (\secref{motivation}), we motivated the topic.
%
The rest of this chapter is organized as follows. 
%
 We first define
binary search trees
(\secref{bst::prelim})
and present an ADT for them.
(\secref{bst::adt}). 
%
We then present a parametric implementation of the ADT
(\secref{bst::parametric})
by using only two operations, $\cd{split}$
and $\cd{join}$, which respectively split a tree at a given key and
join two trees.
%
In \secref{bst::cost},
we present a cost specification based on the
parametric implementation, which achieves strong bounds as long as the
$\cd{split}$ and $\cd{join}$ operations have logarithmic work and
span.
%
As a result, we are able to reduce the problem of implementing the BST
ADT to the problem of implementing just the functions $\cd{split}$
and $\cd{join}$.  
%
We finish the chapter by presenting a specific instance of the
parametric implementation using Treaps (\secref{bst::treaps}).
%
Other possible implementation techniques are also described
(\secref{bst::bsts-review})
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
ex:bst
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>An example binary search tree over the set of natural numbers <span class="math inline">\(\{1,3,4,5,6,7,8,9\}\)</span> is shown below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst2.jpg" alt="image" style="width:2.5in" /></p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst3.jpg" alt="image" style="width:1.8in" /></p></td>
</tr>
</tbody>
</table>
<p>On the left the <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> indicate the left (first) and right (second) child, respectively. All internal nodes (white) have a key associated with them while the leaves (black) are empty. The keys satisfy the BST property—for every node, the keys in the left subtree are less, and the ones in the right subtree are greater.</p>

<p>In the illustration on the left, the edges are oriented away from the root. They could have also been oriented towards the root. When illustrating binary search trees, we usually replace the directed arcs with undirected edges, leaving the orientation to be implicit. We also draw the left and right subtrees of a node on its left and right respectively. Following this convention, we can draw the tree on the left above as shown an the right. We use this convention in future figures.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
An example binary search tree over the set of natural numbers
$\{1,3,4,5,6,7,8,9\}$ is shown below.

\begin{tabular}{ccc}
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=2.5in]{/media/210/bsts/bst2.jpg}
\end{minipage}
%
& \quad\quad\quad &
%
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=1.8in]{/media/210/bsts/bst3.jpg}
\end{minipage}
\end{tabular}
On the left the $L$ and $R$ indicate the left (first) and right
(second) child, respectively.  All internal nodes (white) have a key
associated with them while the leaves (black) are empty.  The keys
satisfy the BST property---for every node, the keys in the left
subtree are less, and the ones in the right subtree are greater. 


\smallskip 

In the illustration on the left, the edges are oriented away from the
root. They could have also been oriented towards the root.
%
When illustrating binary search trees, we usually replace the directed
arcs with undirected edges, leaving the orientation to be implicit.
%
We also draw the left and right subtrees of a node on its left and
right respectively.
%
Following this convention, we can draw the tree on the left above as
shown an the right.
%
We use this convention in future figures.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
ex:bst
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>An example binary search tree over the set of natural numbers <span class="math inline">\(\{1,3,4,5,6,7,8,9\}\)</span> is shown below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst2.jpg" alt="image" style="width:2.5in" /></p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst3.jpg" alt="image" style="width:1.8in" /></p></td>
</tr>
</tbody>
</table>
<p>On the left the <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> indicate the left (first) and right (second) child, respectively. All internal nodes (white) have a key associated with them while the leaves (black) are empty. The keys satisfy the BST property—for every node, the keys in the left subtree are less, and the ones in the right subtree are greater.</p>

<p>In the illustration on the left, the edges are oriented away from the root. They could have also been oriented towards the root. When illustrating binary search trees, we usually replace the directed arcs with undirected edges, leaving the orientation to be implicit. We also draw the left and right subtrees of a node on its left and right respectively. Following this convention, we can draw the tree on the left above as shown an the right. We use this convention in future figures.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
An example binary search tree over the set of natural numbers
$\{1,3,4,5,6,7,8,9\}$ is shown below.

\begin{tabular}{ccc}
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=2.5in]{/media/210/bsts/bst2.jpg}
\end{minipage}
%
& \quad\quad\quad &
%
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=1.8in]{/media/210/bsts/bst3.jpg}
\end{minipage}
\end{tabular}
On the left the $L$ and $R$ indicate the left (first) and right
(second) child, respectively.  All internal nodes (white) have a key
associated with them while the leaves (black) are empty.  The keys
satisfy the BST property---for every node, the keys in the left
subtree are less, and the ones in the right subtree are greater. 


\smallskip 

In the illustration on the left, the edges are oriented away from the
root. They could have also been oriented towards the root.
%
When illustrating binary search trees, we usually replace the directed
arcs with undirected edges, leaving the orientation to be implicit.
%
We also draw the left and right subtrees of a node on its left and
right respectively.
%
Following this convention, we can draw the tree on the left above as
shown an the right.
%
We use this convention in future figures.
]]>
</field> 
</atom> 

</block></block></block> 
</block> 

<block name="section">
<field name="title">
<![CDATA[
Sets and Relations
]]>
</field> 
<field name="title_src">
<![CDATA[
Sets and Relations
]]>
</field> 
<field name="label">
sec:preliminaries_sets
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[
<p>This section presents a review of some basic definitions on sets and relations.</p>
]]>
</field> 
<field name="intro_src">
<![CDATA[
This section presents a review of some basic definitions on sets and
relations.
]]>
</field> 
<block name="subsection">
<field name="title">
<![CDATA[
Sets
]]>
</field> 
<field name="title_src">
<![CDATA[
Sets
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A  <span style="color: black"><span><strong><em>set</em></strong></span></span> is a collection of distinct objects. The objects that are contained in a set, are called  <span style="color: black"><span><strong><em>members</em></strong></span></span> or the  <span style="color: black"><span><strong><em>elements</em></strong></span></span> of the set. The elements of a set must be distinct: a set may not contain the same element more than once. The set that contains no elements is called the  <span style="color: black"><span><strong><em>empty set</em></strong></span></span> and is denoted by <span class="math inline">\(\{\}\)</span> or <span class="math inline">\(\emptyset\)</span>.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
A~\defn{set} is a collection of distinct objects.  The objects that
are contained in a set, are called~\defn{members} or
the~\defn{elements} of the set.  The elements of a set must be
distinct: a set may not contain the same element more than once. The
set that contains no elements is called the~\defn{empty set} and is
denoted by $\{\}$ or $\emptyset$.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
Specification
]]>
</field> 
<field name="title_src">
<![CDATA[
Specification
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Sets can be specified intentionally, by mathematically describing their members. For example, the set of natural numbers, traditionally written as <span class="math inline">\(\mathbb{N}\)</span>, can be specified  <span style="color: black"><span><strong><em>intentionally</em></strong></span></span> as the set of all nonnegative integral numbers. Sets can also be specified  <span style="color: black"><span><strong><em>extensionally</em></strong></span></span> by listing their members. For example, the set <span class="math inline">\(\mathbb{N}= \{0, 1, 2, \ldots\}.\)</span> We say that an element <span class="math inline">\(x\)</span> is a <span><em>member of</em></span> <span class="math inline">\(A\)</span>, written <span class="math inline">\(x \in  
A\)</span>, if <span class="math inline">\(x\)</span> is in <span class="math inline">\(A\)</span>. More generally, sets can be specified using  <span style="color: black"><span><strong><em>set comprehensions</em></strong></span></span>, which offer a compact and precise way to define sets by mixing intentional and extensional notation.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
Sets can be specified intentionally, by mathematically describing
their members.
%
For example, the set of natural numbers, traditionally written as
$\tynat$, can be specified~\defn{intentionally} as the set of all
nonnegative integral numbers.
%
Sets can also be specified~\defn{extensionally} by listing their members.
For example, the set $\tynat = \{0, 1, 2, \ldots\}.$
%
We say that an element $x$ is a {\em member of} $A$, written $x \in
A$, if $x$ is in $A$.  
%
More generally, sets can be specified using~\defn{set comprehensions},
which offer a compact and precise way to define sets by mixing
intentional and extensional notation.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="definition">
<field name="title">
<![CDATA[
Union and Intersection
]]>
</field> 
<field name="title_src">
<![CDATA[
Union and Intersection
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>For two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, the  <span style="color: black"><span><strong><em>union</em></strong></span></span> <span class="math inline">\(A \cup B\)</span> is defined as the set containing all the elements of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. Symmetrically, their  <span style="color: black"><span><strong><em>intersection</em></strong></span></span>, <span class="math inline">\(A \cap B\)</span> is the defined as the set containing the elements that are member of both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. We say that <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are  <span style="color: black"><span><strong><em>disjoint</em></strong></span></span> if their intersection is the empty set, i.e., <span class="math inline">\(A \cap B = \emptyset\)</span>.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
For two sets $A$ and $B$, the~\defn{union} $A \cup B$ is defined as
the set containing all the elements of $A$ and $B$.  Symmetrically,
their~\defn{intersection}, $A \cap B$ is the defined as the set
containing the elements that are member of both $A$ and $B$.
% 
We say that $A$ and $B$ are~\defn{disjoint} if their intersection is
the empty set, i.e., $A \cap B = \emptyset$.
%
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="definition">
<field name="title">
<![CDATA[
Cartesian Product
]]>
</field> 
<field name="title_src">
<![CDATA[
Cartesian Product
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Consider two sets <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. The  <span style="color: black"><span><strong><em>Cartesian product <span class="math inline">\(A \times  
  B\)</span></em></strong></span></span> is the set of all ordered pairs <span class="math inline">\((a,b)\)</span> where <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b  
\in B\)</span>, i.e., <span class="math display">\[A \times B = \left\{ (a,b) : a \in A, b \in B \right\}.\]</span></p>
]]>
</field> 
<field name="body_src">
<![CDATA[
Consider two sets~$A$ and~$B$.  The~\defn{Cartesian product $A \times
  B$} is the set of all ordered pairs $(a,b)$ where $a \in A$ and $b
\in B$, i.e.,
%
\[
A \times B = \cset{(a,b) : a \in A, b \in B}.
\]
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
ex:prelim_cartesian
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The Cartesian product of <span class="math inline">\(A = \left\{ 0,1,2,3 \right\}\)</span> and <span class="math inline">\(B = \left\{ a,b \right\}\)</span> is <span class="math display">\[\begin{array}{lll}  
A \times B = &amp; \{ &amp; (0,a),(0,b),(1,a),(1,b),  
\\  
             &amp;    &amp; (2,a),(2,b),(3,a),(3,b)   
\\  
             &amp; \}.  
\end{array}\]</span></p>
]]>
</field> 
<field name="body_src">
<![CDATA[
The Cartesian product of $A = \cset{0,1,2,3}$ and $B = \cset{a,b}$ is
\[
\begin{array}{lll}
A \times B = & \{ & (0,a),(0,b),(1,a),(1,b),
\\
             &    & (2,a),(2,b),(3,a),(3,b) 
\\
             & \}.
\end{array}
\]
]]>
</field> 
</atom> 
</block> 

</block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="definition">
<field name="title">
<![CDATA[
Set Partition
]]>
</field> 
<field name="title_src">
<![CDATA[
Set Partition
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Given a set <span class="math inline">\(A\)</span>, a partition of <span class="math inline">\(A\)</span> is a set <span class="math inline">\(P\)</span> of non-empty subsets of <span class="math inline">\(A\)</span> such that each element of <span class="math inline">\(P\)</span> is in exactly one subset in <span class="math inline">\(P\)</span>. We refer to each element of <span class="math inline">\(P\)</span> as a  <span style="color: black"><span><strong><em>block</em></strong></span></span> or a  <span style="color: black"><span><strong><em>part</em></strong></span></span> and the set <span class="math inline">\(P\)</span> as a  <span style="color: black"><span><strong><em>partition</em></strong></span></span> of <span class="math inline">\(A\)</span>. More precisely, <span class="math inline">\(P\)</span> is a partition of <span class="math inline">\(A\)</span> if the following conditions hold:</p>
<ul>
<li><p>if <span class="math inline">\(B \in P\)</span>, then <span class="math inline">\(B \not= \emptyset\)</span>,</p></li>
<li><p>if <span class="math inline">\(A = \bigcup_{B \in P}{B}\)</span>, and</p></li>
<li><p>if <span class="math inline">\(B, C \in P\)</span>, then <span class="math inline">\(B = C\)</span> or <span class="math inline">\(B \cap C = \emptyset\)</span>.</p></li>
</ul>
]]>
</field> 
<field name="body_src">
<![CDATA[
Given a set $A$, a partition of $A$ is a set $P$ of non-empty subsets
of $A$ such that each element of $P$ is in exactly one subset in $P$.
%
We refer to each element of $P$ as a~\defn{block} or a~\defn{part} and
the set $P$ as a~\defn{partition} of $A$.
%
More precisely, $P$ is a partition of $A$ if the following conditions
hold:
\begin{itemize}
\item if $B \in P$, then $B \not= \emptyset$,
\item if $A = \bigcup_{B \in P}{B}$, and
\item if $B, C \in P$, then $B = C$ or $B \cap C = \emptyset$.
\end{itemize}
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>If <span class="math inline">\(A = \{1, 2, 3, 4, 5, 6 \}\)</span> then <span class="math inline">\(P = \{ \{1,3,5\}, \{2, 4, 6\} \}\)</span> is a partition of <span class="math inline">\(A\)</span>. The set <span class="math inline">\(\{1,3,5\}\)</span> is a block.</p>
<p>The set <span class="math inline">\(Q = \{ \{1,3,5,6\}, \{2, 4, 6\} \}\)</span> is a not partition of <span class="math inline">\(A\)</span>, because the element <span class="math inline">\(6\)</span> is contained in any of the blocks.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
If $A = \{1, 2, 3, 4, 5, 6 \}$ then $P = \{ \{1,3,5\}, \{2, 4, 6\} \}$
is a partition of $A$.  The set $\{1,3,5\}$ is a block.

The set $Q = \{ \{1,3,5,6\}, \{2, 4, 6\} \}$ is a not partition of
$A$, because the element $6$ is contained in any of the blocks.
]]>
</field> 
</atom> 
</block> 

</block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="definition">
<field name="title">
<![CDATA[
Kleene Operators
]]>
</field> 
<field name="title_src">
<![CDATA[
Kleene Operators
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>For any set <span class="math inline">\(\Sigma\)</span>, its  <span style="color: black"><span><strong><em>Kleene star</em></strong></span></span> <span class="math inline">\(\Sigma^*\)</span> is the set of all possible strings consisting of members of <span class="math inline">\(\Sigma\)</span>, including the empty string.</p>
<p>For any set <span class="math inline">\(\Sigma\)</span>, its  <span style="color: black"><span><strong><em>Kleene plus</em></strong></span></span> <span class="math inline">\(\Sigma^+\)</span> is the set of all possible strings consisting of members <span class="math inline">\(\Sigma\)</span>, excluding the empty string.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
For any set $\Sigma$, its~\defn{Kleene star} $\Sigma^*$ is the set of
all possible strings consisting of members of $\Sigma$, including the
empty string.

For any set $\Sigma$, its~\defn{Kleene plus} $\Sigma^+$ is the set of
all possible strings consisting of members $\Sigma$, excluding the
empty string.
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Given <span class="math inline">\(\Sigma = \{\texttt{a},\texttt{b}\}\)</span>, <span class="math display">\[\begin{array}{rl}  
\Sigma^*   
%  
=   
%  
\{  
&amp;  
\text{&#39;}\,{}\,\text{&#39;},   
%  
\\  
&amp;  
\text{&#39;}\,{\texttt{a}}\,\text{&#39;}, \text{&#39;}\,{\texttt{b}}\,\text{&#39;},   
%  
\\  
&amp;  
\text{&#39;}\,{\texttt{aa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{ab}}\,\text{&#39;},   
\text{&#39;}\,{\texttt{ba}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bb}}\,\text{&#39;},   
\\  
%  
&amp;  
\text{&#39;}\,{\texttt{aaa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{aab}}\,\text{&#39;}, \text{&#39;}\,{\texttt{aba}}\,\text{&#39;},  
\text{&#39;}\,{\texttt{abb}}\,\text{&#39;},  
\\  
&amp; \text{&#39;}\,{\texttt{baa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bab}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bba}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bbb}}\,\text{&#39;},  
\\  
%  
&amp;  
\ldots  
\\  
\} &amp;  
\end{array}\]</span> and <span class="math display">\[\begin{array}{rl}  
\Sigma^+   
%  
=   
%  
\{  
&amp;  
\text{&#39;}\,{\texttt{a}}\,\text{&#39;}, \text{&#39;}\,{\texttt{b}}\,\text{&#39;},   
\\  
%  
&amp;  
\text{&#39;}\,{\texttt{aa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{ab}}\,\text{&#39;},   
\text{&#39;}\,{\texttt{ba}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bb}}\,\text{&#39;},   
\\  
%  
&amp;  
\text{&#39;}\,{\texttt{aaa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{aab}}\,\text{&#39;}, \text{&#39;}\,{\texttt{aba}}\,\text{&#39;}, \text{&#39;}\,{\texttt{abb}}\,\text{&#39;},   
\\  
&amp;  
\text{&#39;}\,{\texttt{baa}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bab}}\,\text{&#39;}, \text{&#39;}\,{\texttt{bba}}\,\text{&#39;},   
\text{&#39;}\,{\texttt{bbb}}\,\text{&#39;},  
\\  
%  
&amp; \ldots  
\\  
\} &amp;   
\\  
\end{array}\]</span></p>
]]>
</field> 
<field name="body_src">
<![CDATA[
Given $\Sigma = \{\texttt{a},\texttt{b}\}$,
\[
\begin{array}{rl}
\Sigma^* 
%
= 
%
\{
&
\str{}, 
%
\\
&
\str{\texttt{a}}, \str{\texttt{b}}, 
%
\\
&
\str{\texttt{aa}}, \str{\texttt{ab}}, 
\str{\texttt{ba}}, \str{\texttt{bb}}, 
\\
%
&
\str{\texttt{aaa}}, \str{\texttt{aab}}, \str{\texttt{aba}},
\str{\texttt{abb}},
\\
& \str{\texttt{baa}}, \str{\texttt{bab}}, \str{\texttt{bba}}, \str{\texttt{bbb}},
\\
%
&
\ldots
\\
\} &
\end{array}
\]
%
and
%
\[
\begin{array}{rl}
\Sigma^+ 
%
= 
%
\{
&
\str{\texttt{a}}, \str{\texttt{b}}, 
\\
%
&
\str{\texttt{aa}}, \str{\texttt{ab}}, 
\str{\texttt{ba}}, \str{\texttt{bb}}, 
\\
%
&
\str{\texttt{aaa}}, \str{\texttt{aab}}, \str{\texttt{aba}}, \str{\texttt{abb}}, 
\\
&
\str{\texttt{baa}}, \str{\texttt{bab}}, \str{\texttt{bba}}, 
\str{\texttt{bbb}},
\\
%
& \ldots
\\
\} & 
\\
\end{array}
\]
]]>
</field> 
</atom> 
</block> 

</block></block> 

<block name="subsection">
<field name="title">
<![CDATA[
Relations
]]>
</field> 
<field name="title_src">
<![CDATA[
Relations
]]>
</field> 
<field name="label">
subsection:preliminaries_relations
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="definition">
<field name="title">
<![CDATA[
Relation
]]>
</field> 
<field name="title_src">
<![CDATA[
Relation
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A  <span style="color: black"><span><strong><em>(binary)  <span style="color: black"><span><strong><em>relation</em></strong></span></span> from a set <span class="math inline">\(A\)</span> to set <span class="math inline">\(B\)</span></em></strong></span></span> is a subset of the Cartesian product of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. For a relation <span class="math inline">\(R \subseteq A \times B\)</span>,</p>
<ul>
<li><p>the set <span class="math inline">\(\left\{ a : (a,b) \in  
  R \right\}\)</span> is referred to as the  <span style="color: black"><span><strong><em>domain</em></strong></span></span> of <span class="math inline">\(R\)</span>, and</p></li>
<li><p>the set <span class="math inline">\(\left\{ b  
  : (a,b) \in R \right\}\)</span> is referred to as the  <span style="color: black"><span><strong><em>range</em></strong></span></span> of <span class="math inline">\(R\)</span>.</p></li>
</ul>
]]>
</field> 
<field name="body_src">
<![CDATA[
A~\defn{(binary)~\defn{relation} from a set~$A$ to set~$B$} is a
subset of the Cartesian product of~$A$ and~$B$.  
%
For a relation~$R \subseteq A \times B$, 
\begin{itemize}
\item the set~$\cset{a : (a,b) \in
  R}$ is referred to as the~\defn{domain} of $R$, and 
\item 
the set~$\cset{b
  : (a,b) \in R}$ is referred to as the~\defn{range} of $R$.
\end{itemize}
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="definition">
<field name="title">
<![CDATA[
Function
]]>
</field> 
<field name="title_src">
<![CDATA[
Function
]]>
</field> 
<field name="label">
...NOT.PROVIDED.LABEL...
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A  <span style="color: black"><span><strong><em>mapping from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span></em></strong></span></span> is a relation <span class="math inline">\(R \subset A \times B\)</span> such that <span class="math inline">\(|R| = |\mbox{domain}(R)|\)</span>, i.e., for every <span class="math inline">\(a\)</span> in the domain of <span class="math inline">\(R\)</span> there is only one <span class="math inline">\(b\)</span> such that <span class="math inline">\((a,b) \in R\)</span>. A mapping is also called a  <span style="color: black"><span><strong><em>function</em></strong></span></span>.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
A~\defn{mapping from $A$ to $B$} is a relation $R \subset A \times B$
such that $|R| = |\mbox{domain}(R)|$, i.e., for every $a$ in the
domain of $R$ there is only one $b$ such that $(a,b) \in R$.  A
mapping is also called a~\defn{function}.
]]>
</field> 
</atom> 

</block></block><block name="subsubsection"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><block name="group"><field name="label">...NOT.PROVIDED.LABEL...</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_src">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_src">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="label">
ex:prelim_sequencesdef
</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Consider the sets <span class="math inline">\(A = \left\{ 0,1,2,3 \right\}\)</span> and <span class="math inline">\(B = \left\{ a,b \right\}\)</span>.</p>
<p>The set: <span class="math display">\[X = \left\{ (0,a),(0,b),(1,b),(3,a) \right\}\]</span> is a relation from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> since <span class="math inline">\(X \subset A \times B\)</span>, but not a mapping (function) since <span class="math inline">\(0\)</span> is repeated.</p>
<p>The set <span class="math display">\[Y = \left\{ (0,a),(1,b),(3,a) \right\}\]</span> is both a relation and a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> since each element only appears once on the left.</p>
<p>The domain of <span class="math inline">\(Y\)</span> is <span class="math inline">\(\left\{ 0,1,3 \right\}\)</span> and the range is <span class="math inline">\(\left\{ a,b \right\}\)</span>. It is, however, not a sequence since there is a gap in the domain.</p>
]]>
</field> 
<field name="body_src">
<![CDATA[
Consider the sets $A = \cset{0,1,2,3}$ and $B = \cset{a,b}$.

The set:
\[X = \cset{(0,a),(0,b),(1,b),(3,a)}\]
is a relation from $A$ to $B$ since $X \subset A \times B$, but not a mapping (function) since $0$
is repeated.   

The set
\[Y = \cset{(0,a),(1,b),(3,a)}\]
is both a relation and a function from $A$ to $B$ since each element
only appears once on the left.  

The domain of $Y$ is $\cset{0,1,3}$ and the range is $\cset{a,b}$.  It
is, however, not a sequence since there is a gap in the domain.
]]>
</field> 
</atom> 

</block></block></block> 
</block> 
</block>
