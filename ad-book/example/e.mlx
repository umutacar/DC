<?xml version='1.0' encoding='UTF-8'?>
<block name="course">
<field name="title">
<![CDATA[
Parallel and Sequential Algorithms (Fall 2019)
]]>
</field> 
<field name="title_raw">
<![CDATA[
Parallel and Sequential Algorithms (Fall 2019)
]]>
</field> 
<field name="unique">course15210</field><field name="label">course15210</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="coursenumber">
15210
</field> 
<field name="picture">
/210/course/air-pavilion.jpg
</field> 
<field name="semester">
Spring 2018
</field> 
<field name="website">
http://www.cs.cmu.edu/~15210
</field> 
<field name="providesbook">
S18
</field> 
<field name="provideschapter">
21
</field> 
<field name="providessection">
1
</field> 
<field name="providesunit">
1
</field> 
<field name="providesassignment">
1
</field> 
<field name="intro">
<![CDATA[
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>
]]>
</field> 
<field name="intro_raw">
<![CDATA[
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
]]>
</field> 

<block name="book">
<field name="title">
<![CDATA[
Algorithm Design: Parallel and Sequential (Fall 2019)
]]>
</field> 
<field name="title_raw">
<![CDATA[
Algorithm Design: Parallel and Sequential (Fall 2019)
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018</field><field name="label">course15210:semesterSpring 2018</field> 
<field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="authors">
Umut A. Acar and Guy Blelloch
</field> 
<block name="chapter">
<field name="title">
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> 
<field name="title_raw">
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21</field><field name="label">
ch:bsts
</field> 
<field name="no">21</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="picture">
/210/bsts/abstract-tree.jpg
</field> 
<field name="intro">
<![CDATA[
<p>...NOT.PROVIDED.INTRO...</p>
]]>
</field> 
<field name="intro_raw">
<![CDATA[
...NOT.PROVIDED.INTRO...
]]>
</field> 
<block name="section">
<field name="title">
<![CDATA[
Motivation
]]>
</field> 
<field name="title_raw">
<![CDATA[
Motivation
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section1</field><field name="label">course15210:semesterSpring 2018:chapter21:section1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[
<p>Searching is one of the most important operations in computer science. Of the many search data structures that have been designed and are used in practice, search trees, more specifically balanced binary search trees, occupy a coveted place because of their broad applicability to many different sorts of problems. For example, in this book, we rely on binary search trees to implement set and table (dictionary) abstract data types which are then used in the implementation of many algorithms, including for example graph algorithms.</p>
]]>
</field> 
<field name="intro_raw">
<![CDATA[
Searching is one of the most important operations in computer science.
Of the many search data structures that have been designed and are
used in practice, search trees, more specifically balanced binary
search trees, occupy a coveted place because of their broad
applicability to many different sorts of problems.  For example, in
this book, we rely on binary search trees to implement set and table
(dictionary) abstract data types
%(\chref{sets-tables}),
which are then used in the
implementation of many algorithms, including for example graph
algorithms.
]]>
</field> 
<block name="unit">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1</field><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group1</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group1</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">1</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group1:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group1:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>If we are interested in searching a static or unchanging collection of elements, then we can use a simpler data structure such as sequences. For example, we can use a sequence with the array-based cost specification to implement an efficient search function by representing the collection as a sorted sequence and by using binary search. Such an implementation would yield a logarithmic-work search operation. If, however, we want to support dynamic collections, where for example, we insert new elements and delete existing elements, sequences would require linear work. Binary search trees, or <span> </span> for short, make it possible to compute with dynamic collections by using insertions, deletions, as well as searches all in logarithmic number of tree operations.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
If we are interested in searching a static or unchanging collection of
elements, then we can use a simpler data structure such as sequences.
%
For example, we can use a sequence with the array-based cost
specification to implement an efficient search function by
representing the collection as a sorted sequence and by using binary
search.  
%
Such an implementation would yield a logarithmic-work search
operation.
%
If, however, we want to support dynamic collections, where for
example, we insert new elements and delete existing elements,
sequences would require linear work.
% 
Binary search trees, or~\defn{BSTs} for short, make it possible to
compute with dynamic collections by using insertions, deletions, as
well as searches all in logarithmic number of tree operations.
]]>
</field> 
</atom> 

</block><block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group2</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group2</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">2</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group2:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group2:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>In the traditional treatment of algorithms, which focuses on sequential algorithms, binary search trees revolve around three operations: insertion, deletion, and search. While these operations are important, they are not sufficient for parallelism, since they perform a single update at a time. We therefore consider aggregate update operations, such as union and difference, which can be used to insert and delete (respectively) many elements atonce.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
In the traditional treatment of algorithms, which focuses on
sequential algorithms, binary search trees revolve around three
operations: insertion, deletion, and search.
%
While these operations are important, they are not sufficient for
parallelism, since they perform a single update at a time.
% 
We therefore consider aggregate update operations, such as union and
difference, which can be used to insert and delete (respectively) many
elements atonce.
]]>
</field> 
</atom> 

</block><block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group3</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group3</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">3</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section1:unit1:group3:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section1:unit1:group3:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The rest of this chapter is organized as follows. We first define binary search trees and present an ADT for them. We then present a parametric implementation of the ADT by using only two operations, <span class="math inline">\({\texttt{split}}\)</span> and <span class="math inline">\({\texttt{join}}\)</span>, which respectively split a tree at a given key and join two trees. Next, we present a cost specification based on the parametric implementation, which achieves strong bounds as long as the <span class="math inline">\({\texttt{split}}\)</span> and <span class="math inline">\({\texttt{join}}\)</span> operations have logarithmic work and span. As a result, we are able to reduce the problem of implementing the BST ADT to the problem of implementing just the functions <span class="math inline">\({\texttt{split}}\)</span> and <span class="math inline">\({\texttt{join}}\)</span>. We finish the chapter by presenting a specific instance of the parametric implementation using Treaps. Other possible implementation techniques are also described.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The rest of this chapter is organized as follows.  We first define
binary search trees
%(\secref{bst::prelim})
and present an ADT for them.
%(\secref{bst::adt}). 
%
We then present a parametric implementation of the ADT
%(\secref{bst::parametric})
by using only two operations, $\cd{split}$
and $\cd{join}$, which respectively split a tree at a given key and
join two trees.
%
%In \secref{bst::cost},
Next, we present a cost specification based on the
parametric implementation, which achieves strong bounds as long as the
$\cd{split}$ and $\cd{join}$ operations have logarithmic work and
span.
%
As a result, we are able to reduce the problem of implementing the BST
ADT to the problem of implementing just the functions $\cd{split}$
and $\cd{join}$.  
%
We finish the chapter by presenting a specific instance of the
parametric implementation using Treaps.
%(\secref{bst::treaps}).
%
Other possible implementation techniques are also described.
%(\secref{bst::bsts-review})
]]>
</field> 
</atom> 

</block></block> 
</block> 

<block name="section">
<field name="title">
<![CDATA[
Preliminaries
]]>
</field> 
<field name="title_raw">
<![CDATA[
Preliminaries
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2</field><field name="label">
sec:bst::prelim
</field> 
<field name="no">2</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[
<p>...NOT.PROVIDED.INTRO...</p>
]]>
</field> 
<field name="intro_raw">
<![CDATA[
...NOT.PROVIDED.INTRO...
]]>
</field> 
<block name="unit">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1</field><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group1</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group1</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">1</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group1:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group1:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>We start with some basic definitions and terminology involving rooted and binary search trees. Recall first that a rooted tree is a tree with a distinguished root node. A <span> </span> is a rooted tree, where each node is either a <span> </span>, which has no children, or an <span> </span>, which have a left and a right child.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
We start with some basic definitions and terminology involving rooted
and binary search trees.  Recall first that a rooted tree is a tree
with a distinguished root node.
%(\defref{prelim::rootedtree}). 
%
A~\defn{full binary tree} is a rooted tree, where each node is either
a~\defn{leaf}, which has no children, or an~\defn{internal node},
which have a left and a right child.
%(\defref{bst::binarytree}).
%
]]>
</field> 
</atom> 

</block><block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group2</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group2</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">2</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="definition">
<field name="title">
<![CDATA[
Full Binary Tree
]]>
</field> 
<field name="title_raw">
<![CDATA[
Full Binary Tree
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group2:atom1</field><field name="label">
def:bst::binarytree
</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A <span> </span> is an ordered rooted tree in which every internal node has exactly two children: the first or the <span> </span> and the second or the <span> </span>. The <span> </span> of a node is the subtree rooted at the left child, and the <span> </span> the one rooted at the right child.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
A~\defn{full binary tree} is an ordered rooted tree in which every
internal node has exactly two children: the first or the~\defn{left
  child} and the second or the~\defn{right child}.  
%
The~\defn{left subtree} of a node is the subtree rooted at the left
child, and the~\defn{right subtree} the one rooted at the right child.
]]>
</field> 
</atom> 

</block><block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group3</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group3</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">3</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group3:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group3:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A binary search tree is a full binary tree, where each internal node <span class="math inline">\(u\)</span> has a unique key <span class="math inline">\(k\)</span> such that each node in its left subtree has a key less than <span class="math inline">\(k\)</span> and each node in its right subtree has a key greater that <span class="math inline">\(x\)</span>.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
A binary search tree is a full binary tree, where each internal node
$u$ has a unique key~$k$ such that each node in its left subtree has a
key less than $k$ and each node in its right subtree has a key greater
that $x$.  
%
]]>
</field> 
</atom> 

</block><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group4</field><field name="label">course15210:semesterSpring 2018:chapter21:section2:unit1:group4</field> 
<field name="no">4</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="definition">
<field name="title">
<![CDATA[
Binary Search Tree (BST)
]]>
</field> 
<field name="title_raw">
<![CDATA[
Binary Search Tree (BST)
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group4:atom1</field><field name="label">
def:bst::bst
</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>A <span> </span> (BST) over a totally ordered set <span class="math inline">\(S\)</span> is a full binary tree that satisfies the following conditions.</p>
<ol>
<li><p>There is a one-to-one mapping <span class="math inline">\(k(v)\)</span> from internal tree nodes to elements in <span class="math inline">\(S\)</span>.</p></li>
<li><p>for every <span class="math inline">\(u\)</span> in the left subtree of <span class="math inline">\(v\)</span>, <span class="math inline">\(k(u) &lt; k(v)\)</span></p></li>
<li><p>for every <span class="math inline">\(u\)</span> in the right subtree of <span class="math inline">\(v\)</span>, <span class="math inline">\(k(u) &gt; k(v)\)</span></p></li>
</ol>
<p>In the definition, conditions 2 and 3 are referred to as the <span> </span>. We often refer to the elements of <span class="math inline">\(S\)</span> in a BST as keys, and use <span class="math inline">\({\textsf{dom}(T)}\)</span> to indicate the domain (keys) in a BST <span class="math inline">\(T\)</span>. The <span> </span> of a BST is the number of keys in the tree, i.e. <span class="math inline">\(|S|\)</span>.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
A~\defn{binary search tree} (BST) over a totally ordered set $S$ is a
full binary tree that satisfies the following conditions.
\begin{enumerate}
 \item There is a one-to-one mapping $k(v)$ from internal tree nodes to elements in $S$.
 \item for every $u$ in the left subtree of $v$, $k(u) < k(v)$
 \item for every $u$ in the right subtree of $v$, $k(u) > k(v)$
\end{enumerate}
%
In the definition, conditions 2 and 3 are referred to as the~\defn{BST
  property}.  We often refer to the elements of $S$ in a BST as keys,
and use $\dom{T}$ to indicate the domain (keys) in a BST $T$.
The~\defn{size} of a BST is the number of keys in the tree,
i.e. $|S|$.


% A BST can equivalently be defined recursively as:
% \[
% \cd{BST}(S) = \left\{\begin{array}{ll}
% \cd{Leaf} & S = \emptyset\\
% \cd{iNode}(\cd{BST}(S_L), k, \cd{BST}(S_R)) & 
% \underbrace{(S = S_L \cup \cset{k} \cup S_R)}_{\mbox{one to one (inclusion)}} \wedge \underbrace{(S_L < k < S_R)}_{\mbox{BST property}}
% \end{array}\right.
% \]
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section2:unit1:group4:atom2</field><field name="label">
ex:bst
</field> 
<field name="no">2</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>An example binary search tree over the set of natural numbers <span class="math inline">\(\{1,3,4,5,6,7,8,9\}\)</span> is shown below.</p>
<p><span>ccc</span></p>
<p><img src="/media/210/bsts/bst2.jpg" alt="image" width="240" /></p>
<p>&amp; &amp;</p>
<p><img src="/media/210/bsts/bst3.jpg" alt="image" width="172" /></p>
<p>On the left the <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> indicate the left (first) and right (second) child, respectively. All internal nodes (white) have a key associated with them while the leaves (black) are empty. The keys satisfy the BST property—for every node, the keys in the left subtree are less, and the ones in the right subtree are greater.</p>
<p>In the illustration on the left, the edges are oriented away from the root. They could have also been oriented towards the root. When illustrating binary search trees, we usually replace the directed arcs with undirected edges, leaving the orientation to be implicit. We also draw the left and right subtrees of a node on its left and right respectively. Following this convention, we can draw the tree on the left above as shown an the right. We use this convention in future figures.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
An example binary search tree over the set of natural numbers
$\{1,3,4,5,6,7,8,9\}$ is shown below.

\begin{tabular}{ccc}
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=2.5in]{/media/210/bsts/bst2.jpg}
\end{minipage}
%
& \quad\quad\quad &
%
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=1.8in]{/media/210/bsts/bst3.jpg}
\end{minipage}
\end{tabular}
On the left the $L$ and $R$ indicate the left (first) and right
(second) child, respectively.  All internal nodes (white) have a key
associated with them while the leaves (black) are empty.  The keys
satisfy the BST property---for every node, the keys in the left
subtree are less, and the ones in the right subtree are greater. 


\smallskip 

In the illustration on the left, the edges are oriented away from the
root. They could have also been oriented towards the root.
%
When illustrating binary search trees, we usually replace the directed
arcs with undirected edges, leaving the orientation to be implicit.
%
We also draw the left and right subtrees of a node on its left and
right respectively.
%
Following this convention, we can draw the tree on the left above as
shown an the right.
%
We use this convention in future figures.
]]>
</field> 
</atom> 
</block> 

</block> 
</block> 

<block name="section">
<field name="title">
<![CDATA[
The BST Abstract Data Type
]]>
</field> 
<field name="title_raw">
<![CDATA[
The BST Abstract Data Type
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3</field><field name="label">
sec:bst::adt
</field> 
<field name="no">3</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="intro">
<![CDATA[
<p>...NOT.PROVIDED.INTRO...</p>
]]>
</field> 
<field name="intro_raw">
<![CDATA[
...NOT.PROVIDED.INTRO...
]]>
</field> 
<block name="unit">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group1</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group1</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">1</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group1:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group1:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The Abstract Data Type specification below describes an ADT for BSTs parametrized by a totally ordered key set. We briefly describe this ADT and present some examples. As we shall see, the BST ADT can be implemented in many ways. In order to present concrete examples, we assume an implementation but do not specify it.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The Abstract Data Type specification below describes an ADT for BSTs
parametrized by a totally ordered key set. We briefly describe this
ADT and present some examples. As we shall see, the BST ADT can be
implemented in many ways.  In order to present concrete examples, we
assume an implementation but do not specify it.
]]>
</field> 
</atom> 

</block><block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group2</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group2</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">2</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="datatype">
<field name="title">
<![CDATA[
Binary Search Tree (BST)
]]>
</field> 
<field name="title_raw">
<![CDATA[
Binary Search Tree (BST)
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group2:atom1</field><field name="label">
adt:bst::adt
</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>For a universe of totally ordered keys <span class="math inline">\({{{\mathbb{K}}}}\)</span>, the BST ADT consists of a type <span class="math inline">\({{{{\mathbb{T}}}}}\)</span> representing a power set of keys and the functions whose types are specified as follows.</p>
<p><span class="math display">\[\begin{array}{lcl} 
\texttt{empty} &amp; : &amp;{{{{\mathbb{T}}}}}\\ 
{\texttt{singleton}} &amp; : &amp; {{{\mathbb{K}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{find}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{\mathbb{K}}}}{\rightarrow}{{{\mathbb{B}}}}\\ 
{\texttt{delete}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{\mathbb{K}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{insert}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{\mathbb{K}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{intersection}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{difference}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{union}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}\\ 
{\texttt{split}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{\mathbb{K}}}}{\rightarrow}({{{{\mathbb{T}}}}}\times {{{\mathbb{B}}}}\times {{{{\mathbb{T}}}}}) 
\\ 
{\texttt{join}} 
&amp; : &amp; {{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}{\rightarrow}{{{{\mathbb{T}}}}}\end{array}\]</span></p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
For a universe of totally ordered keys $\kkk$, the BST ADT
consists of a type $\bstt$ representing a power set of keys and the
functions whose types are specified as follows. 

\[
\begin{array}{lcl}
\texttt{empty} & : &\bstt
\\
%
\cd{singleton} & : & \kkk \ra \bstt
\\
%
\cd{find}
& : & \bstt \ra \kkk \ra \bbb
\\
%
\cd{delete}
& : & \bstt \ra \kkk \ra  \bstt
\\
\cd{insert}
& : & \bstt \ra \kkk \ra  \bstt
\\
%
\cd{intersection}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{difference}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{union}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{split}
& : & \bstt \ra \kkk \ra (\bstt \times \bbb \times \bstt)
\\
\cd{join}
& : & \bstt \ra \bstt \ra \bstt 
\end{array}
\]
]]>
</field> 
</atom> 

</block><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group3</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group3</field> 
<field name="no">3</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="gram">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The ADT supports two constructors: <span class="math inline">\({\texttt{empty}}\)</span> creates an empty BST and <span class="math inline">\({\texttt{singleton}}\)</span> creates a BST with a single key. The function <span class="math inline">\({\texttt{find}}\)</span> searches for a given key and returns a boolean indicating success.</p>
<p>The functions <span class="math inline">\({\texttt{insert}}\)</span> and <span class="math inline">\({\texttt{delete}}\)</span> insert and delete a given key into or from the BST.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The ADT supports two constructors: $\cd{empty}$ creates an empty BST
  and $\cd{singleton}$ creates a BST with a single key.
%

The function $\cd{find}$ searches for a given key and returns a
boolean indicating success.

The functions $\cd{insert}$ and $\cd{delete}$ insert and delete a
given key into or from the BST.
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom2</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom2</field> 
<field name="no">2</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Searching in BSTs illustrated.</p>
<ul>
<li><p>Searching for <span class="math inline">\(5\)</span> in the input tree returns <span class="math inline">\({\texttt{true}}.\)</span></p>
<p><span class="math inline">\({\texttt{find}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{5}}\)</span> <span class="math inline">\(~=~\)</span> <span class="math inline">\({\texttt{true}}\)</span></p></li>
<li><p>Searching for <span class="math inline">\(6\)</span> in the input tree returns <span class="math inline">\({\texttt{false}}.\)</span> <span class="math inline">\({\texttt{find}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{6}}\)</span> <span class="math inline">\(~=~\)</span> <span class="math inline">\({\texttt{false}}\)</span></p></li>
</ul>
]]>
</field> 
<field name="body_raw">
<![CDATA[
Searching in BSTs illustrated.

\begin{itemize}
\item 
Searching for  $5$  in the input tree returns $\cd{true}.$

$\cd{find}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{5}$
$~=~$
$\cd{true}$

\item 
Searching for  $6$  in the input tree returns $\cd{false}.$
%

$\cd{find}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
$~=~$ 
$\cd{false}$

\end{itemize}
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
Insertion
]]>
</field> 
<field name="title_raw">
<![CDATA[
Insertion
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom3</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom3</field> 
<field name="no">3</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Inserting the key <span class="math inline">\(6\)</span> into the input tree returns a new tree including <span class="math inline">\(6\)</span>. <span class="math inline">\({\texttt{insert}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{6}}\)</span> = <img src="/media/210/bsts/bst5.jpg" alt="image" width="113" /></p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
Inserting the key $6$  into the input tree returns a new tree including $6$.
%

$\cd{insert}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
=
\includegraphics[width=3cm]{/media/210/bsts/bst5.jpg}
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
Deletion
]]>
</field> 
<field name="title_raw">
<![CDATA[
Deletion
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom4</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group3:atom4</field> 
<field name="no">4</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>Deleting the key <span class="math inline">\(6\)</span> from the input tree returns a tree without it. <span class="math inline">\({\texttt{delete}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst5.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{6}}\)</span> = <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /></p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
Deleting the key  $6$ from the input tree returns a tree without it.
%

$\cd{delete}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst5.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
= 
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
]]>
</field> 
</atom> 
</block> 

<block name="group"><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group4</field><field name="no">0</field><field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group4</field><field name="parents">...NOT.PROVIDED.PARENTS...</field><field name="no">4</field><field name="title">...NOT.PROVIDED.TITLE...</field><field name="title_raw">...NOT.PROVIDED.TITLE...</field><field name="unique">0</field><atom name="gram">
<field name="title">
<![CDATA[
Union
]]>
</field> 
<field name="title_raw">
<![CDATA[
Union
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group4:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group4:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The function <span class="math inline">\({\texttt{union}}\)</span> takes two BSTs and returns a BST that contains all the keys in them; <span class="math inline">\({\texttt{union}}\)</span> is an aggregate insert operation. The function <span class="math inline">\({\texttt{intersection}}\)</span> takes two BSTs and returns a BST that contains the keys common in both. The function <span class="math inline">\({\texttt{difference}}\)</span> takes two BSTs <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> and returns a BST that contains the keys in <span class="math inline">\(t_1\)</span> that are not in <span class="math inline">\(t_2\)</span>; <span class="math inline">\({\texttt{difference}}\)</span> is an aggregate delete operation.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The function $\cd{union}$ takes two BSTs and returns a BST that
contains all the keys in them; $\cd{union}$ is an aggregate insert
operation.
% 
The function $\cd{intersection}$ takes two BSTs and returns a BST
that contains the keys common in both.
% 
The function $\cd{difference}$ takes two BSTs $t_1$ and $t_2$ and returns
a BST that contains the keys in $t_1$ that are not in $t_2$;
$\cd{difference}$ is an aggregate delete operation.
]]>
</field> 
</atom> 

</block><block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group5</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group5</field> 
<field name="no">5</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="gram">
<field name="title">
<![CDATA[
Split
]]>
</field> 
<field name="title_raw">
<![CDATA[
Split
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group5:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group5:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The function <span class="math inline">\({\texttt{split}}\)</span> takes a tree <span class="math inline">\(t\)</span> and a key <span class="math inline">\(k\)</span> and splits <span class="math inline">\(t\)</span> into two trees: one consisting of all the keys of <span class="math inline">\(t\)</span> less than <span class="math inline">\(k\)</span>, and another consisting of all the keys of <span class="math inline">\(t\)</span> greater than <span class="math inline">\(k\)</span>. It also returns a Boolean value indicating whether <span class="math inline">\(k\)</span> appears in <span class="math inline">\(t\)</span>. The exact structure of the trees returned by <span class="math inline">\({\texttt{split}}\)</span> can differ from one implementation to another: the specification only requires that the resulting trees to be valid BSTs and that they contain the keys less than <span class="math inline">\(k\)</span> and greater than <span class="math inline">\(k\)</span>, leaving their structure otherwise unspecified.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The function $\cd{split}$ takes a tree $t$ and a key $k$ and
splits $t$ into two trees: one consisting of all the keys of $t$ less
than $k$, and another consisting of all the keys of $t$ greater than
$k$.  
%
It also returns a Boolean value indicating whether $k$ appears in $t$.
%
The exact structure of the trees returned by $\cd{split}$ can differ
from one implementation to another: the specification only requires
that the resulting trees to be valid BSTs and that they contain the
keys less than $k$ and greater than $k$, leaving their structure
otherwise unspecified.
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group5:atom2</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group5:atom2</field> 
<field name="no">2</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The function <span class="math inline">\({\texttt{split}}\)</span> illustrated.</p>
<ul>
<li><p>Splitting the input tree at <span class="math inline">\(6\)</span> yields two trees, consisting of the keys less that <span class="math inline">\(6\)</span> and those greater that <span class="math inline">\(6\)</span>, indicating also that <span class="math inline">\(6\)</span> is not in the input tree.</p>
<p><span class="math inline">\({\texttt{split}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{6}}\)</span> <span class="math inline">\(~~=~~\)</span> <span class="math inline">\({\left(\\[1.5cm]\right.}\)</span> <img src="/media/210/bsts/bst4a.jpg" alt="image" width="37" />  , <span class="math inline">\({\texttt{False}}\)</span> ,   <img src="/media/210/bsts/bst4b.jpg" alt="image" width="75" /> <span class="math inline">\({\left.\\[1.5cm]\right)}\)</span></p></li>
<li><p>Splitting the input tree at <span class="math inline">\(5\)</span> yields two trees, consisting of the keys less than <span class="math inline">\(5\)</span> and those greater than <span class="math inline">\(5\)</span>, indicating also that <span class="math inline">\(5\)</span> is found in the input tree.</p>
<p><span class="math inline">\({\texttt{split}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span>   <span class="math inline">\({\texttt{5}}\)</span> <span class="math inline">\(~~=~~\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <span><img src="/media/210/bsts/bst4c.jpg" alt="image" width="26" /></span>  ,  <span class="math inline">\({\texttt{True}}\)</span> ,   <span><img src="/media/210/bsts/bst4b.jpg" alt="image" width="75" /></span> <span class="math inline">\({\left.\\[2cm]\right)}\)</span></p></li>
</ul>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The function $\cd{split}$ illustrated.

\begin{itemize}
\item 
Splitting the input tree at $6$ yields two trees, consisting of the
keys less that $6$ and those greater that $6$, indicating also that
$6$ is not in the input tree. 

$\cd{split}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
$~~=~~$
$\leftparen{1.5cm}$
\includegraphics[width=1cm]{/media/210/bsts/bst4a.jpg}~~,
$\cd{False}$~,~~
\includegraphics[width=2cm]{/media/210/bsts/bst4b.jpg}
$\rightparen{1.5cm}$

\item 
Splitting the input tree at $5$ yields two trees, consisting of the
keys less than $5$ and those greater than $5$, indicating also that
$5$ is found in the input tree. 

$\cd{split}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{5}$
%
$~~=~~$
%
$\leftparen{2cm}$
{\includegraphics[width=7mm]{/media/210/bsts/bst4c.jpg}}~~,
~$\cd{True}$~,~~
{\includegraphics[width=2cm]{/media/210/bsts/bst4b.jpg}}
$\rightparen{2cm}$
\end{itemize}
]]>
</field> 
</atom> 
</block> 

<block name="group">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group6</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group6</field> 
<field name="no">6</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<atom name="gram">
<field name="title">
<![CDATA[
Join
]]>
</field> 
<field name="title_raw">
<![CDATA[
Join
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group6:atom1</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group6:atom1</field> 
<field name="no">1</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The function <span class="math inline">\({\texttt{join}}\)</span> takes two trees <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> such that all the keys in <span class="math inline">\(t_1\)</span> are less than the keys in <span class="math inline">\(t_2\)</span>. The function returns a tree that contains all the keys in <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span>. The exact structure of the tree returned by <span class="math inline">\({\texttt{join}}\)</span> can differ from one implementation to another: the specification only requires that the resulting tree is a valid BST and that it contains all the keys in the trees joined.</p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The function $\cd{join}$ takes two trees $t_1$ and $t_2$
such that all the keys in $t_1$ are less than the keys in $t_2$.  The
function returns a tree that contains all the keys in $t_1$ and $t_2$.
%
The exact structure of the tree returned by $\cd{join}$ can differ
from one implementation to another: the specification only requires
that the resulting tree is a valid BST and that it contains all the
keys in the trees joined.
]]>
</field> 
</atom> 

<atom name="example">
<field name="title">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="title_raw">
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> 
<field name="unique">course15210:semesterSpring 2018:chapter21:section3:unit1:group6:atom2</field><field name="label">course15210:semesterSpring 2018:chapter21:section3:unit1:group6:atom2</field> 
<field name="no">2</field><field name="parents">
...NOT.PROVIDED.PARENTS...
</field> 
<field name="body">
<![CDATA[
<p>The function <span class="math inline">\({\texttt{join}}\)</span> illustrated.</p>
<p><span class="math inline">\({\texttt{join}}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <img src="/media/210/bsts/bst4a.jpg" alt="image" width="37" /> <span class="math inline">\({\left.\\[2cm]\right)}\)</span> <span class="math inline">\({\left(\\[2cm]\right.}\)</span> <span><img src="/media/210/bsts/bst6.jpg" alt="image" width="113" /></span> <span class="math inline">\({\left.\\[2cm]\right)}\)</span> <span class="math inline">\(~~=~~\)</span> <span><img src="/media/210/bsts/bst4.jpg" alt="image" width="113" /></span></p>
]]>
</field> 
<field name="body_raw">
<![CDATA[
The function $\cd{join}$ illustrated.

$\cd{join}$
$\leftparen{2cm}$
\includegraphics[width=1.0cm]{/media/210/bsts/bst4a.jpg}
$\rightparen{2cm}$
%
$\leftparen{2cm}$
{\includegraphics[width=3cm]{/media/210/bsts/bst6.jpg}}
$\rightparen{2cm}$
%
$~~=~~$
%
{\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}}
]]>
</field> 
</atom> 
</block> 

</block> 
</block> 
</block> 
</block> 
</block>
