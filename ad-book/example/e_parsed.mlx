<?xml version="1.0" encoding="UTF-8"?>
<block name='course'>
<field name='title'>
<![CDATA[
Parallel and Sequential Algorithms (Fall 2018)
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Parallel and Sequential Algorithms (Fall 2018)
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='coursenumber'>
15210
</field> <!-- coursenumber -->
<field name='picture'>
/210/course/air-pavilion.jpg
</field> <!-- picture -->
<field name='semester'>
Spring 2018
</field> <!-- semester -->
<field name='website'>
http://www.cs.cmu.edu/~15210
</field> <!-- website -->
<field name='providesbook'>
S18
</field> <!-- providesbook -->
<field name='provideschapter'>
21
</field> <!-- provideschapter -->
<field name='providessection'>
1
</field> <!-- providessection -->
<field name='providessubsection'>
1
</field> <!-- providessubsection -->
<field name='providesassignment'>
1
</field> <!-- providesassignment -->
<field name='intro'>
<![CDATA[
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>
]]>
</field> <!-- intro -->
<field name='intro_src'>
<![CDATA[
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
]]>
</field> <!-- intro_src -->

<block name='book'>
<field name='title'>
<![CDATA[
Algorithm Design: Parallel and Sequential (Fall 2019)
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Algorithm Design: Parallel and Sequential (Fall 2019)
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='authors'>
Umut A. Acar and Guy Blelloch
</field> <!-- authors -->
<block name='chapter'>
<field name='title'>
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Example Chapter: Binary Search Trees
]]>
</field> <!-- title_src -->
<field name='label'>
ch:bsts
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='picture'>
/210/bsts/abstract-tree.jpg
</field> <!-- picture -->
<field name='intro'>
<![CDATA[
<p>...NOT.PROVIDED.INTRO...</p>
]]>
</field> <!-- intro -->
<field name='intro_src'>
<![CDATA[
...NOT.PROVIDED.INTRO...
]]>
</field> <!-- intro_src -->
<block name='section'>
<field name='title'>
<![CDATA[
Motivation
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Motivation
]]>
</field> <!-- title_src -->
<field name='label'>
sec:bst::motivation
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='intro'>
<![CDATA[
<p>Searching is one of the most important operations in computer science. Of the many search data structures that have been designed and are used in practice, search trees, more specifically balanced binary search trees, occupy a coveted place because of their broad applicability to many different sorts of problems. For example, in this book, we rely on binary search trees to implement set and table (dictionary) abstract data types (Chapter <a href="#ch:sets-tables" data-reference-type="ref" data-reference="ch:sets-tables">[ch:sets-tables]</a>), which are then used in the implementation of many algorithms, including for example graph algorithms.</p>
]]>
</field> <!-- intro -->
<field name='intro_src'>
<![CDATA[
Searching is one of the most important operations in computer science.
Of the many search data structures that have been designed and are
used in practice, search trees, more specifically balanced binary
search trees, occupy a coveted place because of their broad
applicability to many different sorts of problems.  For example, in
this book, we rely on binary search trees to implement set and table
(dictionary) abstract data types
(\chref{sets-tables}),
which are then used in the
implementation of many algorithms, including for example graph
algorithms.
]]>
</field> <!-- intro_src -->
<block name='subsection'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>If we are interested in searching a static or unchanging collection of elements, then we can use a simpler data structure such as sequences. For example, we can use a sequence with the array-based cost specification to implement an efficient search function by representing the collection as a sorted sequence and by using binary search. Such an implementation would yield a logarithmic-work search operation. If, however, we want to support dynamic collections, where for example, we insert new elements and delete existing elements, sequences would require linear work. Binary search trees, or  <span style="color: black"><span><strong><em>BSTs</em></strong></span></span> for short, make it possible to compute with dynamic collections by using insertions, deletions, as well as searches all in logarithmic number of tree operations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If we are interested in searching a static or unchanging collection of
elements, then we can use a simpler data structure such as sequences.
%
For example, we can use a sequence with the array-based cost
specification to implement an efficient search function by
representing the collection as a sorted sequence and by using binary
search.  
%
Such an implementation would yield a logarithmic-work search
operation.
%
If, however, we want to support dynamic collections, where for
example, we insert new elements and delete existing elements,
sequences would require linear work.
% 
Binary search trees, or~\defn{BSTs} for short, make it possible to
compute with dynamic collections by using insertions, deletions, as
well as searches all in logarithmic number of tree operations.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>In the traditional treatment of algorithms, which focuses on sequential algorithms, binary search trees revolve around three operations: insertion, deletion, and search. While these operations are important, they are not sufficient for parallelism, since they perform a single update at a time. We therefore consider aggregate update operations, such as union and difference, which can be used to insert and delete (respectively) many elements atonce.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In the traditional treatment of algorithms, which focuses on
sequential algorithms, binary search trees revolve around three
operations: insertion, deletion, and search.
%
While these operations are important, they are not sufficient for
parallelism, since they perform a single update at a time.
% 
We therefore consider aggregate update operations, such as union and
difference, which can be used to insert and delete (respectively) many
elements atonce.
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
...NOT.PROVIDED.LABEL...
</field> <!-- label -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>In this section (Section <a href="#sec:bst::motivation" data-reference-type="ref" data-reference="sec:bst::motivation">[sec:bst::motivation]</a>), we covered motivation. The rest of this chapter is organized as follows. We first define binary search trees (Section <a href="#sec:bst::prelim" data-reference-type="ref" data-reference="sec:bst::prelim">[sec:bst::prelim]</a>) and present an ADT for them. (Section <a href="#sec:bst::adt" data-reference-type="ref" data-reference="sec:bst::adt">[sec:bst::adt]</a>). We then present a parametric implementation of the ADT (Section <a href="#sec:bst::parametric" data-reference-type="ref" data-reference="sec:bst::parametric">[sec:bst::parametric]</a>) by using only two operations, <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>, which respectively split a tree at a given key and join two trees. In Section <a href="#sec:bst::cost" data-reference-type="ref" data-reference="sec:bst::cost">[sec:bst::cost]</a>, we present a cost specification based on the parametric implementation, which achieves strong bounds as long as the <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations have logarithmic work and span. As a result, we are able to reduce the problem of implementing the BST ADT to the problem of implementing just the functions <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>. We finish the chapter by presenting a specific instance of the parametric implementation using Treaps (Section <a href="#sec:bst::treaps" data-reference-type="ref" data-reference="sec:bst::treaps">[sec:bst::treaps]</a>). Other possible implementation techniques are also described (Section <a href="#sec:bst::bsts-review" data-reference-type="ref" data-reference="sec:bst::bsts-review">[sec:bst::bsts-review]</a>)</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In this section (\secref{bst::motivation}), we covered motivation.
The rest of this chapter is organized as follows.  We first define
binary search trees (\secref{bst::prelim}) and present an ADT for
them.  (\secref{bst::adt}).
%
We then present a parametric implementation of the ADT
(\secref{bst::parametric})
by using only two operations, $\cd{split}$
and $\cd{join}$, which respectively split a tree at a given key and
join two trees.
%
In \secref{bst::cost},
we present a cost specification based on the
parametric implementation, which achieves strong bounds as long as the
$\cd{split}$ and $\cd{join}$ operations have logarithmic work and
span.
%
As a result, we are able to reduce the problem of implementing the BST
ADT to the problem of implementing just the functions $\cd{split}$
and $\cd{join}$.  
%
We finish the chapter by presenting a specific instance of the
parametric implementation using Treaps (\secref{bst::treaps}).
%
Other possible implementation techniques are also described
(\secref{bst::bsts-review})
]]>
</field> <!-- body_src -->
</atom> <!-- gram -->

</block> <!-- subsection -->
</block> <!-- section -->
</block> <!-- chapter -->
</block> <!-- book -->
</block> <!-- course -->
