<?xml version = "1.0"?>
<block name='course'>
<field name='title'>
<![CDATA[
Parallel and Sequential Algorithms
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Parallel and Sequential Algorithms
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210
</field> <!-- unique -->
<field name='label'>
15210
</field> <!-- label -->
<field name='no'>
15210
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='coursenumber'>
15210
</field> <!-- coursenumber -->
<field name='picture'>
/210/course/air-pavilion.jpg
</field> <!-- picture -->
<field name='semester'>
Spring 2018
</field> <!-- semester -->
<field name='website'>
http://www.cs.cmu.edu/~15210
</field> <!-- website -->
<field name='providesbook'>
S18
</field> <!-- providesbook -->
<field name='provideschapter'>
1
</field> <!-- provideschapter -->
<field name='providessection'>
1
</field> <!-- providessection -->
<field name='providesunit'>
1
</field> <!-- providesunit -->
<field name='providesassignment'>
1
</field> <!-- providesassignment -->
<field name='intro'>
<![CDATA[
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>
]]>
</field> <!-- intro -->
<field name='intro_raw'>
<![CDATA[
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
]]>
</field> <!-- intro_raw -->

<block name='book'>
<field name='title'>
<![CDATA[
Algorithm Design: Parallel and Sequential
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Algorithm Design: Parallel and Sequential
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18
</field> <!-- unique -->
<field name='label'>
book:15210:S18
</field> <!-- label -->
<field name='no'>
0
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='authors'>
Umut A. Acar and Guy Blelloch
</field> <!-- authors -->

<block name='chapter'>
<field name='title'>
<![CDATA[
Introduction
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Introduction
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1
</field> <!-- unique -->
<field name='label'>
chapter:15210:S18:CH1:ch:intro
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='picture'>
./media/la-tour-aux-rideaux.jpg
</field> <!-- picture -->
<field name='intro'>
<![CDATA[
<p>This chapter presents a brief overview of the methodology followed in this book.</p>
]]>
</field> <!-- intro -->
<field name='intro_raw'>
<![CDATA[
This chapter presents a brief overview of the methodology followed in
this book.
]]>
</field> <!-- intro_raw -->

<block name='section'>
<field name='title'>
<![CDATA[
Introduction
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Introduction
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1
</field> <!-- unique -->
<field name='label'>
section:15210:S18:CH1:SEC1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='intro'>
<![CDATA[
<p>This section presents an overview of the approach taken in this book.</p>
]]>
</field> <!-- intro -->
<field name='intro_raw'>
<![CDATA[
This section presents an overview of the approach taken in this book.
]]>
</field> <!-- intro_raw -->

<block name='unit'>
<field name='title'>
<![CDATA[
Introduction
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Introduction
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN1
</field> <!-- unique -->
<field name='label'>
unit:15210:S18:CH1:SEC1:UN1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN1:GR1
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN1:GR1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachnote'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN1:GR1:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN1:GR1:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>TODO:Updates needed to deemphasize parallelism.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
TODO:Updates needed to deemphasize parallelism.
% Guy: I intentionally try not to emphasize parallelism in the opening
% two paragraphs because most of the ideas transend parallel vs sequential.
% The whole next section is on parallelism.
]]>
</field> <!-- body_raw -->
</atom> <!-- teachnote -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN1:GR2
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN1:GR2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN1:GR2:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN1:GR2:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>This book aims to present techniques for problem solving using today’s parallel computers. For example, you might want to find the stortest path from where you are now to the nearest café by using your computer. Your primary concern is probably that your answer is correct (e.g. you might be unhappy to find yourself in a pharmacy instead of a nice café). However, you also care that you get the answer reasonably quickly (e.g., it would not be useful if your computer took hours instead of seconds or perhaps minutes). This book covers different aspects of problem solving with computers such as</p>
<ul>
<li><p>defining precisely the problem you want to solve,</p></li>
<li><p>learning the different techniques that can be used to solve a problem and about designing algorithms using these techniques,</p></li>
<li><p>designing abstract data types that can be used in algorithms and data structures that implement these types, and</p></li>
<li><p>analyzing the cost of algorithms and comparing them based on their cost.</p></li>
</ul>
<p>We are concerned both with parallel algorithms (algorithms that are correct and efficient on modern parallel computers) and sequential algorithms (ones that are correct and efficient on sequential computers). However, in our approach, sequential and parallel algorithms are not that different.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
This book aims to present techniques for problem solving using 
today's parallel computers.
%
For example, you might want to find the stortest path from where you
are now to the nearest caf\'e by using your computer.
%
Your primary concern is probably that your answer is correct (e.g. you
might be unhappy to find yourself in a pharmacy instead of a
nice caf\'e). 
%
However, you also care that you get the answer reasonably quickly
(e.g., it would not be useful if your computer took hours instead of
seconds or perhaps minutes).
%

This book covers different aspects of problem solving with computers
such as 
\begin{itemize}
\item defining precisely the problem you want to solve,
\item learning the different techniques that can be used to solve
  a problem and about designing algorithms using these techniques,
\item designing abstract data types that can be used in
  algorithms and data structures that implement these types, and
%
\item analyzing the cost of  algorithms and comparing them based
  on their cost.
%
\end{itemize}

We are concerned both with 
%
parallel algorithms (algorithms that are correct and efficient on
modern parallel computers)
%
and 
%
sequential algorithms (ones that are correct and efficient on
sequential computers).
%
However, in our approach, sequential and parallel algorithms are not
that different.  
%
%In the rest of this chapter we discuss why it is important to study
%parallelism, why it is important to separate interfaces from
%implementations, and outline some algorithm-design techniques.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

</block> <!-- unit -->

<block name='unit'>
<field name='title'>
<![CDATA[
Parallelism
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Parallelism
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2
</field> <!-- unique -->
<field name='label'>
unit:15210:S18:CH1:SEC1:UN2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR1
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR1:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR1:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The term “parallelism” or “parallel computing” refers to the ability to run multiple computations (tasks) at the same time.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The term ``parallelism'' or ``parallel computing'' refers to the
ability to run multiple computations (tasks) at the same time.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR2
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachask'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR2:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR2:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Why should we care about parallelism? Do we even have parallel computers today?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Why should we care about parallelism?  
%
Do we even have parallel computers today?
]]>
</field> <!-- body_raw -->
</atom> <!-- teachask -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR3
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR3
</field> <!-- label -->
<field name='no'>
3
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Parallel Hardware
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Parallel Hardware
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR3:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR3:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Today parallelism is available in all computer systems, and at many different scales starting with parallelism in the nano-circuits that implement individual instructions, and working the way up to parallel systems that occupy large data centers. Since the early 2000s hardware manufacturers have been placing multiple processing units, often called “cores”, onto a single chip. These cores can be general purpose processors, or more special purpose processors, such as those found in <span> </span> (GPUs). Each core can run in parallel with the others.</p>
<p>At the larger scale many such parallel chips or computers can be connected by a network and used together to solve large problems. For example, when you perform a simple search on the Internet, you engage a data center with thousands of computers in some part of the world, likely near your geographic location. Many of these computers (perhaps as many as hundreds, if not thousands) take up your query and sift through data to give you an accurate response as quickly as possible.</p>
<p>There are several reasons for why such parallel systems and thus parallelism has become so prevalent.</p>
<p>First, parallelism is simply faster than sequential computing (where only one computation can be run at a time). For example, an Internet search is not quite effective if it cannot be completed at “interactive speeds”, e.g., completing under a second. Similarly, a weather-forecast simulation is essentially useless if it cannot be completed in time.</p>
<p>The second reason is efficiency in terms of energy usage. As it turns out, performing a computation twice as fast sequentially requires eight times as much energy. Precisely speaking, energy consumption is a cubic function of clock frequency (speed). With parallelism we don’t need more energy to speed up a computation. For example, to perform a computation in half the time, we need to divide the computation into two parallel sub-computations, perform them in parallel and combine their results. This can require as little as half the time as the sequential computation while consuming the same amount of energy. In reality, there are some overheads and we will need more energy, for example, to divide the computation and combine the results. Such overheads are usually small, e.g., constant fraction over sequential computation, but can be larger.</p>
<p>These two factors—time and energy—have become increasingly important in the last decade, catapulting parallelism to the forefront of computing.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Today parallelism is available in all computer systems, and at many
different scales starting with parallelism in the nano-circuits that
implement individual instructions, and working the way up to parallel
systems that occupy large data centers.  Since the early 2000s
hardware manufacturers have been placing multiple processing units,
often called ``cores'', onto a single chip.  These cores can be
general purpose processors, or more special purpose processors, such as
those found in~\defn{Graphics Processing Units} (GPUs).  Each core can
run in parallel with the others.  

At the larger scale many such parallel chips or computers can be
connected by a network and used together to solve large problems.  For
example, when you perform a simple search on the Internet, you engage
a data center with thousands of computers in some part of the world,
likely near your geographic location.
%
Many of these computers (perhaps as many as hundreds, if not
thousands) take up your query and sift through data to give you an
accurate response as quickly as possible.


%% \begin{teachask}
%% Do you know how many computers are engaged in answering a typical web
%% search? 
%% \end{teachask}
%% %

%% \begin{teachask}
%% What is the advantage of using a parallel algorithm instead of a
%% sequential one?
%% \end{teachask}


%% \begin{teachask}
%% Do you know how much energy it takes to run a computation twice as
%% fast using a sequential computer (one line of computation)? 
%% \end{teachask}

There are several reasons for why such parallel systems and thus
parallelism has become so prevalent.
%


First, parallelism is simply faster than sequential computing (where
only one computation can be run at a time).
%
For example, an Internet search is not quite effective if it cannot be
completed at ``interactive speeds'', e.g., completing under a second.
%
Similarly, a weather-forecast simulation is essentially useless if it
cannot be completed in time.

The second reason is efficiency in terms of energy usage.
%
As it turns out, performing a computation twice as fast sequentially
requires eight times as much energy.  
%
Precisely speaking, energy
consumption is a cubic function of clock frequency (speed).  With
parallelism we don't need more energy to speed up a computation. 
%
For example, to perform a computation in half the time, we need to
divide the computation into two parallel sub-computations, perform
them in parallel and combine their results.  This can require as
little as half the time as the sequential computation while consuming
the same amount of energy.
%
In reality, there are some overheads and we will need more energy, for
example, to divide the computation and combine the results.
Such overheads are usually small, e.g., constant fraction over
sequential computation, but can be larger. 

These two factors---time and energy---have become increasingly
important in the last decade, catapulting parallelism to the forefront
of computing.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR4
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR4
</field> <!-- label -->
<field name='no'>
4
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachask'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR4:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR4:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Can you think of consequences of these developments in hardware?</p>
<p>Answer: These developments in hardware make the specification, the design, and the implementation of parallel algorithms an important topic.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Can you think of consequences of these developments in hardware?  

Answer:
These developments in hardware make the specification, the design, and
the implementation of parallel algorithms an important topic.
]]>
</field> <!-- body_raw -->
</atom> <!-- teachask -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR5
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR5
</field> <!-- label -->
<field name='no'>
5
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR5:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR5:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>As is historically popular in explaining algorithms, we can establish an analogy between parallel algorithms and cooking. As in a kitchen with multiple cooks, in parallel algorithms you can do things in parallel for faster turnaround time. For example, if you want to prepare 3 dishes with a team of cooks you can do so by asking each cook to prepare one. Doing so will often be faster that using one cook. But there are some overheads, for example, the work has to be divided as evenly as possible. Obviously, you also need more resources, e.g., each cook might need their own kitchen utensils.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
As is historically popular in explaining algorithms, we can establish
an analogy between parallel algorithms and cooking.  As in a kitchen
with multiple cooks, in parallel algorithms you can do things in
parallel for faster turnaround time.  For example, if you want to
prepare 3 dishes with a team of cooks you can do so by asking each
cook to prepare one.
%
Doing so will often be faster that using one cook.  But there are some
overheads, for example, the work has to be divided as evenly as
possible.  Obviously, you also need more resources, e.g., each cook
might need their own kitchen utensils.
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR6
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR6
</field> <!-- label -->
<field name='no'>
6
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR6:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR6:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>One way to quantify the advantages or parallelism is to compare its performance to sequential computation. The example below illustrates the sort of performance improvements that can achieved today. These times are on a 32 core commodity server machine. In the table, the sequential timings use sequential algorithms while the parallel timings use parallel algorithms. Notice that the <span> </span> for the parallel 32 core version relative to the sequential algorithm ranges from approximately 12 (minimum spanning tree) to approximately 32 (sorting).</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
One way to quantify the advantages or parallelism is to compare
its performance to sequential computation.
%
The example below illustrates the sort of performance improvements
that can achieved today.  
%
%
These times are on a 32 core commodity
server machine.  In the table, the sequential timings use sequential
algorithms while the parallel timings use parallel algorithms.  Notice
that the~\defn{speedup} for the parallel 32 core version relative to
the sequential algorithm ranges from approximately 12 (minimum
spanning tree) to approximately 32 (sorting).
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR7
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR7
</field> <!-- label -->
<field name='no'>
7
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR7:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR7:AT1:ex:intro::example-runs
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Sample timings (reported in seconds) for some algorithms.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><strong>Application</strong></td>
<td align="center"><strong>Sequential</strong></td>
<td align="center"><strong>Parallel</strong></td>
<td align="center"><strong>Parallel</strong></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center"></td>
<td align="center"><strong>P = 1</strong></td>
<td align="center"><strong>P = 32</strong></td>
</tr>
<tr class="odd">
<td align="left">Sort <span class="math inline">\(10^7\)</span> strings</td>
<td align="center">2.9</td>
<td align="center">2.9</td>
<td align="center">.095</td>
</tr>
<tr class="even">
<td align="left">Remove duplicates for <span class="math inline">\(10^7\)</span> strings</td>
<td align="center">.66</td>
<td align="center">1.0</td>
<td align="center">.038</td>
</tr>
<tr class="odd">
<td align="left">Minimum spanning tree for <span class="math inline">\(10^7\)</span> edges</td>
<td align="center">1.6</td>
<td align="center">2.5</td>
<td align="center">.14</td>
</tr>
<tr class="even">
<td align="left">Breadth first search for <span class="math inline">\(10^7\)</span> edges</td>
<td align="center">.82</td>
<td align="center">1.2</td>
<td align="center">.046</td>
</tr>
</tbody>
</table>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Sample timings (reported in seconds) for some algorithms.
  \begin{center}
  \begin{tabular}{l  c c c}
    \toprule
    \textbf{Application} & \textbf{Sequential} & \textbf{Parallel} &
    \textbf{Parallel}
\\
     & & \textbf{P = 1} & \textbf{P = 32}
\\
    \midrule
    Sort $10^7$ strings &        2.9 &  2.9 &  .095\\
    Remove duplicates for $10^7$ strings &      .66 &  1.0 & .038\\
    Minimum spanning tree for $10^7$ edges    &    1.6 & 2.5  & .14\\
    Breadth first search for $10^7$ edges  &   .82  & 1.2 &  .046\\
    \bottomrule
  \end{tabular}
  \end{center}
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR8
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR8
</field> <!-- label -->
<field name='no'>
8
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachask'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR8:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR8:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>But why after all, do we have to do anything differently to take advantage of parallelism?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
But why after all, do we have to do anything differently to take
advantage of parallelism?
]]>
</field> <!-- body_raw -->
</atom> <!-- teachask -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR9
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR9
</field> <!-- label -->
<field name='no'>
9
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Challenges of Parallel Software
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Challenges of Parallel Software
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR9:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR9:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>It would be convenient to use sequential algorithms on parallel computers, but this does not work well because parallel computing requires a different way of organizing the computation. The fundamental difference between sequential and parallel computation is that in the latter certain computations will be performed at the same time but this is possible only if the computations are actually <span> </span>, i.e., do not depend on each other. Thus when designing a parallel algorithm, we have to identify the underlying dependencies in the computation and avoid creating unnecessary dependencies.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
It would be convenient to use sequential algorithms on parallel
computers, but this does not work well because parallel computing
requires a different way of organizing the computation.
%
The fundamental difference between sequential and parallel computation
is that in the latter certain computations will be performed at the
same time but this is possible only if the computations are actually~\defn{independent}, i.e., do not depend on each other.
%
Thus when designing a parallel algorithm, we have to identify the
underlying dependencies in the computation and avoid creating
unnecessary dependencies.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR10
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR10
</field> <!-- label -->
<field name='no'>
10
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR10:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR10:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Going back to our cooking example, suppose that we want to make a frittata in our kitchen with 4 cooks. Making a frittata is not easy. It involves cleaning and chopping vegetables, beating eggs, sauteeing, as well as baking. For the frittata to be good, the cooks must follow a specific receipe and pay attention to the dependencies between various tasks. For example, vegetables cannot be sauteed before they are washed and chopped the eggs cannot be fisked before they are broken, etc.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Going back to our cooking example, suppose that we want to make a
frittata in our kitchen with 4 cooks.
%
Making a frittata is not easy.
%
It involves cleaning and chopping vegetables, beating eggs,
sauteeing, as well as baking.
%
For the frittata to be good, the cooks must follow a specific receipe
and pay attention to the dependencies between various tasks.
%
For example,
%
vegetables cannot be sauteed before they are washed and chopped
%
the eggs cannot be fisked before they are broken, etc.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR11
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN2:GR11
</field> <!-- label -->
<field name='no'>
11
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN2:GR11:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN2:GR11:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>An important challenge is therefore to design algorithms that minimize the dependencies so that more can be run in parallel. This design challenge is a primary focus of this book.</p>
<p>Another important challenge concerns the coding and usage of a parallel algorithm in the real world. The many forms of parallelism, ranging from small to large scale, and from general to special purpose, have led to many different programming languages and system for coding parallel algorithms. These different programming languages and systems often target a particular kind of hardware, and even a particular kind of problem domain. For example, there are separate systems for coding parallel numerical algorithms on shared memory hardware, for coding graphics algorithms on Graphical Processing Units (GPUs), and for coding data-analytics software on a distributed system. Each such system tends to have its own programming interface, its own cost model, and its own optimizations, making it practically impossible to take a parallel algorithm and code it once and for all for all possible applications. As it turns out, one can easily spend weeks or even months optimizing a parallel sorting algorithm on specific parallel hardware, such as a GPU.</p>
<p>Maximizing speedup by coding and optimizing an algorithm is not the goal of this book. Instead, our goal is to cover general design principles for parallel algorithms that can be applied in essentially all parallel systems, from the data center to the multicore chips on mobile phones. We will learn to think about parallelism at a high-level, learning general techniques for designing parallel algorithms and data structures, and learning how to approximately analyze their costs. The focus is on understanding when things can run in parallel, and when not due to dependencies. There is much more to learn about parallelism, and we hope you continue studying this subject.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
An important challenge is therefore to design algorithms that minimize
the dependencies so that more can be run in parallel.
%
This design challenge is a primary focus of this book. 

Another important challenge concerns the coding and usage of a
parallel algorithm in the real world.
%
The many forms of parallelism, ranging from small to large scale, and
from general to special purpose, have led to many different programming
languages and system for coding parallel algorithms.
%
These different programming languages and systems often target a
particular kind of hardware, and even a particular kind of problem
domain.  
%
For example, there are separate systems for coding parallel numerical
algorithms on shared memory hardware, for coding graphics algorithms
on Graphical Processing Units (GPUs), and for coding data-analytics
software on a distributed system.
%
Each such system tends to have its own programming interface, its own
cost model, and its own optimizations, making it practically
impossible to take a parallel algorithm and code it once and for all
for all possible applications.
%
As it turns out, one can easily spend weeks or even months optimizing a
parallel sorting algorithm on specific parallel hardware, such as a GPU.
%% For example, it is unlikely that unoptimized code can obtain the
%% speedups discussed in \exref{intro::example-runs}.
%% %


%% The diversity of parallel hardware and software makes it difficult to
%% learn both the high-level ideas of developing parallel algorithms and
%% the optimization techniques required to achieve efficiency on a variety
%% of different machines.
%% %
%% For example, would a particular parallel sorting algorithm be
%% theoretically efficient on a large-scale system? How about on a small
%% scale system?  What would be needed to implement an optimized parallel
%% sorting algorithm for a GPU?

Maximizing speedup by coding and optimizing an algorithm is not the
goal of this book.
%
Instead, our goal is to cover general design principles for parallel
algorithms that can be applied in essentially all parallel systems,
from the data center to the multicore chips on mobile phones.
%
We will learn to think about parallelism at a high-level, learning
general techniques for designing parallel algorithms and data
structures, and learning how to approximately analyze their costs.
%
The focus is on understanding when things can run in parallel, and
when not due to dependencies.  
%
There is much more to learn about parallelism, and we hope you
continue studying this subject.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

</block> <!-- unit -->

<block name='unit'>
<field name='title'>
<![CDATA[
Work and Span
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Work and Span
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3
</field> <!-- unique -->
<field name='label'>
unit:15210:S18:CH1:SEC1:UN3
</field> <!-- label -->
<field name='no'>
3
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR1
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR1:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR1:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>This section describes the two measures—work and span—that we use to analyze algorithms. Together these measures capture both the sequential time and the parallelism available in an algorithm. We typically analyze both of these asymptotically, using for example the big-O notation.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
This section describes the two measures---work and span---that we use
to analyze algorithms.  Together these measures capture both the
sequential time and the parallelism available in an algorithm.
%
We typically analyze both of these asymptotically, using
for example the big-O notation.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR2
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Work
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Work
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR2:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR2:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The <span> </span> of an algorithm corresponds to the total number of primitive operations performed by an algorithm. If running on a sequential machine, it corresponds to the sequential time. On a parallel machine, however, work can be divided among multiple processors and thus does not necessarily correspond to time. The interesting question is to what extent can the work be divided and performed in parallel. Ideally we would like to divide the work evenly. If we had <span class="math inline">\(W\)</span> work and <span class="math inline">\(P\)</span> processors to work on it in parallel, then even division would give each processor <span class="math inline">\(\frac{W}{P}\)</span> fraction of the work, and hence the total time would be <span class="math inline">\(\frac{W}{P}\)</span>. An algorithm that achieves such ideal division is said to have <span> </span>. Perfect speedup, however, is not always possible.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The~\defn{work} of an algorithm corresponds to the total number of
primitive operations performed by an algorithm.  If running on a
sequential machine, it corresponds to the sequential time.
%
On a parallel machine, however, work can be divided among multiple
processors and thus does not necessarily correspond to time.
%

The interesting question is to what extent can the work be divided and
performed in parallel.  Ideally we would like to divide the work
evenly.  If we had $W$ work and $P$ processors to work on it in
parallel, then even division would give each processor $\frac{W}{P}$
fraction of the work, and hence the total time would be $\frac{W}{P}$.
%
An algorithm that achieves such ideal division is said to
have~\defn{perfect speedup}.  Perfect speedup, however, is not always
possible.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR2:AT2
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR2:AT2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>A fully sequential algorithm, where each operation depends on prior operations leaves no room for parallelism. We can only take advantage of one processor and the time would not be improved at all by adding more. More generally, when executing an algorithm in parallel, we cannot break dependencies, if a task depends on another task, we have to complete them in order.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
A fully sequential algorithm, where each operation depends on prior
operations leaves no room for parallelism.
%
We can only take advantage of one processor and the time would not be
improved at all by adding more.  
%

More generally, when executing an algorithm in parallel, we cannot
break dependencies, if a task depends on another task, we have to
complete them in order.
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR3
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR3
</field> <!-- label -->
<field name='no'>
3
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachask'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR3:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR3:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Can you come up with an example where perfect speedup is not possible?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Can you come up with an example where perfect speedup is not possible?
]]>
</field> <!-- body_raw -->
</atom> <!-- teachask -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR4
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR4
</field> <!-- label -->
<field name='no'>
4
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachnote'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR4:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR4:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>For example, when cooking a frittata, you cannot cook the egg that is not broken, nor can we add the eggs to the pan until the vegetables are sauteed.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
For example, when cooking a frittata, you cannot cook the egg that is
not broken, nor can we add the eggs to the pan until the vegetables
are sauteed.
]]>
</field> <!-- body_raw -->
</atom> <!-- teachnote -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR5
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR5
</field> <!-- label -->
<field name='no'>
5
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Span
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Span
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR5:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR5:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The second measure, <span> </span>, enables analyzing to what extent the work of an algorithm can be divided among processors. The <span> </span> of an algorithm basically corresponds to the longest sequence of dependences in the computation. It can be thought of as the time an algorithm would take if we had an unlimited number of processors on an ideal machine.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The second measure,~\defn{span}, enables analyzing to what extent the
work of an algorithm can be divided among processors.  The~\defn{span}
of an algorithm basically corresponds to the longest sequence of
dependences in the computation.  It can be thought of as the time an
algorithm would take if we had an unlimited number of processors on an
ideal machine.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR6
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR6
</field> <!-- label -->
<field name='no'>
6
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR6:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR6:AT1:ex:intro::mergesortcost
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>As an example, consider the parallel <span class="math inline">\({\texttt{mergeSort}}\)</span> algorithm for sorting a sequence of length <span class="math inline">\(n\)</span>. The work is the same as the sequential time, which you might know is <span class="math display">\[W(n) = O(n \lg{n}).\]</span> We will see that the span for <span class="math inline">\({\texttt{mergeSort}}\)</span> is <span class="math display">\[S(n) = O(\lg^2{n}).\]</span></p>
<p>Thus, when sorting a million keys and ignoring constant factors, work is <span class="math inline">\(10^6\lg (10^6) &gt; 10^7\)</span>, and span is <span class="math inline">\(\lg^2(10^6) &lt; 500.\)</span></p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
As an example, consider the parallel $\cd{mergeSort}$ algorithm for
sorting a sequence of length $n$.  The work is the same as the
sequential time, which you might know is
\[
W(n) = O(n \lg{n}).
\] 
%
%In Chapter~\ref{ch:divide-and-conquer} 
We will see that the span for
$\cd{mergeSort}$ is
\[
S(n) = O(\lg^2{n}).
\]

Thus, when  sorting a million keys and ignoring constant factors, 
work is $10^6\lg (10^6) > 10^7$, and 
%
span is 
$\lg^2(10^6) < 500.$
%
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR7
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR7
</field> <!-- label -->
<field name='no'>
7
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Parallel Time
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Parallel Time
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR7:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR7:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Even though work and span, are abstract measures of real costs, they can be used to predict the run-time on any number of processors. Specifically, if for an algorithm the work dominates, i.e., is much larger than, span, then we expect the algorithm to deliver good speedups.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Even though work and span, are abstract measures of real costs, they
can be used to predict the run-time on any number of processors.
%
Specifically, if for an algorithm the work dominates, i.e., is much
larger than, span, then we expect the algorithm to deliver good
speedups.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR8
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR8
</field> <!-- label -->
<field name='no'>
8
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='exercise'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR8:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR8:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>How would you expect the parallel mergesort algorithm, <span class="math inline">\({\texttt{mergeSort}}\)</span>, mentioned in the example above to perform as we increase the number of processors dedicated to running it?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
How would you expect the parallel mergesort algorithm, $\cd{mergeSort}$,
mentioned in the example above to perform as we increase the number of
processors dedicated to running it?
]]>
</field> <!-- body_raw -->
</atom> <!-- exercise -->

<atom name='solution'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR8:AT2
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR8:AT2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Recall that the work of parallel merge sort is <span class="math inline">\(O(n\lg{n})\)</span>, whereas the span is <span class="math inline">\(O(\lg^2{n})\)</span>. Since span is much smaller than the work, we would expect to get good (close to perfect) speedups when using a small to moderate number of processors, e.g., couple of tens or hundreds, because the work term will dominate. We would expect for example the running time to halve when we double the number of processors. We should note that in practice, speedups tend to be more conservative due to natural overheads of parallel execution and due to other factors such as the memory subsystem that can limit parallelism.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Recall that the work of parallel merge sort is $O(n\lg{n})$, whereas
the span is $O(\lg^2{n})$.  
%
Since span is much smaller than the work, we would expect to get good
(close to perfect) speedups when using a small to moderate number of
processors, e.g., couple of tens or hundreds, because the work term
will dominate.
%
We would expect for example the running time to halve when we double
the number of processors.
%
We should note that in practice, speedups tend to be more conservative
due to natural overheads of parallel execution and due to other
factors such as the memory subsystem that can limit parallelism.
]]>
</field> <!-- body_raw -->
</atom> <!-- solution -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR9
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR9
</field> <!-- label -->
<field name='no'>
9
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachask'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR9:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR9:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>How do we calculate the work and span of an algorithm?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
How do we calculate the work and span of an algorithm?
]]>
</field> <!-- body_raw -->
</atom> <!-- teachask -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR10
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR10
</field> <!-- label -->
<field name='no'>
10
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='definition'>
<field name='title'>
<![CDATA[
Work and Span
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Work and Span
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR10:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR10:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We calculate the work and span of algorithms in a very simple way that just involves composing costs across subcomputations. Basically we assume that sub-computations are either composed sequentially (one must be performed after the other) or in parallel (they can be performed at the same time). We then calculate the work as the sum of the work of the subcomputations and the span as the sum of the span of sequential subcomputations or maximum of the work of the parallel subcomputations. More concretely, given two subcomputations with work <span class="math inline">\(W_1\)</span> and <span class="math inline">\(W_2\)</span> and span <span class="math inline">\(S_1\)</span> and <span class="math inline">\(S_2\)</span>, we can calculate the work and the span of their sequential and parallel composition as follows. In calculating the overall work and span, the unit cost <span class="math inline">\(1\)</span> accounts for the cost of (parallel or sequential) composition.</p>
<table>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="center"><strong><span class="math inline">\(W\)</span> (Work) &amp; <strong><span class="math inline">\(S\)</span> (span)<br />
<strong>Sequential composition &amp; <span class="math inline">\(1 + W_1 + W_2\)</span> &amp; <span class="math inline">\(1 + S_1+ S_2\)</span><br />
<strong>Parallel composition &amp; <span class="math inline">\(1 + W_1 + W_2\)</span> &amp; <span class="math inline">\(1 + \max(S_1, S_2)\)</span><br />
</strong></strong></strong></strong></td>
<td align="center"></td>
</tr>
</tbody>
</table>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We calculate the work and span of algorithms in a very
simple way that just involves composing costs across subcomputations.
%
Basically we assume that sub-computations are either composed
sequentially (one must be performed after the other) or in parallel
(they can be performed at the same time).
%
We then calculate the work as the sum of the work of the
subcomputations and the span as the sum of the span of sequential
subcomputations or maximum of the work of the parallel
subcomputations.
%
More concretely, given two subcomputations with work $W_1$ and $W_2$
and span $S_1$ and $S_2$, we can calculate the work and the span of
their sequential and parallel composition as follows.
%
In calculating the overall work and span, the unit cost $1$ accounts
for the cost of (parallel or sequential) composition.


\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{lcc}
\toprule
                          &  \bf $W$ (Work) & \bf $S$ (span)\\
\midrule
\bf Sequential composition & $1 + W_1 + W_2$ & $1 + S_1+ S_2$\\
\midrule
\bf Parallel composition   & $1 + W_1 + W_2$ & $1 + \max(S_1, S_2)$\\
\bottomrule
\end{tabular}
\end{center}
]]>
</field> <!-- body_raw -->
</atom> <!-- definition -->

<atom name='note'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR10:AT2
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR10:AT2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The intuition behind the definition of work and span is that work simply adds, whether we perform computations sequentially or in parallel. The span, however, only depends on the span of the maximum of the two parallel computations. It might help to think of work as the total energy consumed by a computation and span as the minimum possible time that the computation requires. Regardless of whether computations are performed serially or in parallel, energy is equally required; time, however, is determined only by the slowest computation.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The intuition behind the definition of work and span is that work
simply adds, whether we perform computations sequentially or in
parallel.  The span, however, only depends on the span of the maximum
of the two parallel computations.  It might help to think of work as
the total energy consumed by a computation and span as the minimum
possible time that the computation requires.  Regardless of whether
computations are performed serially or in parallel, energy is equally
required; time, however, is determined only by the slowest
computation.
]]>
</field> <!-- body_raw -->
</atom> <!-- note -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR10:AT3
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR10:AT3
</field> <!-- label -->
<field name='no'>
3
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Suppose that we have <span class="math inline">\(30\)</span> eggs to cook using <span class="math inline">\(3\)</span> cooks. Whether all <span class="math inline">\(3\)</span> cooks to do the cooking or just one, the total work remains unchanged: <span class="math inline">\(30\)</span> eggs need to be cooked. Assuming that cooking an egg takes <span class="math inline">\(5\)</span> minutes, the total work therefore is <span class="math inline">\(150\)</span> minutes. The span of this job corresponds to the longest sequence of dependences that we must follow. Since we can, in principle, cook all the eggs at the same time, span is 5 minutes. Given that we have <span class="math inline">\(3\)</span> cooks, how much time do we actually need? The greedy scheduling principle tells us that we need no more that <span class="math inline">\(150/3 + 5 = 55\)</span> minutes. That is almost a factor <span class="math inline">\(3\)</span> speedup over the <span class="math inline">\(150\)</span> that we would need with just one cook. How do we actually realize the greedy schedule? In this case, this is simple, all we have to do is divide the eggs equally between our cooks.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Suppose that we have $30$ eggs to cook using $3$ cooks.  Whether all
$3$ cooks to do the cooking or just one, the total work remains
unchanged: $30$ eggs need to be cooked.
%
Assuming that cooking an egg takes $5$ minutes, the total work
therefore is $150$ minutes.
%
The span of this job corresponds to the longest sequence of
dependences that we must follow.
%
Since we can, in principle, cook all the eggs at the same time, 
span is 5 minutes.
%

Given that we have $3$ cooks, how much time do we actually need?
%
The greedy scheduling principle tells us that we need no more that
$150/3 + 5 = 55$ minutes. That is almost a factor $3$ speedup over the
$150$ that we would need with just one cook. 
%

How do we actually realize the greedy schedule?  In this case, this is
simple, all we have to do is divide the eggs equally between our
cooks.
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR11
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR11
</field> <!-- label -->
<field name='no'>
11
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR11:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR11:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>If algorithm <span class="math inline">\(A\)</span> has less work than algorithm <span class="math inline">\(B\)</span>, but has greater span then which algorithm is better? In analyzing sequential algorithms there is only one measure so it is clear when one algorithm is asymptotically better than another, but now we have two measures. In general the work is more important than the span. This is because the work reflects the total cost of the computation (the processor-time product). Therefore typically the goal is to first reduce the work and then reduce the span by designing asymptotically work-efficient algorithms that perform no work than the best sequential algorithm for the same problem. However, sometimes it is worth giving up a little in work to gain a large improvement in span.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
If algorithm $A$ has less work than algorithm $B$, but has greater
span then which algorithm is better?  In analyzing sequential
algorithms there is only one measure so it is clear when one algorithm
is asymptotically better than another, but now we have two measures.
In general the work is more important than the span.  
%
This is because the work reflects the total cost of the computation
(the processor-time product).  Therefore typically the goal is to
first reduce the work and then reduce the span by designing
asymptotically work-efficient algorithms that perform no work
than the best sequential algorithm for the same problem. 
%
However, sometimes it is worth giving up a little in work to gain a
large improvement in span.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR12
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN3:GR12
</field> <!-- label -->
<field name='no'>
12
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='definition'>
<field name='title'>
<![CDATA[
Work Efficiency
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Work Efficiency
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR12:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR12:AT1:def:intro::work-efficiency
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We say that a parallel algorithm is <span> </span>, if the work is asymptotically the same as the time for an optimal sequential algorithm that solves the same problem.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We say that a parallel algorithm is~\defn{(asymptotically) work
  efficient}, if the work is asymptotically the same as the time for
an optimal sequential algorithm that solves the same problem.
]]>
</field> <!-- body_raw -->
</atom> <!-- definition -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN3:GR12:AT2
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN3:GR12:AT2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The parallel <span class="math inline">\({\texttt{mergeSort}}\)</span> function described in is work efficient since it does <span class="math inline">\(O(n \log n)\)</span> work, which optimal time for comparison based sorting. In this course we will try to develop work-efficient or close to work-efficient algorithms.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The parallel $\cd{mergeSort}$ function described in
\exref{mergesortcost} is work efficient since it does $O(n \log n)$
work, which optimal time for comparison based sorting.  In this course
we will try to develop work-efficient or close to work-efficient
algorithms.
]]>
</field> <!-- body_raw -->
</atom> <!-- example -->
</block> <!-- group -->

</block> <!-- unit -->

<block name='unit'>
<field name='title'>
<![CDATA[
Specification, Problem, Implementation
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Specification, Problem, Implementation
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4
</field> <!-- unique -->
<field name='label'>
unit:15210:S18:CH1:SEC1:UN4
</field> <!-- label -->
<field name='no'>
4
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR1
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR1:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR1:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Problem solving in computer science requires reasoning precisely about problems being studied and the properties of solutions. To facilitate such reasoning, we define problems by specifying them and describe the desired properties of solutions at different levels of abstraction, such as the cost and the implementation of the solution.</p>
<p>In this book, we are usually interested in two distinct classes of problems: algorithms problems and data structures problems.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Problem solving in computer science requires reasoning precisely about
problems being studied and the properties of solutions.
%
To facilitate such reasoning,  we define problems by
specifying them and describe the desired properties of solutions at
different levels of abstraction, such as the cost and the
implementation  of the solution.

In this book, we are usually interested in two distinct classes of
problems: algorithms problems and data structures problems.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR2
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR2
</field> <!-- label -->
<field name='no'>
2
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Algorithm Specification
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Algorithm Specification
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR2:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR2:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We specify an algorithm by describing what is expected of the algorithm via an <span> </span>. For example, we can specify a sorting algorithm for sequences with respect to a given comparison function as follows.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We specify an algorithm by describing what is expected of the
algorithm via an~\defn{algorithm specification}.
%
For example, we can specify a sorting algorithm for sequences with
respect to a given comparison function as follows.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR3
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR3
</field> <!-- label -->
<field name='no'>
3
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='definition'>
<field name='title'>
<![CDATA[
Comparison Sort
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Comparison Sort
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR3:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR3:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Given a sequence <span class="math inline">\(A\)</span> of <span class="math inline">\(n\)</span> elements taken from a totally ordered set with comparison operator <span class="math inline">\(\leq\)</span>, return a comparison-sorting algorithm sequence <span class="math inline">\(B\)</span> containing the same elements but such that <span class="math inline">\(B[i] \leq 
B[j]\)</span> for <span class="math inline">\(0 \leq i &lt; j &lt; n\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Given a sequence $A$ of $n$ elements taken from a totally ordered set
with comparison operator $\leq$, return a comparison-sorting algorithm
sequence $B$ containing the same elements but such that $B[i] \leq
B[j]$ for $0 \leq i < j < n$.
]]>
</field> <!-- body_raw -->
</atom> <!-- definition -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR4
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR4
</field> <!-- label -->
<field name='no'>
4
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='note'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR4:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR4:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The specification describes <span> </span> the algorithm should do but it does not describe <span> </span> it achieves what is asked. This is intentional—and is exactly the point—because there can be many algorithms that meet a specification.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The specification describes~\defn{what} the algorithm should do but it
does not describe~\defn{how} it achieves what is asked.
%
This is intentional---and is exactly the point---because there can be
many algorithms that meet a specification.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- note -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR5
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR5
</field> <!-- label -->
<field name='no'>
5
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR5:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR5:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>A crucial property of any algorithm is its resource requirements or its <span> </span>. For example, of the many ways algorithms for sorting a sequence, we may prefer some over the others. We specify the cost of class of algorithms with a <span> </span>. For example, the following cost specification states that a particular class of parallel sorting algorithms performs <span class="math inline">\(O(n \log{n})\)</span> work and <span class="math inline">\(O(\log^2{n})\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
A crucial property of any algorithm is its resource requirements or
its~\defn{cost}.
%
For example, of the many ways algorithms for sorting a sequence, we
may prefer some over the others.  
%
We specify the cost of class of algorithms with a~\defn{cost
  specification}.  For example, the following cost specification
states that a particular class of parallel sorting algorithms performs
$O(n \log{n})$ work and $O(\log^2{n})$ span.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR6
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR6
</field> <!-- label -->
<field name='no'>
6
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='costspec'>
<field name='title'>
<![CDATA[
Comparison Sort: Efficient &amp; Parallel
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Comparison Sort: Efficient \& Parallel
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR6:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR6:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n \log n)\)</span> work and <span class="math inline">\(O(\log^2 n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n \log n)$
work and $O(\log^2 n)$ span.
]]>
</field> <!-- body_raw -->
</atom> <!-- costspec -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR7
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR7
</field> <!-- label -->
<field name='no'>
7
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR7:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR7:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>There can be many cost specifications for sorting. For example, if we are not interested in parallelism, we can specify <span class="math inline">\(O(n \log{n})\)</span> work but no bounds on the span. There is another cost specification below that requires even smaller span but allows for more work. We usually care more about work and thus would prefer the first cost specification; there might, however, be cases where the second specification is preferable.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
There can be many cost specifications for sorting.  For example, if we
are not interested in parallelism, we can specify $O(n \log{n})$ work
but no bounds on the span. There is another cost specification below
that requires even smaller span but allows for more work.
%
We usually care more about work and thus would prefer the first cost
specification; there might, however, be cases where the second
specification is preferable.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR8
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR8
</field> <!-- label -->
<field name='no'>
8
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='costspec'>
<field name='title'>
<![CDATA[
Comparison Sort: Inefficient but Parallel
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Comparison Sort: Inefficient but Parallel
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR8:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR8:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n^2)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n^2)$ work
and $O(\log n)$ span.
]]>
</field> <!-- body_raw -->
</atom> <!-- costspec -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR9
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR9
</field> <!-- label -->
<field name='no'>
9
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Data Structure Specification
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Data Structure Specification
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR9:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR9:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We specify a data structure by describing what is expected of the data structure via an <span> </span>. As with algorithms, we usually give cost specifications to data structures. For example, we can specify a priority queue ADT and give it a cost specification.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We specify a data structure by describing what is expected of the data
structure via an~\defn{Abstract Data Type (ADT) specification}.
%
As with algorithms, we usually give cost specifications to data
structures.
%
For example, we can specify a priority queue ADT and give it a cost
specification. 
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR10
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR10
</field> <!-- label -->
<field name='no'>
10
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='datatype'>
<field name='title'>
<![CDATA[
Priority Queue
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Priority Queue
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR10:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR10:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>A priority queue consists of a priority queue type and supports three operations on values of this type. The operation <span class="math inline">\({\texttt{empty}}\)</span> returns an empty queue. The operation <span class="math inline">\({\texttt{insert}}\)</span> inserts a given value with a priority into the queue and returns the queue. The operation <span class="math inline">\({\texttt{removeMin}}\)</span> removes the value with the smallest priority from the queue and returns it.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
A priority queue consists of a priority queue type and supports three
operations on values of this type.  The operation $\cd{empty}$ returns
an empty queue.  The operation $\cd{insert}$ inserts a given value with
a priority into the queue and returns the queue.  The operation
$\cd{removeMin}$ removes the value with the smallest priority from the
queue and returns it.
]]>
</field> <!-- body_raw -->
</atom> <!-- datatype -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR11
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR11
</field> <!-- label -->
<field name='no'>
11
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='costspec'>
<field name='title'>
<![CDATA[
Priority Queue: Basic
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Priority Queue: Basic
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR11:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR11:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>The work and span of a priority queue operations are as follows.</p>
<ul>
<li><p><span class="math inline">\({\texttt{create}}\)</span>: <span class="math inline">\(O(1)\)</span>, <span class="math inline">\(O(1)\)</span>.</p></li>
<li><p><span class="math inline">\({\texttt{insert}}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
<li><p><span class="math inline">\({\texttt{removeMin}}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
The work and span of a priority queue operations are as follows.
\begin{itemize}
\item $\cd{create}$: $O(1)$, $O(1)$.
\item $\cd{insert}$: $O(\log{n})$, $O(\log{n})$.
\item $\cd{removeMin}$: $O(\log{n})$, $O(\log{n})$.
\end{itemize}
]]>
</field> <!-- body_raw -->
</atom> <!-- costspec -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR12
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR12
</field> <!-- label -->
<field name='no'>
12
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Problem
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Problem
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR12:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR12:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>A <span> </span> requires meeting an algorithm or an ADT specification and a corresponding cost specification. Since we allow specifying algorithms and data structures, we can distinguish between algorithms problems and data-structure problems. An <span> </span> requires designing an algorithm that satisfies the given algorithm specification and cost specification if any. A <span> </span> requires meeting an ADT specification by designing a data structure that can support the desired operations with the required efficiency specified by the cost specification. The difference between an algorithms problem and a data-structures problem is that the latter involves designing a data structure and a collection of algorithms, one for each operation, that operate on that data structure.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
A~\defn{problem} requires meeting an algorithm or an ADT specification
and a corresponding cost specification.
%
Since we allow specifying algorithms and data structures, we can
distinguish between algorithms problems and data-structure problems.
%

An~\defn{algorithms problem} requires designing an algorithm that
satisfies the given algorithm specification and cost specification if
any.
%

A~\defn{data-structures problem} requires meeting an ADT
specification by designing a data structure that can
support the desired operations with the required efficiency specified
by the cost specification.
%

The difference between an algorithms problem and a data-structures
problem is that the latter involves designing a data structure and a
collection of algorithms, one for each operation, that operate on that
data structure.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR13
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR13
</field> <!-- label -->
<field name='no'>
13
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='note'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR13:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR13:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>When we consider problems, it is usually clear from the context whether we are talking about algorithms or data structures. In such cases, we use the simpler terms <span> </span> and <span> </span> to refer to the algorithm/ADT specification and the corresponding problem respectively.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
When we consider problems, it is usually clear from the context
whether we are talking about algorithms or data structures.
%
In such cases, we use the simpler terms~\defn{specification}
and~\defn{problem} to refer to the algorithm/ADT specification and the
corresponding problem respectively.
]]>
</field> <!-- body_raw -->
</atom> <!-- note -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR14
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR14
</field> <!-- label -->
<field name='no'>
14
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Implementation
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
Implementation
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR14:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR14:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We can solve an algorithms or a data-structures problem by presenting an <span> </span>. The term <span> </span> refers to an implementation that solves an algorithms problem and the term <span> </span> to refer to an implementation that solves a data-structures problem. We note that while the distinction between problems and algorithms is common in the literature, the distinction between abstract data types and data structures is less so.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We can solve an algorithms or a data-structures problem by presenting
an~\defn{implementation}.  
%
The term~\defn{algorithm} refers to an implementation that solves an
algorithms problem and the term~\defn{data structure} to
refer to an implementation that solves a data-structures problem.
%
We note that while the distinction between problems and algorithms is
common in the literature, the distinction between abstract data types
and data structures is less so.
%
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR15
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR15
</field> <!-- label -->
<field name='no'>
15
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='teachnote'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR15:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR15:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Why do we think this distinction is important?</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Why do we think this distinction is important?
]]>
</field> <!-- body_raw -->
</atom> <!-- teachnote -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR16
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR16
</field> <!-- label -->
<field name='no'>
16
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR16:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR16:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>We describe an algorithm by using the pseudo-code notation based on <span>SPARC</span>, the language used in this book. For example, we can specify the classic insertion sort algorithm as follows. <span class="math display">\[\begin{array}{l} 
{\texttt{insSort}}~f~s = 
\\  
~~{\texttt{if}}~|s| = 0~{\texttt{then}}  
\\ 
~~~~{\left\langle\,  \,\right\rangle} 
\\ 
~~{\texttt{else}}~{\texttt{insert}}~f~s[0]~({\texttt{insSort}}~f~(s[1,...,n-1])) 
\end{array}\]</span></p>
<p>In the algorithm, <span class="math inline">\(f\)</span> is the comparison function and <span class="math inline">\(s\)</span> is the input sequence. The algorithm uses a function (<span class="math inline">\({\texttt{insert}}~f~x~s\)</span>) that takes the comparison function <span class="math inline">\(f\)</span>, an element <span class="math inline">\(x\)</span>, and a sequence <span class="math inline">\(s\)</span> sorted by <span class="math inline">\(f\)</span>, and inserts <span class="math inline">\(x\)</span> in the appropriate place. Inserting into a sorted sequence is itself an algorithms problem, since we are not specifying how it is implemented, but just specifying its functionality. We might also be given a cost specification for <span class="math inline">\({\texttt{insert}}\)</span>, e.g., for a sequence of length <span class="math inline">\(n\)</span> the cost of <span class="math inline">\({\texttt{insert}}\)</span> should be <span class="math inline">\(O(n)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span. Given this cost we can determine the overall asymptotic cost of <span class="math inline">\({\texttt{sort}}\)</span> using our composition rules described in the last section. Since the code uses <span class="math inline">\({\texttt{insert}}\)</span> sequentially and since there are <span class="math inline">\(n\)</span> inserts, the algorithm <span class="math inline">\({\texttt{insSort}}\)</span> has <span class="math inline">\(n \times O(n) = 
O(n^2)\)</span> work and <span class="math inline">\(n \times O(\log n) = O(n \log n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
We describe an algorithm by using the pseudo-code notation based on
\pml, the language  used in this book.  For example, we can specify
the classic insertion sort algorithm as follows.
%

\[
\begin{array}{l}
\cd{insSort}~f~s =
\\ 
~~\cd{if}~|s| = 0~\cd{then} 
\\
~~~~\cseq{}
\\
~~\cd{else}~\cd{insert}~f~s[0]~(\cd{insSort}~f~(s[1,...,n-1]))
\end{array}
\]


In the algorithm, $f$ is the comparison function and $s$ is the input
sequence.  
%
The algorithm uses a function ($\cd{insert}~f~x~s$) that
takes the comparison function $f$, an element $x$, and a sequence $s$
sorted by $f$, and inserts $x$ in the appropriate place.  
%
Inserting into a sorted sequence is itself an algorithms problem,
since we are not specifying how it is implemented, but just specifying
its functionality.  
%
We might also be given a cost specification for $\cd{insert}$, e.g., for
a sequence of length $n$ the cost of $\cd{insert}$ should be $O(n)$
work and $O(\log n)$ span.  
%
Given this cost we can determine the overall asymptotic cost of
$\cd{sort}$ using our composition rules described in the last section.
%
Since the code uses $\cd{insert}$ sequentially and since there are $n$
inserts, the algorithm $\cd{insSort}$ has $n \times O(n) =
O(n^2)$ work and $n \times O(\log n) = O(n \log n)$ span.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR17
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR17
</field> <!-- label -->
<field name='no'>
17
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR17:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR17:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Similarly, we can specify a data structure by specifying the data type used by the implementation, and the algorithms for each operation. For example, we can implement a priority queue with a binary heap data structure and describe each operation as an algorithm that operates on this data structure. In other words, a data structure can be viewed as a collection of algorithms that operate on the same organization of the data.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Similarly, we can specify a data structure by specifying the data type
used by the implementation, and the algorithms for each operation.
%
For example, we can implement a priority queue with a binary heap data
structure and describe each operation as an algorithm that operates on
this data structure.  In other words, a data structure can be viewed
as a collection of algorithms that operate on the same organization
of the data.
]]>
</field> <!-- body_raw -->
</atom> <!-- gram -->
</block> <!-- group -->

<block name='group'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR18
</field> <!-- unique -->
<field name='label'>
group:15210:S18:CH1:SEC1:UN4:GR18
</field> <!-- label -->
<field name='no'>
18
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->

<atom name='remark'>
<field name='title'>
<![CDATA[
On the importance of specification
]]>
</field> <!-- title -->
<field name='title_raw'>
<![CDATA[
On the importance of specification
]]>
</field> <!-- title_raw -->
<field name='unique'>
15210:S18:CH1:SEC1:UN4:GR18:AT1
</field> <!-- unique -->
<field name='label'>
atom:15210:S18:CH1:SEC1:UN4:GR18:AT1
</field> <!-- label -->
<field name='no'>
1
</field> <!-- no -->
<field name='parents'>
...NOT.PROVIDED.PARENTS...
</field> <!-- parents -->
<field name='body'>
<![CDATA[
<p>Several reasons underline the importance of distinguishing between specification and implementation.</p>
<p>First, we want to be able to use a specification without knowing the details of an implementation that matches that specification. In many cases the specification of a problem is quite simple, but an efficient algorithm or data structure that solves it, i.e., the implementation, is complicated. Specifications allow us abstract from implementation details. Second, we want to be able to change or improve implementations over time. As long as each implementation matches the same specification, and the user relied only on the specification, then he or she can continue using the new implementation without worrying about their code breaking. Third, when we compare the performance of different algorithms or data structures it is important that we are not comparing apples with oranges. We have to make sure the algorithms we compare are solving the same problem, because subtle differences in the problem specification can make a significant difference in how efficiently that problem can be solved.</p>
]]>
</field> <!-- body -->
<field name='body_raw'>
<![CDATA[
Several reasons underline the importance of distinguishing between
specification and implementation.  

First, we want to be able to use a specification without knowing the
details of an implementation that matches that specification.
%
In many cases the specification of a problem is quite simple, but an
efficient algorithm or data structure that solves it, i.e., the
implementation, is complicated.  
%
Specifications allow us abstract from implementation details.
%

Second, we want to be able to change or improve implementations over
time.  As long as each implementation matches the same specification,
and the user relied only on the specification, then he or she can
continue using the new implementation without worrying about their
code breaking. 
%

Third, when we compare the performance of different
algorithms or data structures it is important that we are not
comparing apples with oranges.  We have to make sure the algorithms we
compare are solving the same problem, because subtle differences in
the problem specification can make a significant difference in how
efficiently that problem can be solved.
]]>
</field> <!-- body_raw -->
</atom> <!-- remark -->
</block> <!-- group -->

</block> <!-- unit -->
</block> <!-- section -->
</block> <!-- chapter -->
</block> <!-- book -->
</block> <!-- course -->
