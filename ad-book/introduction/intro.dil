%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilCourse}
\begin{dilFieldTitle}
Parallel and Sequential Algorithms
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parallel and Sequential Algorithms
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210
\end{dilFieldUnique}
\begin{dilLabel}
15210
\end{dilLabel}
\begin{dilNo}
15210
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldCourseNumber}
15210
\end{dilFieldCourseNumber}
\begin{dilFieldPicture}
/210/course/air-pavilion.jpg
\end{dilFieldPicture}
\begin{dilFieldSemester}
Spring 2018
\end{dilFieldSemester}
\begin{dilFieldWebsite}
http://www.cs.cmu.edu/~15210
\end{dilFieldWebsite}
\begin{dilFieldProvidesBook}
S18
\end{dilFieldProvidesBook}
\begin{dilFieldProvidesChapter}
1
\end{dilFieldProvidesChapter}
\begin{dilFieldProvidesSection}
1
\end{dilFieldProvidesSection}
\begin{dilFieldProvidesUnit}
1
\end{dilFieldProvidesUnit}
\begin{dilFieldProvidesAssignment}
1
\end{dilFieldProvidesAssignment}
\begin{dilIntro}
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>

\end{dilIntro}
\begin{dilIntroDex}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilBook}
\begin{dilFieldTitle}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18
\end{dilFieldUnique}
\begin{dilLabel}
book:15210:S18
\end{dilLabel}
\begin{dilNo}
0
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldAuthors}
Umut A. Acar and Guy Blelloch
\end{dilFieldAuthors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilChapter}
\begin{dilFieldTitle}
Introduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Introduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1
\end{dilFieldUnique}
\begin{dilLabel}
chapter:15210:S18:CH1:ch:intro
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldPicture}
./media/la-tour-aux-rideaux.jpg
\end{dilFieldPicture}
\begin{dilIntro}
<p>This chapter presents a brief overview of the methodology followed in this book.</p>

\end{dilIntro}
\begin{dilIntroDex}





This chapter presents a brief overview of the methodology followed in
this book.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Introduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Introduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH1:SEC1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>This section presents an overview of the approach taken in this book.</p>

\end{dilIntro}
\begin{dilIntroDex}


This section presents an overview of the approach taken in this book.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Specification, Problem, Implementation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Specification, Problem, Implementation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH1:SEC1:UN1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Problem solving in computer science requires reasoning precisely about problems being studied and the properties of solutions. To facilitate such reasoning, we define problems by specifying them and describe the desired properties of solutions at different levels of abstraction, such as the cost and the implementation of the solution.</p>
<p>In this book, we are usually interested in two distinct classes of problems: algorithms problems and data structures problems.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Problem solving in computer science requires reasoning precisely about
problems being studied and the properties of solutions.
%
To facilitate such reasoning,  we define problems by
specifying them and describe the desired properties of solutions at
different levels of abstraction, such as the cost and the
implementation  of the solution.

In this book, we are usually interested in two distinct classes of
problems: algorithms problems and data structures problems.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Algorithm Specification
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Algorithm Specification
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We specify an algorithm by describing what is expected of the algorithm via an  <span style="color: black"><span><strong><em>algorithm specification</em></strong></span></span>. For example, we can specify a sorting algorithm for sequences with respect to a given comparison function as follows.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We specify an algorithm by describing what is expected of the
algorithm via an~\defn{algorithm specification}.
%
For example, we can specify a sorting algorithm for sequences with
respect to a given comparison function as follows.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Comparison Sort
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Comparison Sort
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Given a sequence <span class="math inline">\(A\)</span> of <span class="math inline">\(n\)</span> elements taken from a totally ordered set with comparison operator <span class="math inline">\(\leq\)</span>, return a comparison-sorting algorithm sequence <span class="math inline">\(B\)</span> containing the same elements but such that <span class="math inline">\(B[i] \leq 
B[j]\)</span> for <span class="math inline">\(0 \leq i &lt; j &lt; n\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given a sequence $A$ of $n$ elements taken from a totally ordered set
with comparison operator $\leq$, return a comparison-sorting algorithm
sequence $B$ containing the same elements but such that $B[i] \leq
B[j]$ for $0 \leq i < j < n$.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The specification describes  <span style="color: black"><span><strong><em>what</em></strong></span></span> the algorithm should do but it does not describe  <span style="color: black"><span><strong><em>how</em></strong></span></span> it achieves what is asked. This is intentional—and is exactly the point—because there can be many algorithms that meet a specification.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The specification describes~\defn{what} the algorithm should do but it
does not describe~\defn{how} it achieves what is asked.
%
This is intentional---and is exactly the point---because there can be
many algorithms that meet a specification.
%

\end{dilFieldBodyDex}
\end{dilAtomNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A crucial property of any algorithm is its resource requirements or its  <span style="color: black"><span><strong><em>cost</em></strong></span></span>. For example, of the many ways algorithms for sorting a sequence, we may prefer some over the others. We specify the cost of class of algorithms with a  <span style="color: black"><span><strong><em>cost specification</em></strong></span></span>. For example, the following cost specification states that a particular class of parallel sorting algorithms performs <span class="math inline">\(O(n \log{n})\)</span> work and <span class="math inline">\(O(\log^2{n})\)</span> span.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A crucial property of any algorithm is its resource requirements or
its~\defn{cost}.
%
For example, of the many ways algorithms for sorting a sequence, we
may prefer some over the others.  
%
We specify the cost of class of algorithms with a~\defn{cost
  specification}.  For example, the following cost specification
states that a particular class of parallel sorting algorithms performs
$O(n \log{n})$ work and $O(\log^2{n})$ span.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomCostSpec}
\begin{dilFieldTitle}
Comparison Sort: Efficient &amp; Parallel
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Comparison Sort: Efficient \& Parallel
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n \log n)\)</span> work and <span class="math inline">\(O(\log^2 n)\)</span> span.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n \log n)$
work and $O(\log^2 n)$ span.

\end{dilFieldBodyDex}
\end{dilAtomCostSpec}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>There can be many cost specifications for sorting. For example, if we are not interested in parallelism, we can specify <span class="math inline">\(O(n \log{n})\)</span> work but no bounds on the span. There is another cost specification below that requires even smaller span but allows for more work. We usually care more about work and thus would prefer the first cost specification; there might, however, be cases where the second specification is preferable.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
There can be many cost specifications for sorting.  For example, if we
are not interested in parallelism, we can specify $O(n \log{n})$ work
but no bounds on the span. There is another cost specification below
that requires even smaller span but allows for more work.
%
We usually care more about work and thus would prefer the first cost
specification; there might, however, be cases where the second
specification is preferable.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomCostSpec}
\begin{dilFieldTitle}
Comparison Sort: Inefficient but Parallel
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Comparison Sort: Inefficient but Parallel
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n^2)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n^2)$ work
and $O(\log n)$ span.

\end{dilFieldBodyDex}
\end{dilAtomCostSpec}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Data Structure Specification
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Data Structure Specification
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We specify a data structure by describing what is expected of the data structure via an  <span style="color: black"><span><strong><em>Abstract Data Type (ADT) specification</em></strong></span></span>. As with algorithms, we usually give cost specifications to data structures. For example, we can specify a priority queue ADT and give it a cost specification.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We specify a data structure by describing what is expected of the data
structure via an~\defn{Abstract Data Type (ADT) specification}.
%
As with algorithms, we usually give cost specifications to data
structures.
%
For example, we can specify a priority queue ADT and give it a cost
specification. 
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDatatype}
\begin{dilFieldTitle}
Priority Queue
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Priority Queue
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A priority queue consists of a priority queue type and supports three operations on values of this type. The operation <span class="math inline">\(\texttt{empty}\)</span> returns an empty queue. The operation <span class="math inline">\(\texttt{insert}\)</span> inserts a given value with a priority into the queue and returns the queue. The operation <span class="math inline">\(\texttt{removeMin}\)</span> removes the value with the smallest priority from the queue and returns it.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A priority queue consists of a priority queue type and supports three
operations on values of this type.  The operation $\cd{empty}$ returns
an empty queue.  The operation $\cd{insert}$ inserts a given value with
a priority into the queue and returns the queue.  The operation
$\cd{removeMin}$ removes the value with the smallest priority from the
queue and returns it.

\end{dilFieldBodyDex}
\end{dilAtomDatatype}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomCostSpec}
\begin{dilFieldTitle}
Priority Queue: Basic
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Priority Queue: Basic
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The work and span of a priority queue operations are as follows.</p>
<ul>
<li><p><span class="math inline">\(\texttt{create}\)</span>: <span class="math inline">\(O(1)\)</span>, <span class="math inline">\(O(1)\)</span>.</p></li>
<li><p><span class="math inline">\(\texttt{insert}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
<li><p><span class="math inline">\(\texttt{removeMin}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The work and span of a priority queue operations are as follows.
\begin{itemize}
\item $\cd{create}$: $O(1)$, $O(1)$.
\item $\cd{insert}$: $O(\log{n})$, $O(\log{n})$.
\item $\cd{removeMin}$: $O(\log{n})$, $O(\log{n})$.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomCostSpec}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR12
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Problem
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Problem
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR12:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR12:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>problem</em></strong></span></span> requires meeting an algorithm or an ADT specification and a corresponding cost specification. Since we allow specifying algorithms and data structures, we can distinguish between algorithms problems and data-structure problems.</p>
<p>An  <span style="color: black"><span><strong><em>algorithms problem</em></strong></span></span> requires designing an algorithm that satisfies the given algorithm specification and cost specification if any.</p>
<p>A  <span style="color: black"><span><strong><em>data-structures problem</em></strong></span></span> requires meeting an ADT specification by designing a data structure that can support the desired operations with the required efficiency specified by the cost specification.</p>
<p>The difference between an algorithms problem and a data-structures problem is that the latter involves designing a data structure and a collection of algorithms, one for each operation, that operate on that data structure.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{problem} requires meeting an algorithm or an ADT specification
and a corresponding cost specification.
%
Since we allow specifying algorithms and data structures, we can
distinguish between algorithms problems and data-structure problems.
%

An~\defn{algorithms problem} requires designing an algorithm that
satisfies the given algorithm specification and cost specification if
any.
%

A~\defn{data-structures problem} requires meeting an ADT
specification by designing a data structure that can
support the desired operations with the required efficiency specified
by the cost specification.
%

The difference between an algorithms problem and a data-structures
problem is that the latter involves designing a data structure and a
collection of algorithms, one for each operation, that operate on that
data structure.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR13
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR13
\end{dilLabel}
\begin{dilNo}
13
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR13:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR13:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>When we consider problems, it is usually clear from the context whether we are talking about algorithms or data structures. In such cases, we use the simpler terms  <span style="color: black"><span><strong><em>specification</em></strong></span></span> and  <span style="color: black"><span><strong><em>problem</em></strong></span></span> to refer to the algorithm/ADT specification and the corresponding problem respectively.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
When we consider problems, it is usually clear from the context
whether we are talking about algorithms or data structures.
%
In such cases, we use the simpler terms~\defn{specification}
and~\defn{problem} to refer to the algorithm/ADT specification and the
corresponding problem respectively.

\end{dilFieldBodyDex}
\end{dilAtomNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR14
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR14
\end{dilLabel}
\begin{dilNo}
14
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Implementation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Implementation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR14:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR14:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We can solve an algorithms or a data-structures problem by presenting an  <span style="color: black"><span><strong><em>implementation</em></strong></span></span>. The term  <span style="color: black"><span><strong><em>algorithm</em></strong></span></span> refers to an implementation that solves an algorithms problem and the term  <span style="color: black"><span><strong><em>data structure</em></strong></span></span> to refer to an implementation that solves a data-structures problem. We note that while the distinction between problems and algorithms is common in the literature, the distinction between abstract data types and data structures is less so.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We can solve an algorithms or a data-structures problem by presenting
an~\defn{implementation}.  
%
The term~\defn{algorithm} refers to an implementation that solves an
algorithms problem and the term~\defn{data structure} to
refer to an implementation that solves a data-structures problem.
%
We note that while the distinction between problems and algorithms is
common in the literature, the distinction between abstract data types
and data structures is less so.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR15
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR15
\end{dilLabel}
\begin{dilNo}
15
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR15:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR15:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Why do we think this distinction is important?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Why do we think this distinction is important?

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR16
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR16
\end{dilLabel}
\begin{dilNo}
16
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR16:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR16:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We describe an algorithm by using the pseudo-code notation based on SPARC, the language used in this book. For example, we can specify the classic insertion sort algorithm as follows.</p>
<p><span class="math display">\[\begin{array}{l} 
\texttt{insSort}~f~s = 
\\  
~~\texttt{if}~|s| = 0~\texttt{then}  
\\ 
~~~~\left\langle\,  \,\right\rangle 
\\ 
~~\texttt{else}~\texttt{insert}~f~s[0]~(\texttt{insSort}~f~(s[1,...,n-1])) 
\end{array}\]</span></p>
<p>In the algorithm, <span class="math inline">\(f\)</span> is the comparison function and <span class="math inline">\(s\)</span> is the input sequence. The algorithm uses a function (<span class="math inline">\(\texttt{insert}~f~x~s\)</span>) that takes the comparison function <span class="math inline">\(f\)</span>, an element <span class="math inline">\(x\)</span>, and a sequence <span class="math inline">\(s\)</span> sorted by <span class="math inline">\(f\)</span>, and inserts <span class="math inline">\(x\)</span> in the appropriate place. Inserting into a sorted sequence is itself an algorithms problem, since we are not specifying how it is implemented, but just specifying its functionality. We might also be given a cost specification for <span class="math inline">\(\texttt{insert}\)</span>, e.g., for a sequence of length <span class="math inline">\(n\)</span> the cost of <span class="math inline">\(\texttt{insert}\)</span> should be <span class="math inline">\(O(n)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span. Given this cost we can determine the overall asymptotic cost of <span class="math inline">\(\texttt{sort}\)</span> using our composition rules described in the last section. Since the code uses <span class="math inline">\(\texttt{insert}\)</span> sequentially and since there are <span class="math inline">\(n\)</span> inserts, the algorithm <span class="math inline">\(\texttt{insSort}\)</span> has <span class="math inline">\(n \times O(n) = 
O(n^2)\)</span> work and <span class="math inline">\(n \times O(\log n) = O(n \log n)\)</span> span.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We describe an algorithm by using the pseudo-code notation based on
\pml, the language  used in this book.  For example, we can specify
the classic insertion sort algorithm as follows.
%

\[
\begin{array}{l}
\cd{insSort}~f~s =
\\ 
~~\cd{if}~|s| = 0~\cd{then} 
\\
~~~~\cseq{}
\\
~~\cd{else}~\cd{insert}~f~s[0]~(\cd{insSort}~f~(s[1,...,n-1]))
\end{array}
\]


In the algorithm, $f$ is the comparison function and $s$ is the input
sequence.  
%
The algorithm uses a function ($\cd{insert}~f~x~s$) that
takes the comparison function $f$, an element $x$, and a sequence $s$
sorted by $f$, and inserts $x$ in the appropriate place.  
%
Inserting into a sorted sequence is itself an algorithms problem,
since we are not specifying how it is implemented, but just specifying
its functionality.  
%
We might also be given a cost specification for $\cd{insert}$, e.g., for
a sequence of length $n$ the cost of $\cd{insert}$ should be $O(n)$
work and $O(\log n)$ span.  
%
Given this cost we can determine the overall asymptotic cost of
$\cd{sort}$ using our composition rules described in the last section.
%
Since the code uses $\cd{insert}$ sequentially and since there are $n$
inserts, the algorithm $\cd{insSort}$ has $n \times O(n) =
O(n^2)$ work and $n \times O(\log n) = O(n \log n)$ span.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR17
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR17
\end{dilLabel}
\begin{dilNo}
17
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR17:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR17:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Similarly, we can specify a data structure by specifying the data type used by the implementation, and the algorithms for each operation. For example, we can implement a priority queue with a binary heap data structure and describe each operation as an algorithm that operates on this data structure. In other words, a data structure can be viewed as a collection of algorithms that operate on the same organization of the data.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Similarly, we can specify a data structure by specifying the data type
used by the implementation, and the algorithms for each operation.
%
For example, we can implement a priority queue with a binary heap data
structure and describe each operation as an algorithm that operates on
this data structure.  In other words, a data structure can be viewed
as a collection of algorithms that operate on the same organization
of the data.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR18
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR18
\end{dilLabel}
\begin{dilNo}
18
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}
On the importance of specification
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
On the importance of specification
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR18:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR18:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Several reasons underline the importance of distinguishing between specification and implementation.</p>
<p>First, we want to be able to use a specification without knowing the details of an implementation that matches that specification. In many cases the specification of a problem is quite simple, but an efficient algorithm or data structure that solves it, i.e., the implementation, is complicated. Specifications allow us abstract from implementation details.</p>
<p>Second, we want to be able to change or improve implementations over time. As long as each implementation matches the same specification, and the user relied only on the specification, then he or she can continue using the new implementation without worrying about their code breaking.</p>
<p>Third, when we compare the performance of different algorithms or data structures it is important that we are not comparing apples with oranges. We have to make sure the algorithms we compare are solving the same problem, because subtle differences in the problem specification can make a significant difference in how efficiently that problem can be solved.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Several reasons underline the importance of distinguishing between
specification and implementation.  

First, we want to be able to use a specification without knowing the
details of an implementation that matches that specification.
%
In many cases the specification of a problem is quite simple, but an
efficient algorithm or data structure that solves it, i.e., the
implementation, is complicated.  
%
Specifications allow us abstract from implementation details.
%

Second, we want to be able to change or improve implementations over
time.  As long as each implementation matches the same specification,
and the user relied only on the specification, then he or she can
continue using the new implementation without worrying about their
code breaking. 
%

Third, when we compare the performance of different
algorithms or data structures it is important that we are not
comparing apples with oranges.  We have to make sure the algorithms we
compare are solving the same problem, because subtle differences in
the problem specification can make a significant difference in how
efficiently that problem can be solved.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR19
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH1:SEC1:UN1:GR19
\end{dilLabel}
\begin{dilNo}
19
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH1:SEC1:UN1:GR19:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH1:SEC1:UN1:GR19:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[{x} \above 4pt {y}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
    {x} \above 4pt {y}
  \]

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
\end{dilChapter}
\end{dilBook}
\end{dilCourse}
