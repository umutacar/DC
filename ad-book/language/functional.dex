\documentclass{course}
\title{Parallel and Sequential Algorithms}

% Course number must be unique in the database
\coursenumber{15210}

\semester{Spring 2018}
\picture{/210/course/artemis.jpg}
\website{http://www.cs.cmu.edu/~15210}

% Provides book
% This must be provided
% The name should be relative to course number.
\providesbook{S18}

% Start counting chapters from 
% This is optional. Will start counting at 1.
\provideschapter{3}
\providessection{3}

15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking â€” i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues. Concepts
covered in this class include:


\begin{book}
\title{Algorithm Design: Parallel and Sequential}
\label{15210-2016}
\unique{15210S18}
\authors{Umut A. Acar and Guy Blelloch}


\begin{chapter}[SPARC: A Strict Language for Parallel Computing]
\picture{/210/language/dora-maar-seated.jpg}


This chapter presents \pml{}: a parallel functional language used
throughout the book for specifying algorithms.

%
\begin{section}[Functional Algorithms]

\begin{unit}[Effects and Purity]
\begin{gram}
Many parallel algorithms are \defn{purely functional}.  To understand
what this means, let's review first what it means for an algorithm to
be pure and functional.
%
\end{gram}

\begin{group}
\begin{definition}[Side Effects]
We say that a computation has a \defn{side effect}, if in addition to
returning a value, it also performs an effect such as writing to an
existing memory location, printing on the screen, or writing to a
file.
%
\end{definition}

\begin{example}
Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number, and also updates
the argument $n$ by overwriting it with the return value.
%
This function has the side effect of changing the value of its
argument.
%
\end{example}
\end{group}

\begin{group}
\begin{definition}[Pure computation]
We say that  a computation is  \defn{pure} if it doesn't perform any side
  effects.
%
Pure computations return a value without performing any side effects.
%
In contrast an \defn{impure} or \defn{imperative} computation can
perform side effects.  The Fibonacci function described above is
impure.
%
\end{definition}
\begin{example}
Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number by recursively
computing the $(n-1)^{st}$ and $(n-2)^{nd}$ Fibonacci numbers and
summing them up.
%
This function is pure because it has no side effects.
\end{example}
\end{group}

\begin{gram}
Pure computations correspond closely with mathematical systems or
notation, where for example, determining the result of a calculation
of formula does not affect the result of another.
%
The notion of purity can be further extended to allow for effects
that are not \defn{observable}.  
%
For example, the Fibonacci function
described above may be implemented by using a mutable reference that
holds some intermediate value that may be used to compute
the result.
%
If this reference is not observable (e.g., not visible to the caller
of the function), the function has no observable
effect, and can thus be considered pure.  Such effects are sometimes
called \defn{benign effects}.
%
This more general notion of purity is important because it allows for
example using side effects in a ``responsible'' fashion to improve
efficiency.
\end{gram}

\begin{important}
Strictly speakig there is probably no non-trivial computation that is
pure because almost any computation performs memory effects at the
hardware level.  Encapsulation of effects by observation is therefore
essential for meaningful discussions of purity.
\end{important}


\begin{definition}[Functional Programming]
A programming language is called \defn{functional}, if it does not
restrict the use of functions any more than the use of other values
such as natural numbers.
%
\end{definition}

\begin{gram}
This principle is sometimes referred to as ``functions as first-class
values'' or ``functions as first-class citizens''.  
%
Functional programming languages do not distinguish between a function
and other values: both can be used as building blocks of values,
stored in memory, and passed as arguments to functions, etc.
%
For example, a function that returns the number~\cd{1} under some
argument and the natural number \cd{1} are the same for the purposes
of computation.
%
Treating functions as values leads to a powerful way to code.  
%
For example, we can write \defn{higher-order functions} that take
functions as their arguments.
\end{gram}

\begin{definition}[Purely Functional Algorithm]
A \defn{purely functional algorithm} is an algorithm that is both pure
and functional, i.e., it is described in a functional language and it
avoids use of observable side effects such as imperative updates to
memory locations that can be observed and can thus have an effect on
other computations.
%
\end{definition}

\begin{teachask}
What are the advantages of purely functional algorithms and
programming?
\end{teachask}

\begin{gram}
Purely functional algorithms are particularly useful for parallelism
for  two important reasons.

\begin{itemize}

\item Purely functional algorithms are safe for parallelism.
%
Different parts of the algorithm may be executed in parallel without
affecting each other.
%
In contrast, in imperative programming, the programmer must take care
that side effects don't alter the meaning of the program in
unintended ways.
%
The problem is that preventing side effects from altering the meaning
of the program is very difficult, because 1) depending on the exact
execution order (timing) of components, side effects may cause a
computation to return different results at different times, and 2)
there are exponentially many different orderings.
%


\item
Second, higher-order functions (even in a language that is not pure)
help with the design and implementation of parallel algorithm by
encouraging the designer to think at a higher level of abstraction.
%
For example, instead of thinking about a loop that iterates over the
elements of an array to generate the sum, which is completely
sequential, we can define a higher-order ``reduce'' function. 
%
In addition to taking the array as an argument, the reduce function
takes a binary associative function as another argument.  It then sums
the array based on that binary associative function.
%
The advantage is that the higher-order reduce allows for any
binary associative function (e.g. maximum, minimum, multiplication).
%
By implementing the reduce function as a tree sum, which is highly
parallel, we can thus perform a variety of computations in parallel
rather than sequentially as a loop.
%
In general, thinking in higher order functions encourages working at a
higher level of abstraction, moving us away from the one-at-a-time
(loop) way of thinking that is detrimental to code quality and
to parallelism.
\end{itemize}
% Finally, functional programs don't have traditional loops.  We hope 
% that the lack of such loops discourages the use of sequential code,
% when parallel code is preferable.  For example we will use the 
% following notation 
% \[\cseq{f(x) : x \in S}\]
% to mean apply the function $f$ to each $x$ in the sequence $S$ and return 
% a new sequence.   This is purely functional (assuming $f$ has no side effects) 
% and is also parallel since all the applications of $f$ to each $x$ can 
% happen in parallel. 
\end{gram}

\begin{remark}
Coding a purely functional algorithm does not require a purely
functional programming language.
%
In fact, a purely functional algorithm can be coded in essentially any
programming language---one just needs to be much more careful when
coding imperatively in order to avoid errors caused by sharing of
state and side effects.  
%
Some imperative parallel languages such as extension to the C
language, in fact, encourage programming purely functional algorithms.
%
The techniques that we describe thus are applicable to  imperative
programming languages as  well.
\end{remark}

\end{unit}


\begin{unit}[Race Conditions]


\begin{definition}[Race conditions]
Side effects that alter the result of the computation based on the
evaluation order (timing) are called \defn{race conditions}.
%
\end{definition}

\begin{gram}
Functional algorithms avoi race condition because they do not 
permit observable side effects.  For example, in \pml{}, the language
that we use to describe algorithms in this course, there is no syntax
for memory effects.  
%
To discuss side effects and give example, we will extend \pml{} with a
simple \defn{assignment} operation, which overwrites the value of a
variable.
%
The syntax 
\[
x \la e
\]
means that $e$ is evaluated to a value $v$, $v$ is written into the
variable $x$, and a unit $()$ is returned. 
%
Note that this is different than 
\[
x \la e,
\]
because the latter defines a (new) variable $x$ whose value is that of
$e$.  The variable may shadow an existing variable with the same name
but cannot change its value.
\end{gram}

\begin{example}
Consider the following piece of code where the function $\cd{select}$
calls two functions $\cd{left}$ and $\cd{right}$ in parallel.
%
The return value of $\cd{select}$ depends on the order in which
$\cd{left}$ and $\cd{right}$ execute because $\cd{select}$ passes to
both functions the same reference to write to, whose contents it
returns.

\[
\begin{array}{l}
\cd{left}~x = x \la \cstr{left}
\\ 
\cd{right}~y = y \la \cstr{right}
\\
\cd{select}~() = 
\\
~~\cd{let}

\\
~~~~z \la \cstr{center}
\\
~~~~\cd{par}(\cd{left}, \cd{right})
\\
~~\cd{in}
\\
~~~~!z
\\
~~\cd{end}
\end{array}
\]
\end{example}



\begin{group}
\begin{exercise}
Consider two tiny functions given below that read and write from the
same references.
%
The programmer convinced themselves that the function $\cd{select}$
would return $(\cd{left}, \cd{right}).$

Is the programmer correct? Prove or disprove? 
 
\[
\begin{array}{l}
\cd{left}~(x,y) =\\
~~y \la \cstr{left}
\\ 
~~x \la \cstr{left}
\\
~~\\
\cd{right}~(x,y) =\\
~~x \la \cstr{right}
\\ 
~~y \la \cstr{right}
\\
~~\\
\cd{select}~() = 
\\
~~\cd{let}
\\
~~~~x \la \cstr{center}
\\
~~~~y \la \cstr{center}
\\
~~~~((),()) = \cd{par}(\cd{left}(x,y), \cd{right}(x,y))
\\
~~\cd{in}
\\
~~~~(!x, !y)
\\
~~\cd{end}
\end{array}
\]
\end{exercise}


\begin{solution}
The programmer might have reasoned like this: the two functions
$\cd{left}$ and $\cd{right}$ finish by writing to two different
references $x$ and $y$ respectively.  Since they write respectively
the values $\cstr{left}$ and $\cstr{right}$, the returned value will
be $(\cstr{left}, \cstr{right})$.

This is wrong because it consider only one possible execution order.  
%
There are many others.  For example, the function $\cd{left}$ might
execute to completion and then $\cd{right}$.  In this case, the
returned value will be $(\cstr{right}, \cstr{right})$.
%
The converse is also possible resulting in the return value 
$(\cstr{left}, \cstr{left})$.
\end{solution}

\end{group}


\begin{gram}
Verifying the correctness of an effectful algorithm can require
checking a very large number, e.g., billions or more, of different
execution possibilities.
%
It is nearly impossible for any human being to comprehend such numbers
of different possibilities.
%
There are indeed many examples of parallelism or concurrency bugs in
real systems that lead to sometimes catastrophic outcomes.
\end{gram}


\begin{example}
There are several spectacular examples of correctness problems caused
by race-conditions, including for example the Northeast blackout of
2003, which affected over 50 Million people in North America.

Here are some quotes from the spokesmen of the companies involved in
this event.
%

The first quote below describes the problem, which is a race
condition (multiple computations writing to the same piece of data).
%
"There was a couple of processes that were in contention for a common
data structure, and through a software coding error in one of the
application processes, they were both able to get write access to a
data structure at the same time [...] And that corruption led to the
alarm event application getting into an infinite loop and spinning."
%

The second  quote describes the difficulty of finding the bug.
%
"This fault was so deeply embedded, it took them [the team of
  engineers] weeks of poring through millions of lines of code and
data to find it."
\end{example}

\begin{remark}[Heisenbug]
Race conditions make it difficult to reason about the correctness and
the efficiency of parallel algorithms.  They also make debugging
difficult, because each time the code is run, it might give a
different answer.
%
For example, each time we evaluate a piece of code, we may obtain a
different answer or we may obtain a correct answer 99.99\% of the time
but not always.
%

The term \defn{Heisenbug} was coined in the early 80s to refer to a
type of bug that ``disappears'' when you try to pinpoint or study it
and ``appears'' when you stop studying it.  They are named after the
famous Heisenberg uncertainty principle which roughly says that if you
localize one property, you will lose information about another
complementary property.  Often the most difficult Heisenbugs to find
have to do with race conditions in parallel or concurrent code.  These
are sometimes also called concurrency bugs.
\end{remark}


\begin{exercise}
What are all the different outcomes of the example given above?
\end{exercise}
%\begin{solution}
% There are many including jumbled characters such as $\cstr{leight}$.
%\end{solution}

\end{unit}

\end{section}


\end{chapter}
\end{book}
