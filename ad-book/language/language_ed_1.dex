
\documentclass{course}
\title{Parallel and Sequential Algorithms}
\label{15210}
\no{15210}
\unique{15210}
\parent{...NOT.PROVIDED.PARENTS...}

\coursenumber{15210}
\picture{/210/course/air-pavilion.jpg}
\providesbook{S18}
\provideschapter{3}
\providessection{1}
\providesunit{1}
\providesassignment{1}
\semester{Spring 2018}
\website{http://www.cs.cmu.edu/~15210}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking â€” i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
\begin{book}
\title{Algorithm Design: Parallel and Sequential}
\label{book:15210:S18}
\no{0}
\unique{15210:S18}
\parent{...NOT.PROVIDED.PARENTS...}
\authors{Umut A. Acar and Guy Blelloch}

\begin{chapter}[SPARC: A Strict Language for Parallel Computing]
\label{chapter:15210:S18:CH3}
\no{3}
\unique{15210:S18:CH3}
\parent{...NOT.PROVIDED.PARENTS...}

\picture{./media/dora-maar-seated.jpg}




This chapter presents \pml{}: a parallel functional language used
throughout the book for specifying algorithms.

%
\pml is a strict functional language similar to the ML class of
languages such as Standard ML or SML, Caml, and F\#.
%
In pseudo code, we sometimes use mathematical notation, and even
English descriptions in addition to \pml{} syntax.
%
This chapter describes the basic syntax and semantics of \pml{}; we
introduce additional syntax as needed in the rest of the book.

\begin{section}[Introduction]
\label{section:15210:S18:CH3:SEC1}
\no{1}
\unique{15210:S18:CH3:SEC1}
\parent{...NOT.PROVIDED.PARENTS...}

This section briefly describes lambda calculus.

\begin{unit}[Lambda Calculus]
\label{unit:15210:S18:CH3:SEC1:UN1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR1:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR1:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

As with most functional programming languages, the ML class of
languages are based on the~\defn{lambda calculus} (or $\lambda$
calculus), a computational model developed by Alonzo Church in 1932.
%
The syntax of lambda calculus is very simple and the evaluation of
lambda calculus expressions requires effectively a single rule
called~\defn{beta reduction}.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR2}
\no{2}
\unique{15210:S18:CH3:SEC1:UN1:GR2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Syntax of Lambda Calculus]
\label{atom:15210:S18:CH3:SEC1:UN1:GR2:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR2:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The lambda calculus is a very simple language consisting of
expressions $e$ which can only be one of the following three forms:

\begin{itemize}
\item a variable name, written as $x$,

\item a function definition, written as $(\lambda~x~.~e)$, where $e$ is
  an expression denoting the body of the function, or

\item a function application, written as $e_1~e_2$, where $e_1$ and
  $e_2$ are expressions.
\end{itemize}
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR3}
\no{3}
\unique{15210:S18:CH3:SEC1:UN1:GR3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Beta Reduction]
\label{atom:15210:S18:CH3:SEC1:UN1:GR3:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR3:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

For any function
application for which the left hand expression is a function
definition, beta reduction ``applies the function'' by making the
transformation:
\[ (\lambda~x~.~e_1)~e_2 \longrightarrow e_1[x/e_2] \]
where $e_1[x/e_2]$ roughly means for every (free) occurrence of $x$ in
$e_1$, substitute it with $e_2$.  Computation in the \lc{} consists of
applying beta reduction until there is nothing left to reduce.
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR4}
\no{4}
\unique{15210:S18:CH3:SEC1:UN1:GR4}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR4:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR4:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In the early 30s Church argued that anything that can be ``effectively
computed'' can be computed with the lambda calculus, and therefore
that it is a universal mechanism for computation.  
%
However, it was not until a few years later when Alan Turing developed
the Turing machine and showed its equivalence to the lambda calculus
that the concept of universality became widely accepted.  The fact
that the models were so different, but equivalent in what they can
compute, was a powerful argument for the universality of the models.
We now refer to the hypothesis that anything that can be computed can
be computed with the lambda calculus, or equivalently the Turing
machine, as the~\defn{Church-Turing hypothesis}, and refer to any
computational model that is computationally equivalent to the lambda
calculus as~\defn{Church-Turing complete}.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR5}
\no{5}
\unique{15210:S18:CH3:SEC1:UN1:GR5}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR5:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR5:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Although the lambda calculus allows beta reduction to be applied in
any order, most functional programming languages use a specific order.
%
The two most prominent orders are called ``call-by-value'' or
``call-be-need.''
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR6}
\no{6}
\unique{15210:S18:CH3:SEC1:UN1:GR6}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Call-by-Value]
\label{atom:15210:S18:CH3:SEC1:UN1:GR6:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR6:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In~\defn{call-by-value} evaluation order, a function application
$(\lambda~x~.~e_1)~e_2$ can be evaluated only if the expression $e_2$
is a value first, i.e., $e_2$ is evaluated to a value first and then
beta reduction is applied to evaluate the application.  
%
\end{definition}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR6:AT2}
\no{2}
\unique{15210:S18:CH3:SEC1:UN1:GR6:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

The ML class of languages such as Standard ML, CAML, and OCAML, all
use call-by-value evaluation order.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR7}
\no{7}
\unique{15210:S18:CH3:SEC1:UN1:GR7}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Call-by-Need]
\label{atom:15210:S18:CH3:SEC1:UN1:GR7:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR7:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In~\defn{call-by-need} evaluation order, beta reduction can proceed
for any expression $e_2$.
% 
If during beta reduction $e_2$ is copied into each variable $x$ in the
body, this reduction order is called~\defn{call-by-name}, and if $e_2$
is shared, it is called call-by-need.  
%
\end{definition}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR7:AT2}
\no{2}
\unique{15210:S18:CH3:SEC1:UN1:GR7:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

The Haskell language is perhaps the most well known example of a
call-by-need (or lazy) functional language.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC1:UN1:GR8}
\no{8}
\unique{15210:S18:CH3:SEC1:UN1:GR8}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{important}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC1:UN1:GR8:AT1}
\no{1}
\unique{15210:S18:CH3:SEC1:UN1:GR8:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

All the reduction orders, call-by-value, call-by-name, and
call-by-value are Church-Turing complete.
%
But there are differences in terms of cost.
%
Call-by-name is inefficient, because it can create redundant
computations.
%
Call-by need can be efficient but is inherently sequential.
%
%% TODO: Why? 
%
Call-by-need can also complicate cost analysis because it is difficult
to know if andt when an expression is evaluated. 
%
We therefore only use call-by-value.
\end{important}
\end{group}
\end{unit}
\end{section}

\begin{section}[The SPARC Language]
\label{section:15210:S18:CH3:SEC2}
\no{2}
\unique{15210:S18:CH3:SEC2}
\parent{...NOT.PROVIDED.PARENTS...}

This section describes the syntax and the semantics of the core subset of the
\pml{} language. 
%~\defn[syntax]{Syntax} refers to the structure of the program itself,
while~\defn{semantics} refers to what the program computes.  
%
Since we wish to analyze the cost of algorithms, we are interested in
not just what algorithms compute, but how they compute.
%
Semantics that capture how algorithms compute are
called~\defn{operational semantics}, and when augmented with specific
costs,~\defn{cost semantics}.
%
Here we describe the syntax of \pml{} and present an informal
description of its operational semantics. 
%
%We will talk about cost semantics in \chref{analysis}.
%
While we focus primarily on the core subset of \pml, we also describe
some~\defn{syntactic sugar} that makes it easier to read or write code
without adding any real power.
%
Even though \pml is a strongly typed language, for our purposes in
this book, we use types primarily as a means of describing and
specifying the behavior of our algorithms.
%
We therefore do not present careful account of \pml's type system.

\begin{unit}[Syntax and Semantics of SPARC]
\label{unit:15210:S18:CH3:SEC2:UN2}
\no{2}
\unique{15210:S18:CH3:SEC2:UN2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR1:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR1:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The definition below shows the syntax of \pml{}.
%
A \pml{} program is an expression, whose syntax,
 describe the computations that can be expressed in \pml{}.
%
When evaluated an expression yield a value.
%
Informally speaking, evaluation of an expression proceeds involves
evaluating its sub-expressions to values and then combining these
values  to compute the value of the expression.
%
\pml{} is a strongly typed language, where every closed expression,
which have no undefined (free) variables, evaluates to a value or runs
forever.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR2}
\no{2}
\unique{15210:S18:CH3:SEC2:UN2:GR2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[\pml{} expressions]
\label{atom:15210:S18:CH3:SEC2:UN2:GR2:AT1:def:language::syntax}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR2:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

\setlength{\tabcolsep}{20mm}
\begin{tabular}{llcll}
Identifier
& $id$ & := & $\ldots$
\\

%
Variables
& $x$ & := & $id$
\\

Type Constructors 
& $tycon$ & := & $id$
\\

Data Constructors 
& $dcon$ & := & $id$
\\

Patterns & $p$ 
& := & x & variable
\\
& & $\mid$  & \cd{(} $p$ \cd{)} & parenthesization
\\
& & $\mid$  & $p_1$ \cd{,} $p_2$ & pair
\\
& & $\mid$  & $dcon$ \cd{(}$p$\cd{)} & data pattern
\\

Types & $\tau$ &  := & $\tyint$  & integers
\\
& &  $\mid$ &   $\tybool$  & booleans
\\
& &  $\mid$  & $\tau$ $[$ \cd{*} $\tau$ $]^+$  & products
\\
& &  $\mid$  & $\tau \ra \tau$ & functions
\\
& & $\mid$ & $tycon$         &  type constructors
\\
& & $\mid$ & $dty$ & data types
\\

Data Types & $dty$
& := &   $dcon$$[$\cd{of} $\tau$ $]$ 
\\
&  & $\mid$ &  $dcon$$[$ \cd{of} $\tau$ $]$\cd{|}$dty$
\\

Values & $v$
& := & \cd{0}  $\mid$  \cd{1}  $\mid$  $\ldots$ &  integers
\\
& & $\mid$ &  \cd{-1}  $\mid$ \cd{-2}  $\mid$ $\ldots$ &  integers
\\
& & $\mid$ & \ctrue  $\mid$  \cfalse & booleans
\\
& & $\mid$ & \cd{not}  $\mid$  $\ldots$ & unary operations
\\
& & $\mid$ & \cand  $\mid$  \cd{plus}  $\mid$  $\ldots$ & binary operations
\\
& & $\mid$ & $v_1, v_2$  & pairs
\\
& & $\mid$ & \cd{(} $v$ \cd{)}   & parenthesis
\\
& & $\mid$ & $dcon$\cd{(}$v$\cd{)}               & constructed data
\\
& & $\mid$ & \cfn{$p$}{$e$} & lambda functions
\\

Expression  & $e$ 
& := & $x$ & variables
\\
& & $\mid$ & $v$ & values
\\
& & $\mid$ & $e_1$ op $e_2$ & infix operations
\\
& & $\mid$ & $e_1$\cd{,} $e_2$ & sequential pair
\\
& & $\mid$ & $e_1$ \cd{||} $e_2$ & parallel pair
\\
& & $\mid$ & \cd{(} $e$ \cd{)} & parenthesis
\\
& & $\mid$ & \ccase$e_1$$[$\cd{|}$p$\cdra$e_2$$]^+$  & case
\\
& & $\mid$ & \cif$e_1$\cthen$e_2$\celse$e_3$  & conditionals
\\
& & $\mid$ & $e_1$$e_2$ & \mbox{function application}
\\
& & $\mid$ & \clet$b^+$\cin$e$\cend & \mbox{local bindings}
\\

Operations & $op$ & := & \cd{+}, \cd{-}, \cd{*}, \cd{-}, $\ldots$
\\

Bindings &  $b$ & := & 
$x$ \cd{(} $p$  \cd{)} = $e$ & bind function
\\
&  & $\mid$ & $p$ \cd{=} $e$ & bind pattern
\\
&  & $\mid$ & \ctype$tycon$ \cd{=} $\tau$ & bind type 
\\
&  & $\mid$ & \ctype$tycon$ \cd{=} $dty$ & bind datatype
\\

\end{tabular}
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR3}
\no{3}
\unique{15210:S18:CH3:SEC2:UN2:GR3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Identifiers]
\label{atom:15210:S18:CH3:SEC2:UN2:GR3:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR3:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In \pml, variables, type constructors, and data constructors are given
a name, or an~\defn{identifier}.  
%
An identifer consist of only alphabetic and numeric characters (a-z,
A-Z, 0-9), the underscore character (``\_''), and optionally end with
some number of ``primes''.  
%
Example identifiers include, $x'$, $x_1$, $x_l$, $myVar$,
$myType$, $myData$, and $my\_data$.

%but \cd{myVar1}, \cd{my-type} and \cd{my\_data} are not.

Program~\defn{variables},~\defn{type constructors}, and~\defn{data
  constructors} are all instances of identifiers.
%
%% Free or bound variables
During evaluation of a \pml expression, variables are bound to values,
which may then be used in  a computation later.  
%
In \pml, variable are~\defn{bound} during function application, as part
of matching the formal arguments to a function to those specified by
the application, and also by $\cd{let}$ expressions.
%
If, however, a variable appears in an expression but it is not bound
by the expression, then it is~\defn[free variables]{free}
in the expression.
%
We say that an expression is~\defn[closed expressions]{closed} if it
has no free variables.


Types constructors give names to types.  For example, the type of
binary trees may be given the type constructor $\cd{btree}$.
%
Since for the purposes of simplicity, we rely on mathematical rather
than formal specifications, we usually name our types behind
mathematical conventions.
%
For example, we denote the type of natural numbers by $\tynat$, the type
of integers by $\tyint$, and the type of booleans by $\tybool$.


Data constructors serve the purpose of making complex data structures.
%
By convention, we will capitalize data constructors, while starting
variables always with lowercase letters.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR4}
\no{4}
\unique{15210:S18:CH3:SEC2:UN2:GR4}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Patterns]
\label{atom:15210:S18:CH3:SEC2:UN2:GR4:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR4:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In \pml, variables and data constructors can be used to construct more
complex~\defn{patterns} over data.
%
For example, a pattern can be a pair $\cd{(x,y)}$, or a triple of
variables $\cd{(x,y,z)}$, or it can consist of a data constructor
followed by a pattern, e.g., $\cd{Cons}(x)$ or $\cd{Cons}(x,y).$
%
Patterns thus enable a convenient and concise way to pattern match
over the data structures in \pml.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR5}
\no{5}
\unique{15210:S18:CH3:SEC2:UN2:GR5}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Built-in Types]
\label{atom:15210:S18:CH3:SEC2:UN2:GR5:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR5:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Types of \pml include base types such as integers $\tyint$, booleans
$\tybool$, product types such as $\tau_1 \cd{*} \tau_2 \ldots \tau_n$,
function types $\tau_1 \ra \tau_2$ with domain $\tau_1$ and range
$\tau_2$, as well as user defined data types.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR6}
\no{6}
\unique{15210:S18:CH3:SEC2:UN2:GR6}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Data Types]
\label{atom:15210:S18:CH3:SEC2:UN2:GR6:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR6:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In addition to built-in types, a program can define new~\defn{data types} as a
union of tagged types, also called variants, by ``unioning'' them via
distinct~\defn{data constructors}. 
%
For example, the following data type defines a point as a
two-dimensional or a three-dimensional coordinate of integers.
%
%
\[
\begin{array}{lcl}
\cd{type}~\cd{point} & = & \cd{Point2D}~\cd{of}~\tyint~\cd{*}~\tyint
\\
           & | & \cd{Point3D}~\cd{of}~\tyint~\cd{*}~\tyint~\cd{*}~\tyint
\end{array} 
\]
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR7}
\no{7}
\unique{15210:S18:CH3:SEC2:UN2:GR7}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Recursive Data Types]
\label{atom:15210:S18:CH3:SEC2:UN2:GR7:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR7:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

In \pml recursive data types are relatively easy to define and compute
with. For example, we can define a point list data type as follows
%
\[
\begin{array}{l}
\cd{type}~\cd{plist} = \cd{Nil}~|~\cd{Cons}~\cd{of}~\tyint * \cd{plist}.
\end{array}
\] 
%
Based on this definition the list 
%
\[
\begin{array}{l}
\cd{Cons}(\cd{Point2D} (0,0),  
\\
~~~~~~~~~~\cd{Cons}(\cd{Point2D} (0,1), 
\\
~~~~~~~~~~~~~~~~~~~~\cd{Cons}(\cd{Point2D}(0,2), \cd{Nil})))  
\end{array} 
\]
%
defines a list consisting of three points.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR8}
\no{8}
\unique{15210:S18:CH3:SEC2:UN2:GR8}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{exercise}[Booleans]
\label{atom:15210:S18:CH3:SEC2:UN2:GR8:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR8:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Some built-in types such as booleans, $\tybool$, are in fact syntactic
sugar and can be defined by using union types as follows.
%
Describe how you can define booleans using data types of \pml{}.
\end{exercise}

\begin{solution}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR8:AT2}
\no{2}
\unique{15210:S18:CH3:SEC2:UN2:GR8:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

Booleans can be defined as folllows.

\[
\begin{array}{l}
\cd{type}~\cd{myBool} = \cd{myTrue}~|~\cd{myFalse} 
\end{array}
\] 
%
\end{solution}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR9}
\no{9}
\unique{15210:S18:CH3:SEC2:UN2:GR9}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Option Type]
\label{atom:15210:S18:CH3:SEC2:UN2:GR9:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR9:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Throughout the book, we use~\defn{option} types quite frequently.
%
Option types for natural numbers can be defined as follows.
%
\[
\begin{array}{l}
\cd{type}~\cd{option} = \cd{None} ~|~ \cd{Some}~\cd{of}~\tynat
\end{array}
\]
%
Similarly, we can define option types for integers.
%
\[
\begin{array}{l}
\cd{type}~\cd{int_option} = \cd{INone} ~|~ \cd{ISome}~\cd{of}~\tyint
\end{array}
\]
%
Note that we used a different data constructor for naturals.  
%
This is necessary for type inference and type checking.
%
Since, however, types are secondary for our purposes in this book, we
are sometimes sloppy in our use of types for the sake of simplicity.
%
For example, we use throughout $\cd{None}$ and $\cd{Some}$ for option
types regardless of the type of the contents.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR10}
\no{10}
\unique{15210:S18:CH3:SEC2:UN2:GR10}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{teachnote}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR10:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR10:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

TODO: SEQUENCES etc.SETS.
\end{teachnote}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR11}
\no{11}
\unique{15210:S18:CH3:SEC2:UN2:GR11}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Values]
\label{atom:15210:S18:CH3:SEC2:UN2:GR11:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR11:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Values of \pml, which are the irreducible units of computation
include natural numbers, integers, Boolean values $\ctrue$ and $\cfalse$,
unary primitive operations, such as boolean negation $\cd{not}$,
arithmetic negation $\cminus$, as well as binary operations such as
logical and $\cand$ and arithmetic operations such as $\cplus$.
%
Values also include constant-length tuples, which correspond to
product types, whose components are values.
%
Example tuples used commonly through the book include binary tuples or
pairs, and ternary tuples or triples.
%
Similarly, data constructors applied to values, which correspond to
sum types, are also values.
%

As a functional language, \pml treats all function as values. 
%
The anonymous function
%
$\cd{lambda}~p.~e$
%
is a function whose arguments are specified by the pattern $p$, and
whose body is the expression $e$.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR12}
\no{12}
\unique{15210:S18:CH3:SEC2:UN2:GR12}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR12:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR12:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{itemize}

\item

The function 
%
$\cd{lambda}~x. x~\cd{+}~1$ takes a single variable as an argument and
adds one to it.
%

\item
The function 
%
$\cd{lambda}~(x,y).~x$ takes a pairs as an argument and
returns the first component of the pair.
\end{itemize}
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR13}
\no{13}
\unique{15210:S18:CH3:SEC2:UN2:GR13}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Expressions]
\label{atom:15210:S18:CH3:SEC2:UN2:GR13:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR13:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Expressions, denoted by $e$ and variants (with subscript, superscript,
prime), are defined inductively, because in many cases, an expression
contains other expressions.
%
Expressions describe the computations that can be expressed in \pml. 
%
Evaluating an expression via the operational semantics of \pml
produce the value for that expression.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR14}
\no{14}
\unique{15210:S18:CH3:SEC2:UN2:GR14}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Infix Expressions]
\label{atom:15210:S18:CH3:SEC2:UN2:GR14:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR14:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

An~\defn{infix expression}, $e_1~\cd{op}~e_2$, involve two expressions
and an infix operator $\cd{op}$.  The infix operators include $\cd{+}$
(plus), $\cd{-}$ (minus), $\cd{*}$ (multiply), $\cd{/}$ (divide),
$\cd{<}$ (less), $\cd{>}$ (greater), $\cd{or}$, and $\cd{and}.$
%
For all these operators the infix expression
$e_1~\cd{op}~e_2$ is just syntactic sugar for $f(e_1, e_2)$ where
$f$ is the function corresponding to the operator $\cd{op}$ (see
parenthesized names that follow each operator above).  
%

We use standard precedence rules on the operators to indicate their
parsing.  For example in the expression
\[
\cd{3 + 4 * 5}
\]
the $\cd{*}$ has a higher precedence than $\cd{+}$ and therefore the
expression is equivalent to $\cd{3 + (4 * 5)}$. 
%

Furthermore all operators are left associative unless stated
otherwise, i.e., that is to say that $a~\cd{op}_1~b~\cd{op}_2~c =
(a~\cd{op}_1~b)~\cd{op}_2~c$ if $\cd{op}_1$ and $\cd{op}_2$ have the
same precedence.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR15}
\no{15}
\unique{15210:S18:CH3:SEC2:UN2:GR15}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR15:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR15:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The expressions $\cd{5 - 4 + 2}$ evaluates to $\cd{(5-4) + 2 = 3}$ not
$\cd{5 - (4 + 2) = -1}$, because $\cd{-}$ and $\cd{+}$ have the same
precedence.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR16}
\no{16}
\unique{15210:S18:CH3:SEC2:UN2:GR16}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR16:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR16:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

{Sequential and Parallel Composition}
Expressions include two special infix operators: ``$,$'' and
$||$, for generating ordered pairs, or tuples, either
sequentially or in parallel.
%

The~\defn{comma} operator or~\defn{sequential composition} as in the
infix expression $(e_1, e_2)$, evaluates $e_1$ and
$e_2$ sequentially, one after the other, and returns the ordered pair
consisting of the two resulting values.
%
Parenthesis delimit  tuples.
%
%

The~\defn{parallel} operator or~\defn{parallel composition}
``$||$'', as in the infix expression
%
$(e_1~||~e_2)$,
%
evaluates $e_1$ and $e_2$ in parallel, at the same time, and
returns the ordered pair consisting of the two resulting values.
%


The two operators are identical in terms of their return values.
%
However, we will see later, their cost semantics differ: one is
sequential and the other parallel.  The comma and parallel operators
have the weakest, and equal, precedence.
%
\begin{teachnote}
Cost model pointer.
\end{teachnote}
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR17}
\no{17}
\unique{15210:S18:CH3:SEC2:UN2:GR17}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR17:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR17:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{itemize}

\item

The expression 
\[
\begin{array}{l}
\cd{lambda}~(x, y).~(x~\cd{*}~x, y~\cd{*}~y)
\end{array}
\]
is a function that take two arguments $x$ and $y$ and returns a
pair consisting of the squares $x$ and $y$.
%

\item
The expression
\[
\begin{array}{l}
\cd{lambda}~(x, y).~(x~\cd{*}~x~||~y~\cd{*}~y)
\end{array}
\]
is a function that take two arguments $\cd{x}$ and $\cd{y}$ and returns a
pair consisting of the squares $\cd{x}$ and $\cd{y}$ by squaring each of
$\cd{x}$ and $\cd{y}$ in parallel.
\end{itemize}
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR18}
\no{18}
\unique{15210:S18:CH3:SEC2:UN2:GR18}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Case Expressions]
\label{atom:15210:S18:CH3:SEC2:UN2:GR18:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR18:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

A~\defn{case expression} such as 
%
\[
\begin{array}{l}
\cd{case}~e_1 \\
\cd{| Nil}\dra e_2 \\ 
\cd{| Cons}~(x,y)\dra e_3 \\
\end{array}
\]
%
first evaluates the expression $e_1$ to a value $v_1$, which must
return data type.
%
It then matches $v_1$ to one of the patterns, $\cd{Nil}$ or
$\cd{Cons}~(x,y)$ in our example, binds the variable if any in the
pattern to the respective sub-values of $v_1$, and evaluates the
``right hand side'' of the matched pattern, i.e., the expression $e_2$
or $e_3$.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR19}
\no{19}
\unique{15210:S18:CH3:SEC2:UN2:GR19}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Conditionals]
\label{atom:15210:S18:CH3:SEC2:UN2:GR19:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR19:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

A conditional or an~\defn{if-then-else expression},
$\cd{if}~e_1~\cd{then}~e_2~\cd{else}~e_3$, evaluates the expression $e_1$,
which must return a Boolean.
%
If the value of $e_1$ is true then the result of the if-then-else
expression is the result of evaluating $e_2$, otherwise it is the
result of evaluating $e_3$.  
%
This allows for conditional evaluation of expressions.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR20}
\no{20}
\unique{15210:S18:CH3:SEC2:UN2:GR20}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Function Application]
\label{atom:15210:S18:CH3:SEC2:UN2:GR20:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR20:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

A~\defn{function application}, $e_1~e_2$, applies the function
generated by evaluating~$e_1$ to the value generated by
evaluating~$e_2$.  
%
For example, lets say that~$e_1$ evaluates to the function~$f$
and~$e_2$ evaluates to the value~$v$, then we apply~$f$ to~$v$ by
first matching~$v$ to the argument of $f$, which is pattern, to
determine the values of each variable in the pattern.
%
We then substitute in the body of~$f$ the value of each variable for
the variable.  To~\defn{substitute} a value in place of a variable~$x$
in an expression~$e$, we replace each instance of~$x$ with~$v$.
%

For example if function $\cd{lambda}~(x,y).~e$ is applied to the pair
$\cd{(2,3)}$ then $x$ is given value $\cd{2}$ and $y$ is given value
$\cd{3}$. 
%
Any free occurrences of the variables $x$ and $y$ in the
expression $e$ will now be bound to the values $\cd{2}$ and $\cd{3}$
respectively.  
%
We can think of function application as substituting
the argument (or its parts) into the free occurrences of the variables
in its body $e$.
%
The treatment of function application is why we call \pml{} a~\defn{strict} language. 
%
In strict languages, the argument to the function is always evaluated
to a value before applying the function.
%
In contrast non-strict languages wait to see if the argument will be
used before evaluating it to a value. 
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR21}
\no{21}
\unique{15210:S18:CH3:SEC2:UN2:GR21}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR21:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR21:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{itemize}

\item
The expression
\[
(\cd{lambda}~(x,y).~x / y)~(8,2)
\]
\\
evaluates to $\cd{4}$ since $\cd{8}$ and 
$\cd{2}$ are bound to $\cd{x}$ and $\cd{y}$, respectively, and then divided.

\item
The expression 
\[
(\cd{lambda}~(f,x).~f(x,x))~(\cd{plus},3)
\] 
%
evaluates to $\cd{6}$ because $f$ is bound to the function
$\cd{plus}$, $x$ is bound to $\cd{3}$, and then $\cd{plus}$ is applied
to the pair $(\cd{3},\cd{3})$.

\item
The expression
\[
(\cd{lambda}~x.~(\cd{lambda}~y .~x~\cd{+}~y ) )~3
\]
\\
%
evaluates to a function that adds $\cd{3}$ to any integer.
\end{itemize}
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR22}
\no{22}
\unique{15210:S18:CH3:SEC2:UN2:GR22}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[Bindings]
\label{atom:15210:S18:CH3:SEC2:UN2:GR22:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR22:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The~\defn{let expression}, 
\[
\cd{let}~b^+\cd{in}~e~\cd{end},
\] 
%
consists of a sequence of bindings $b^+$, which define local variables
and types, followed by an expression $e$, in which those bindings are
visible.  In the syntax for the bindings, the superscript $+$ means
that $b$ is repeated one or more times.  Each binding $b$ is either a
variable binding, a function binding, or a type binding.
%
The let expressionevaluates to the result of evaluating $e$ given the
variable bindings defined in $b$.

A~\defn{function binding}, $x (p) = e$, consists of a function
name, $x$ (technically a variable), the arguments for the function,
$p$, which are themselves a pattern, and the body of the function,
$e$. 

%

Each~\defn{type binding} equates a type to a base type or a data type.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR23}
\no{23}
\unique{15210:S18:CH3:SEC2:UN2:GR23}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR23:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR23:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Consider the following let expression.
\[
\begin{array}{l}
\cd{let}\\ 
~~x = 2~\cd{+}~3\\
~~f (w) = (w~\cd{*}~4, w~\cd{-}~2)\\
~~(y,z) = f(x-1)\\
\cd{in}\\ 
~~x~\cd{+}~y~\cd{+}~z\\
\cd{end} 
\end{array}
\]

The first  binding the variable $x$ to $\cd{2 + 3 = 5}$;
%
The second binding defines a function $f(w)$ which returns a pair;
%
The third binding applies the function $f$ to $x~\cd{-}~1 = 4$
returning the pair $(\cd{4 * 4}, \cd{4 -2}) = (\cd{16},\cd{2})$, which
  $y$ and $z$ are bound to, respectively (i.e., $y = \cd{16}$ and
  $z = \cd{2}$.
%
Finally the let expressions adds $x, y, z$ and yields $\cd{5 + 16 + 2}$.  The result of the expression is therefore $\cd{23}$.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR24}
\no{24}
\unique{15210:S18:CH3:SEC2:UN2:GR24}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{note}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR24:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR24:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Be careful about defining which variables each binding can see, as
this is important in being able to define recursive functions.  In
\pml{} the expression on the right of each binding in a $\cd{let}$ can
see all the variables defined in previous variable bindings, and can
see the function name variables of all binding (including itself)
within the $\cd{let}$.
%
Therefore the function binding
%
\[
\cd{x}(p) = e
\]
%
is not equivalent to the variable binding
%
\[
\cd{x} = \cd{lambda}~p.e,
\]
%
because in the prior $x$ can be used
in $e$ and in the later it cannot.
%
Function bindings therefore allow for the definition of
recursive functions.  
%
Indeed they allow for mutually recursive functions since the body of
function bindings within the same $\cd{let}$ can reference each other.
\end{note}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR25}
\no{25}
\unique{15210:S18:CH3:SEC2:UN2:GR25}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR25:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR25:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The expression
%
\[
\begin{array}{l}
\cd{let}\\
~~f(i) = \cd{if} ~(i < 2) ~\cd{then}~ i ~\cd{else}~ i ~\cd{*}~
f(i~\cd{-}~\cd{1}) \\
\cd{in} \\ 
~~f(5) \\
\cd{end} 
\end{array}
\]
will evaluate to the factorial of $\cd{5}$, i.e., $\cd{5 * 4 * 3 * 2
* 1}$, which is $\cd{120}.$
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR26}
\no{26}
\unique{15210:S18:CH3:SEC2:UN2:GR26}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR26:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR26:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The piece of code below illustrates an example use of data types and
higher-order functions.
%
\[
\begin{array}{l}
\cd{let}
\\ 
~~\cd{type}~\cd{point} = \cd{Point2D}~\cd{of}~\tyint * \tyint
\\ 
~~~~~~~~~~~~~~~~~~~~~~~~|~~\cd{Point3D}~\cd{of}~ \tyint * \tyint * \tyint
\\
~~\cd{inject3D}~(\cd{Point2D}~(x, y)) = \cd{Point3D}~(x, y, 0)
\\  
~~\cd{project2D}~(\cd{Point3D}~(x, y, z)) = \cd{Point2D}~(x, y)
\\ 
~~\cd{compose}~f~g = f~g  
\\
~~p0 = (0,0)
\\
~~q0 = \cd{project3D}~p0
\\
~~p1 = (\cd{compose}~\cd{project2D}~\cd{inject3D})~p0
\\
\cd{in} 
\\
~~(p0, q0)
\\
\cd{end}
\end{array}
\]

The example code above defines a $\cd{point}$ as a two (consisting of
$x$ and $y$ axes) or three dimensional (consisting of $x$, $y$, and
$z$ axes) point in space.
%
The function $\cd{inject3D}$ takes a 2D point and transforms it to a 3D
point by mapping it to a point on the $z=0$ plane. 
%
The function $\cd{project2D}$ takes a 3D point and transforms it to a 2D
point by dropping its $z$ coordinate.
%
The function $\cd{compose}$ takes two functions $f$ and $g$ and composes
them.
%
The function $\cd{compose}$ is a higher-order function, since id operates
on functions.

The point $p0$ is the origin in 2D.  The point $q0$ is then computed
as the origin in 3D.  The point $p1$ is computed by injecting $p0$ to
3D and then projecting it back to 2D by dropping the $z$ components,
which yields again $p0$.  
%
In the end we thus have $p0 = p1 = (0,0)$.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR27}
\no{27}
\unique{15210:S18:CH3:SEC2:UN2:GR27}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR27:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR27:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The following \pml code, which defines a binary tree whose leaves and
internal nodes holds keys of integer type.
%
The function $\cd{find}$ performs a lookup in a given binary-search tree
$t$, by recursively comparing the key $x$ to the keys along a path in
the tree.

\[
\begin{array}{l}
\cd{type}~\cd{tree} = \cd{Leaf}~\cd{of}~\tyint~|~\cd{Node}~\cd{of} (\cd{tree}, \tyint, \cd{tree})
\\
\cd{find} (t, x) = 
\\
~~\cd{case}~x
\\ 
~~|~\cd{Leaf}~y \dra x = y 
\\
~~|~\cd{Node}~(\cd{left}, y, \cd{right}) \dra
\\
~~~~~~\cd{if}~x = y~\cd{then} 
\\
~~~~~~~~\cd{return}~\cd{true}
\\
~~~~~~\cd{else}~\cd{if}~x < y~\cd{then} 
\\
~~~~~~~~\cd{find}~(\cd{left}, x)
\\
~~~~~~\cd{else}
\\
~~~~~~~~\cd{find}~(\cd{right}, x)
\end{array}
\]
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN2:GR28}
\no{28}
\unique{15210:S18:CH3:SEC2:UN2:GR28}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{remark}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN2:GR28:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN2:GR28:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

~\\
%\begin{minipage}[t]{3.5in}
The definition
\[
\cfn{x}{(\cfn{y}{f(x,y)})}
\]
  takes a function $f$ of a pair of arguments and converts it
  into a function that takes one of the arguments and returns a
  function which takes the second argument.  This technique can be
  generalized to functions with multiple arguments and is often
  referred to as~\defn{currying}, named after Haskell Curry
  (1900-1982), who developed the idea.  It has nothing to do with the
  popular dish from Southern Asia, although that might be an easy way
  to remember the term.
%\end{minipage}
%% %
%% \begin{notesonly}
%% \begin{minipage}[t]{2.2in}
%% \vspace*{0in}
%% \includegraphics[width=2.2in]{introduction/curry}
%% \end{minipage}
%% \end{notesonly}
\end{remark}
\end{group}
\end{unit}

\begin{unit}[Derived Syntax for Loops]
\label{unit:15210:S18:CH3:SEC2:UN3}
\no{3}
\unique{15210:S18:CH3:SEC2:UN3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN3:GR1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN3:GR1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN3:GR1:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN3:GR1:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

\pml{} does not have explicit syntax for loops but loops can be
implemented with recursion.
%
We use the syntactic sugar, which is defined below, for expressing
while loops.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN3:GR2}
\no{2}
\unique{15210:S18:CH3:SEC2:UN3:GR2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{syntax}[While loops]
\label{atom:15210:S18:CH3:SEC2:UN3:GR2:AT1:syn:language::while}
\no{1}
\unique{15210:S18:CH3:SEC2:UN3:GR2:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The~\defn{while loop} can appear as one of the bindings $b$ in a
\cd{let} expression and has the syntax the following syntax.
%
\[
\begin{array}{ll}
xs = 
& \cd{start}~p~\cd{and}
\\
& \cd{while}~e_{continue}~\cd{do}
\\
&~~~~b^+
\end{array}
\]
%
Here $xs$ are the result variables holding the values computed by the
while loop, the pattern $p$ is the initial value for $xs$.
%
Such a $\cd{while}$ loop evaluates by setting $xs$ to pattern $p$ and
then evaluating the loop until $e_{continue}$ evaluates to $\cfalse$.
%
In a typical use the body of the loop $b^+$ defines the variables
$xs$, whose final value will be the value of $xs$ when the loop terminates.

We define the while loop syntax above  to be equivalent to the
following pair of bindings.

\[
\begin{array}{l}
f~xs = \cd{if not}~e_{continue}~\cd{then}~xs
\\
~~~~~~~~~~~~~\cd{else let}~b^+~\cd{in}~f~xs~\cd{end}
\\
\cd{xs} =  f~p
\end{array}
\]

%% \[
%% \begin{align}
%% f~xs  = & \cd{if not}~e_{continue}~\cd{then}~xs
%% \\
%%   & \cd{else let}~b^+~\cd{in}~f~xs~\cd{end}
%% \\
%% \cd{xs} & = & f~p
%% \end{align}
%% \]

Here $xs$, $p$, $e_{continue}$ and $b^+$ are substituted
verbatim.  
%
The loop is expressed as a function that takes $xs$ as an argument and
runs the body of the loop until the expression $e_{continue}$ becomes
false at which time the variables $xs$ is returned.
%
The variables $xs$ are passed from one iteration of the while to the next
each of which might redefine them in the bindings.  
%
After the loop terminates, the variables take on the value they had at
the end of the last iteration.

When evaluated a while loop starts by matching the variables $xs$ to
the pattern $p$ and then continues to evaluate the while loop in the
usual fashion.
%
It first checks the value of $e_{continue}$, if it is false, then the
evaluation completes.  
%
If not, then the  bindings in $b^{+}$, which can use the variables
$xs$, are evaluated.
%
Having finished the body, evaluation jumps to the beginning of the
$\cd{while}$ and evaluates the termination condition $e_{continue}$, and
continues on executing the loop body and so on.
\end{syntax}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC2:UN3:GR3}
\no{3}
\unique{15210:S18:CH3:SEC2:UN3:GR3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC2:UN3:GR3:AT1}
\no{1}
\unique{15210:S18:CH3:SEC2:UN3:GR3:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

The following code sums the squares of the integers from 1 to $n$.
%
\[
\begin{array}{l}
\cd{sumSquares}~(n) = 
\\
~~~~\cd{let}~(s,n) = \cd{start}~(0,n)~\cd{and} \\ 
~~~~~~~~~~~~~~~~~~~~~~~~~~\cd{while}~n > 0~\cd{do} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~s = s~\cd{+}~n~\cd{*}~n \\
~~~~~~~~~~~~~n = n~\cd{-}~\cd{1}\\
~~~~\cd{in}~s~\cd{end}
\end{array}
\]
%
By definition it is equivalent
to the following code.
\[
\begin{array}{l}
\cd{sumSquares}~(n) =\\ 
~~~~\cd{let}~f(s,n) = \\ 
~~~~~~~~~~~~~~~\cd{if}~\cd{not} (n > 0) ~\cd{then}\\
~~~~~~~~~~~~~~~~~~~(n,s) \\
~~~~~~~~~~~~~~~\cd{else}\\
~~~~~~~~~~~~~~~~~~~\cd{let} \\
~~~~~~~~~~~~~~~~~~~~~~~~s = s ~\cd{+} n ~\cd{*} n \\
~~~~~~~~~~~~~~~~~~~~~~~~n = n ~\cd{-} 1 \\
~~~~~~~~~~~~~~~~~~~\cd{in}~f(s,n)~\cd{end}\\
~~~~~~~~~~~~~(s,n) = f(0,n)\\
~~~~\cd{in}~s~\cd{end}
\end{array}
\]
\end{example}
\end{group}
\end{unit}
\end{section}

\begin{section}[Functional Algorithms]
\label{section:15210:S18:CH3:SEC3}
\no{3}
\unique{15210:S18:CH3:SEC3}
\parent{...NOT.PROVIDED.PARENTS...}

...NOT.PROVIDED.INTRO...

\begin{unit}[Effects and Purity]
\label{unit:15210:S18:CH3:SEC3:UN4}
\no{4}
\unique{15210:S18:CH3:SEC3:UN4}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR1:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR1:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Many parallel algorithms are~\defn{purely functional}.  To understand
what this means, let's review first what it means for an algorithm to
be pure and functional.
%
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR2}
\no{2}
\unique{15210:S18:CH3:SEC3:UN4:GR2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Side Effects]
\label{atom:15210:S18:CH3:SEC3:UN4:GR2:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR2:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

We say that a computation has a~\defn{side effect}, if in addition to
returning a value, it also performs an effect such as writing to an
existing memory location, printing on the screen, or writing to a
file.
%
\end{definition}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR2:AT2}
\no{2}
\unique{15210:S18:CH3:SEC3:UN4:GR2:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number, and also updates
the argument $n$ by overwriting it with the return value.
%
This function has the side effect of changing the value of its
argument.
%
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR3}
\no{3}
\unique{15210:S18:CH3:SEC3:UN4:GR3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Pure computation]
\label{atom:15210:S18:CH3:SEC3:UN4:GR3:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR3:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

We say that  a computation is ~\defn{pure} if it doesn't perform any side
  effects.
%
Pure computations return a value without performing any side effects.
%
In contrast an~\defn{impure} or~\defn{imperative} computation can
perform side effects.  The Fibonacci function described above is
impure.
%
\end{definition}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR3:AT2}
\no{2}
\unique{15210:S18:CH3:SEC3:UN4:GR3:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number by recursively
computing the $(n-1)^{st}$ and $(n-2)^{nd}$ Fibonacci numbers and
summing them up.
%
This function is pure because it has no side effects.
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR4}
\no{4}
\unique{15210:S18:CH3:SEC3:UN4:GR4}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR4:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR4:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Pure computations correspond closely with mathematical systems or
notation, where for example, determining the result of a calculation
of formula does not affect the result of another.
%
The notion of purity can be further extended to allow for effects
that are not~\defn{observable}.  
%
For example, the Fibonacci function
described above may be implemented by using a mutable reference that
holds some intermediate value that may be used to compute
the result.
%
If this reference is not observable (e.g., not visible to the caller
of the function), the function has no observable
effect, and can thus be considered pure.  Such effects are sometimes
called~\defn{benign effects}.
%
This more general notion of purity is important because it allows for
example using side effects in a ``responsible'' fashion to improve
efficiency.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR5}
\no{5}
\unique{15210:S18:CH3:SEC3:UN4:GR5}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{important}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR5:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR5:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Strictly speakig there is probably no non-trivial computation that is
pure because almost any computation performs memory effects at the
hardware level.  Encapsulation of effects by observation is therefore
essential for meaningful discussions of purity.
\end{important}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR6}
\no{6}
\unique{15210:S18:CH3:SEC3:UN4:GR6}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Functional Programming]
\label{atom:15210:S18:CH3:SEC3:UN4:GR6:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR6:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

A programming language is called~\defn{functional}, if it does not
restrict the use of functions any more than the use of other values
such as natural numbers.
%
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR7}
\no{7}
\unique{15210:S18:CH3:SEC3:UN4:GR7}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR7:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR7:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

This principle is sometimes referred to as ``functions as first-class
values'' or ``functions as first-class citizens''.  
%
Functional programming languages do not distinguish between a function
and other values: both can be used as building blocks of values,
stored in memory, and passed as arguments to functions, etc.
%
For example, a function that returns the number~\cd{1} under some
argument and the natural number \cd{1} are the same for the purposes
of computation.
%
Treating functions as values leads to a powerful way to code.  
%
For example, we can write~\defn{higher-order functions} that take
functions as their arguments.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR8}
\no{8}
\unique{15210:S18:CH3:SEC3:UN4:GR8}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Purely Functional Algorithm]
\label{atom:15210:S18:CH3:SEC3:UN4:GR8:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR8:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

A~\defn{purely functional algorithm} is an algorithm that is both pure
and functional, i.e., it is described in a functional language and it
avoids use of observable side effects such as imperative updates to
memory locations that can be observed and can thus have an effect on
other computations.
%
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR9}
\no{9}
\unique{15210:S18:CH3:SEC3:UN4:GR9}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{teachask}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR9:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR9:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

What are the advantages of purely functional algorithms and
programming?
\end{teachask}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR10}
\no{10}
\unique{15210:S18:CH3:SEC3:UN4:GR10}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR10:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR10:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Purely functional algorithms are particularly useful for parallelism
for  two important reasons.

\begin{itemize}

\item Purely functional algorithms are safe for parallelism.
%
Different parts of the algorithm may be executed in parallel without
affecting each other.
%
In contrast, in imperative programming, the programmer must take care
that side effects don't alter the meaning of the program in
unintended ways.
%
The problem is that preventing side effects from altering the meaning
of the program is very difficult, because 1) depending on the exact
execution order (timing) of components, side effects may cause a
computation to return different results at different times, and 2)
there are exponentially many different orderings.
%


\item
Second, higher-order functions (even in a language that is not pure)
help with the design and implementation of parallel algorithm by
encouraging the designer to think at a higher level of abstraction.
%
For example, instead of thinking about a loop that iterates over the
elements of an array to generate the sum, which is completely
sequential, we can define a higher-order ``reduce'' function. 
%
In addition to taking the array as an argument, the reduce function
takes a binary associative function as another argument.  It then sums
the array based on that binary associative function.
%
The advantage is that the higher-order reduce allows for any
binary associative function (e.g. maximum, minimum, multiplication).
%
By implementing the reduce function as a tree sum, which is highly
parallel, we can thus perform a variety of computations in parallel
rather than sequentially as a loop.
%
In general, thinking in higher order functions encourages working at a
higher level of abstraction, moving us away from the one-at-a-time
(loop) way of thinking that is detrimental to code quality and
to parallelism.
\end{itemize}
% Finally, functional programs don't have traditional loops.  We hope 
% that the lack of such loops discourages the use of sequential code,
% when parallel code is preferable.  For example we will use the 
% following notation 
% \[\cseq{f(x) : x \in S}\]
% to mean apply the function $f$ to each $x$ in the sequence $S$ and return 
% a new sequence.   This is purely functional (assuming $f$ has no side effects) 
% and is also parallel since all the applications of $f$ to each $x$ can 
% happen in parallel.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN4:GR11}
\no{11}
\unique{15210:S18:CH3:SEC3:UN4:GR11}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{remark}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN4:GR11:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN4:GR11:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Coding a purely functional algorithm does not require a purely
functional programming language.
%
In fact, a purely functional algorithm can be coded in essentially any
programming language---one just needs to be much more careful when
coding imperatively in order to avoid errors caused by sharing of
state and side effects.  
%
Some imperative parallel languages such as extension to the C
language, in fact, encourage programming purely functional algorithms.
%
The techniques that we describe thus are applicable to  imperative
programming languages as  well.
\end{remark}
\end{group}
\end{unit}

\begin{unit}[Race Conditions]
\label{unit:15210:S18:CH3:SEC3:UN5}
\no{5}
\unique{15210:S18:CH3:SEC3:UN5}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR1}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{definition}[Race conditions]
\label{atom:15210:S18:CH3:SEC3:UN5:GR1:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR1:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Side effects that alter the result of the computation based on the
evaluation order (timing) are called~\defn{race conditions}.
%
\end{definition}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR2}
\no{2}
\unique{15210:S18:CH3:SEC3:UN5:GR2}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR2:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR2:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Functional algorithms avoid race condition because they do not 
permit observable side effects.  For example, in \pml{}, the language
that we use to describe algorithms in this course, there is no syntax
for memory effects.  
%
To discuss side effects and give example, we will extend \pml{} with a
simple~\defn{assignment} operation, which overwrites the value of a
variable.
%
The syntax 
\[
x \la e
\]
means that $e$ is evaluated to a value $v$, $v$ is written into the
variable $x$, and a unit $()$ is returned. 
%
Note that this is different than 
\[
x = e,
\]
because the latter defines a (new) variable $x$ whose value is that of
$e$.  The variable may shadow an existing variable with the same name
but cannot change its value.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR3}
\no{3}
\unique{15210:S18:CH3:SEC3:UN5:GR3}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR3:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR3:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Consider the following piece of code where the function $\cd{select}$
calls two functions $\cd{left}$ and $\cd{right}$ in parallel.
%
The return value of $\cd{select}$ depends on the order in which
$\cd{left}$ and $\cd{right}$ execute because $\cd{select}$ passes to
both functions the same reference to write to, whose contents it
returns.

\[
\begin{array}{l}
\cd{left}~x = x \la \cstr{left}
\\ 
\cd{right}~y = y \la \cstr{right}
\\
\cd{select}~() = 
\\
~~\cd{let}

\\
~~~~z \la \cstr{center}
\\
~~~~(\cd{left}~z)~||~(\cd{right}~z)
\\
~~\cd{in}
\\
~~~~!z
\\
~~\cd{end}
\end{array}
\]
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR4}
\no{4}
\unique{15210:S18:CH3:SEC3:UN5:GR4}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{exercise}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR4:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR4:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Consider two tiny functions given below that read and write from the
same references.
%
The programmer convinced themselves that the function $\cd{select}$
would return $(\cd{left}, \cd{right}).$

Is the programmer correct? Prove or disprove? 
 
\[
\begin{array}{l}
\cd{left}~(x,y) =\\
~~y \la \cstr{left}
\\ 
~~x \la \cstr{left}
\\
~~\\
\cd{right}~(x,y) =\\
~~x \la \cstr{right}
\\ 
~~y \la \cstr{right}
\\
~~\\
\cd{select}~() = 
\\
~~\cd{let}
\\
~~~~x \la \cstr{center}
\\
~~~~y \la \cstr{center}
\\
~~~~((),()) = (\cd{left}(x,y))~||~(\cd{right}(x,y))
\\
~~\cd{in}
\\
~~~~(!x, !y)
\\
~~\cd{end}
\end{array}
\]
\end{exercise}

\begin{solution}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR4:AT2}
\no{2}
\unique{15210:S18:CH3:SEC3:UN5:GR4:AT2}
\parent{...NOT.PROVIDED.PARENTS...}

The programmer might have reasoned like this: the two functions
$\cd{left}$ and $\cd{right}$ finish by writing to two different
references $x$ and $y$ respectively.  Since they write respectively
the values $\cstr{left}$ and $\cstr{right}$, the returned value will
be $(\cstr{left}, \cstr{right})$.

This is wrong because it consider only one possible execution order.  
%
There are many others.  For example, the function $\cd{left}$ might
execute to completion and then $\cd{right}$.  In this case, the
returned value will be $(\cstr{right}, \cstr{right})$.
%
The converse is also possible resulting in the return value 
$(\cstr{left}, \cstr{left})$.
\end{solution}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR5}
\no{5}
\unique{15210:S18:CH3:SEC3:UN5:GR5}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{gram}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR5:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR5:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Verifying the correctness of an effectful algorithm can require
checking a very large number, e.g., billions or more, of different
execution possibilities.
%
It is nearly impossible for any human being to comprehend such numbers
of different possibilities.
%
There are indeed many examples of parallelism or concurrency bugs in
real systems that lead to sometimes catastrophic outcomes.
\end{gram}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR6}
\no{6}
\unique{15210:S18:CH3:SEC3:UN5:GR6}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{example}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR6:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR6:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

There are several spectacular examples of correctness problems caused
by race-conditions, including for example the Northeast blackout of
2003, which affected over 50 Million people in North America.

Here are some quotes from the spokesmen of the companies involved in
this event.
%

The first quote below describes the problem, which is a race
condition (multiple computations writing to the same piece of data).
%
"There was a couple of processes that were in contention for a common
data structure, and through a software coding error in one of the
application processes, they were both able to get write access to a
data structure at the same time [...] And that corruption led to the
alarm event application getting into an infinite loop and spinning."
%

The second  quote describes the difficulty of finding the bug.
%
"This fault was so deeply embedded, it took them [the team of
  engineers] weeks of poring through millions of lines of code and
data to find it."
\end{example}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR7}
\no{7}
\unique{15210:S18:CH3:SEC3:UN5:GR7}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{remark}[Heisenbug]
\label{atom:15210:S18:CH3:SEC3:UN5:GR7:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR7:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

Race conditions make it difficult to reason about the correctness and
the efficiency of parallel algorithms.  They also make debugging
difficult, because each time the code is run, it might give a
different answer.
%
For example, each time we evaluate a piece of code, we may obtain a
different answer or we may obtain a correct answer 99.99\% of the time
but not always.
%

The term~\defn{Heisenbug} was coined in the early 80s to refer to a
type of bug that ``disappears'' when you try to pinpoint or study it
and ``appears'' when you stop studying it.  They are named after the
famous Heisenberg uncertainty principle which roughly says that if you
localize one property, you will lose information about another
complementary property.  Often the most difficult Heisenbugs to find
have to do with race conditions in parallel or concurrent code.  These
are sometimes also called concurrency bugs.
\end{remark}
\end{group}

\begin{group}[...NOT.PROVIDED.TITLE...]
\label{group:15210:S18:CH3:SEC3:UN5:GR8}
\no{8}
\unique{15210:S18:CH3:SEC3:UN5:GR8}
\parent{...NOT.PROVIDED.PARENTS...}

\begin{exercise}[...NOT.PROVIDED.TITLE...]
\label{atom:15210:S18:CH3:SEC3:UN5:GR8:AT1}
\no{1}
\unique{15210:S18:CH3:SEC3:UN5:GR8:AT1}
\parent{...NOT.PROVIDED.PARENTS...}

What are all the different outcomes of the example given above?
\end{exercise}
\end{group}
\end{unit}
\end{section}
\end{chapter}

\end{book}
