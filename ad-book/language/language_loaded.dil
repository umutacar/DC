%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilCourse}
\begin{dilFieldTitle}
Parallel and Sequential Algorithms
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parallel and Sequential Algorithms
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210
\end{dilFieldUnique}
\begin{dilLabel}
15210
\end{dilLabel}
\begin{dilNo}
15210
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldCourseNumber}
15210

\end{dilFieldCourseNumber}
\begin{dilFieldPicture}
/210/course/air-pavilion.jpg
\end{dilFieldPicture}
\begin{dilFieldSemester}
Spring 2018

\end{dilFieldSemester}
\begin{dilFieldWebsite}
http://www.cs.cmu.edu/~15210

\end{dilFieldWebsite}
\begin{dilFieldProvidesBook}
S18

\end{dilFieldProvidesBook}
\begin{dilFieldProvidesChapter}
3

\end{dilFieldProvidesChapter}
\begin{dilFieldProvidesSection}
1

\end{dilFieldProvidesSection}
\begin{dilFieldProvidesUnit}
1

\end{dilFieldProvidesUnit}
\begin{dilFieldProvidesAssignment}
1

\end{dilFieldProvidesAssignment}
\begin{dilIntro}
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>

\end{dilIntro}
\begin{dilIntroDex}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.

\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilBook}
\begin{dilFieldTitle}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18
\end{dilFieldUnique}
\begin{dilLabel}
book:15210:S18
\end{dilLabel}
\begin{dilNo}
0
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldAuthors}
Umut A. Acar and Guy Blelloch

\end{dilFieldAuthors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilChapter}
\begin{dilFieldTitle}
SPARC: A Strict Language for Parallel Computing
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
SPARC: A Strict Language for Parallel Computing
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3
\end{dilFieldUnique}
\begin{dilLabel}
chapter:15210:S18:CH3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldPicture}
/210/language/dora-maar-seated.jpg
\end{dilFieldPicture}
\begin{dilIntro}
<p>This chapter presents SPARC: a parallel functional language used throughout the book for specifying algorithms.</p>
<p>SPARC is a strict functional language similar to the ML class of languages such as Standard ML or SML, Caml, and F#. In pseudo code, we sometimes use mathematical notation, and even English descriptions in addition to SPARC syntax. This chapter describes the basic syntax and semantics of SPARC; we introduce additional syntax as needed in the rest of the book.</p>

\end{dilIntro}
\begin{dilIntroDex}
This chapter presents \pml{}: a parallel functional language used
throughout the book for specifying algorithms.


%
\pml is a strict functional language similar to the ML class of
languages such as Standard ML or SML, Caml, and F\#.
%
In pseudo code, we sometimes use mathematical notation, and even
English descriptions in addition to \pml{} syntax.
%
This chapter describes the basic syntax and semantics of \pml{}; we
introduce additional syntax as needed in the rest of the book.

\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Introduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Introduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH3:SEC1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>This section briefly describes lambda calculus.</p>

\end{dilIntro}
\begin{dilIntroDex}
This section briefly describes lambda calculus.

\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Lambda Calculus
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Lambda Calculus
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH3:SEC1:UN1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As with most functional programming languages, the ML class of languages are based on the  <span style="color: black"><span><strong><em>lambda calculus</em></strong></span></span> (or <span class="math inline">\(\lambda\)</span> calculus), a computational model developed by Alonzo Church in 1932. The syntax of lambda calculus is very simple and the evaluation of lambda calculus expressions requires effectively a single rule called  <span style="color: black"><span><strong><em>beta reduction</em></strong></span></span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As with most functional programming languages, the ML class of
languages are based on the~\defn{lambda calculus} (or $\lambda$
calculus), a computational model developed by Alonzo Church in 1932.
%
The syntax of lambda calculus is very simple and the evaluation of
lambda calculus expressions requires effectively a single rule
called~\defn{beta reduction}.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Syntax of Lambda Calculus
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Syntax of Lambda Calculus
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The lambda calculus is a very simple language consisting of expressions <span class="math inline">\(e\)</span> which can only be one of the following three forms:</p>
<ul>
<li><p>a variable name, written as <span class="math inline">\(x\)</span>,</p></li>
<li><p>a function definition, written as <span class="math inline">\((\lambda~x~.~e)\)</span>, where <span class="math inline">\(e\)</span> is an expression denoting the body of the function, or</p></li>
<li><p>a function application, written as <span class="math inline">\(e_1~e_2\)</span>, where <span class="math inline">\(e_1\)</span> and <span class="math inline">\(e_2\)</span> are expressions.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The lambda calculus is a very simple language consisting of
expressions $e$ which can only be one of the following three forms:

\begin{itemize}
\item a variable name, written as $x$,

\item a function definition, written as $(\lambda~x~.~e)$, where $e$ is
  an expression denoting the body of the function, or

\item a function application, written as $e_1~e_2$, where $e_1$ and
  $e_2$ are expressions.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Beta Reduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Beta Reduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>For any function application for which the left hand expression is a function definition, beta reduction “applies the function” by making the transformation: <span class="math display">\[(\lambda~x~.~e_1)~e_2 \longrightarrow e_1[x/e_2]\]</span> where <span class="math inline">\(e_1[x/e_2]\)</span> roughly means for every (free) occurrence of <span class="math inline">\(x\)</span> in <span class="math inline">\(e_1\)</span>, substitute it with <span class="math inline">\(e_2\)</span>. Computation in the lambda calculus consists of applying beta reduction until there is nothing left to reduce.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
For any function
application for which the left hand expression is a function
definition, beta reduction ``applies the function'' by making the
transformation:
\[ (\lambda~x~.~e_1)~e_2 \longrightarrow e_1[x/e_2] \]
where $e_1[x/e_2]$ roughly means for every (free) occurrence of $x$ in
$e_1$, substitute it with $e_2$.  Computation in the \lc{} consists of
applying beta reduction until there is nothing left to reduce.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In the early 30s Church argued that anything that can be “effectively computed” can be computed with the lambda calculus, and therefore that it is a universal mechanism for computation. However, it was not until a few years later when Alan Turing developed the Turing machine and showed its equivalence to the lambda calculus that the concept of universality became widely accepted. The fact that the models were so different, but equivalent in what they can compute, was a powerful argument for the universality of the models. We now refer to the hypothesis that anything that can be computed can be computed with the lambda calculus, or equivalently the Turing machine, as the  <span style="color: black"><span><strong><em>Church-Turing hypothesis</em></strong></span></span>, and refer to any computational model that is computationally equivalent to the lambda calculus as  <span style="color: black"><span><strong><em>Church-Turing complete</em></strong></span></span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In the early 30s Church argued that anything that can be ``effectively
computed'' can be computed with the lambda calculus, and therefore
that it is a universal mechanism for computation.  
%
However, it was not until a few years later when Alan Turing developed
the Turing machine and showed its equivalence to the lambda calculus
that the concept of universality became widely accepted.  The fact
that the models were so different, but equivalent in what they can
compute, was a powerful argument for the universality of the models.
We now refer to the hypothesis that anything that can be computed can
be computed with the lambda calculus, or equivalently the Turing
machine, as the~\defn{Church-Turing hypothesis}, and refer to any
computational model that is computationally equivalent to the lambda
calculus as~\defn{Church-Turing complete}.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Although the lambda calculus allows beta reduction to be applied in any order, most functional programming languages use a specific order. The two most prominent orders are called “call-by-value” or “call-be-need.”</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Although the lambda calculus allows beta reduction to be applied in
any order, most functional programming languages use a specific order.
%
The two most prominent orders are called ``call-by-value'' or
``call-be-need.''

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Call-by-Value
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Call-by-Value
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In  <span style="color: black"><span><strong><em>call-by-value</em></strong></span></span> evaluation order, a function application <span class="math inline">\((\lambda~x~.~e_1)~e_2\)</span> can be evaluated only if the expression <span class="math inline">\(e_2\)</span> is a value first, i.e., <span class="math inline">\(e_2\)</span> is evaluated to a value first and then beta reduction is applied to evaluate the application.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In~\defn{call-by-value} evaluation order, a function application
$(\lambda~x~.~e_1)~e_2$ can be evaluated only if the expression $e_2$
is a value first, i.e., $e_2$ is evaluated to a value first and then
beta reduction is applied to evaluate the application.  
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR6:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR6:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The ML class of languages such as Standard ML, CAML, and OCAML, all use call-by-value evaluation order.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The ML class of languages such as Standard ML, CAML, and OCAML, all
use call-by-value evaluation order.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Call-by-Need
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Call-by-Need
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In  <span style="color: black"><span><strong><em>call-by-need</em></strong></span></span> evaluation order, beta reduction can proceed for any expression <span class="math inline">\(e_2\)</span>. If during beta reduction <span class="math inline">\(e_2\)</span> is copied into each variable <span class="math inline">\(x\)</span> in the body, this reduction order is called  <span style="color: black"><span><strong><em>call-by-name</em></strong></span></span>, and if <span class="math inline">\(e_2\)</span> is shared, it is called call-by-need.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In~\defn{call-by-need} evaluation order, beta reduction can proceed
for any expression $e_2$.
% 
If during beta reduction $e_2$ is copied into each variable $x$ in the
body, this reduction order is called~\defn{call-by-name}, and if $e_2$
is shared, it is called call-by-need.  
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR7:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR7:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The Haskell language is perhaps the most well known example of a call-by-need (or lazy) functional language.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The Haskell language is perhaps the most well known example of a
call-by-need (or lazy) functional language.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC1:UN1:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomImportant}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC1:UN1:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC1:UN1:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>All the reduction orders, call-by-value, call-by-name, and call-by-value are Church-Turing complete. But there are differences in terms of cost. Call-by-name is inefficient, because it can create redundant computations. Call-by need can be efficient but is inherently sequential. Call-by-need can also complicate cost analysis because it is difficult to know if andt when an expression is evaluated. We therefore only use call-by-value.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
All the reduction orders, call-by-value, call-by-name, and
call-by-value are Church-Turing complete.
%
But there are differences in terms of cost.
%
Call-by-name is inefficient, because it can create redundant
computations.
%
Call-by need can be efficient but is inherently sequential.
%
%% TODO: Why? 
%
Call-by-need can also complicate cost analysis because it is difficult
to know if andt when an expression is evaluated. 
%
We therefore only use call-by-value.

\end{dilFieldBodyDex}
\end{dilAtomImportant}
\end{dilGroup}
\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
The SPARC Language
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The SPARC Language
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH3:SEC2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>This section describes the syntax and the semantics of the core subset of the SPARC language. while  <span style="color: black"><span><strong><em>semantics</em></strong></span></span> refers to what the program computes. Since we wish to analyze the cost of algorithms, we are interested in not just what algorithms compute, but how they compute. Semantics that capture how algorithms compute are called  <span style="color: black"><span><strong><em>operational semantics</em></strong></span></span>, and when augmented with specific costs,  <span style="color: black"><span><strong><em>cost semantics</em></strong></span></span>. Here we describe the syntax of SPARC and present an informal description of its operational semantics. While we focus primarily on the core subset of SPARC, we also describe some  <span style="color: black"><span><strong><em>syntactic sugar</em></strong></span></span> that makes it easier to read or write code without adding any real power. Even though SPARC is a strongly typed language, for our purposes in this book, we use types primarily as a means of describing and specifying the behavior of our algorithms. We therefore do not present careful account of SPARC’s type system.</p>

\end{dilIntro}
\begin{dilIntroDex}
This section describes the syntax and the semantics of the core subset of the
\pml{} language. 
%~\defn[syntax]{Syntax} refers to the structure of the program itself,
while~\defn{semantics} refers to what the program computes.  
%
Since we wish to analyze the cost of algorithms, we are interested in
not just what algorithms compute, but how they compute.
%
Semantics that capture how algorithms compute are
called~\defn{operational semantics}, and when augmented with specific
costs,~\defn{cost semantics}.
%
Here we describe the syntax of \pml{} and present an informal
description of its operational semantics. 
%
%We will talk about cost semantics in \chref{analysis}.
%
While we focus primarily on the core subset of \pml, we also describe
some~\defn{syntactic sugar} that makes it easier to read or write code
without adding any real power.
%
Even though \pml is a strongly typed language, for our purposes in
this book, we use types primarily as a means of describing and
specifying the behavior of our algorithms.
%
We therefore do not present careful account of \pml's type system.

\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Syntax and Semantics of SPARC
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Syntax and Semantics of SPARC
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH3:SEC2:UN2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The definition below shows the syntax of SPARC. A SPARC program is an expression, whose syntax, describe the computations that can be expressed in SPARC. When evaluated an expression yield a value. Informally speaking, evaluation of an expression proceeds involves evaluating its sub-expressions to values and then combining these values to compute the value of the expression. SPARC is a strongly typed language, where every closed expression, which have no undefined (free) variables, evaluates to a value or runs forever.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The definition below shows the syntax of \pml{}.
%
A \pml{} program is an expression, whose syntax,
 describe the computations that can be expressed in \pml{}.
%
When evaluated an expression yield a value.
%
Informally speaking, evaluation of an expression proceeds involves
evaluating its sub-expressions to values and then combining these
values  to compute the value of the expression.
%
\pml{} is a strongly typed language, where every closed expression,
which have no undefined (free) variables, evaluates to a value or runs
forever.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
SPARC expressions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
\pml{} expressions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR2:AT1:def:language::syntax
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Identifier</td>
<td style="text-align: left;"><span class="math inline">\(id\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Variables</td>
<td style="text-align: left;"><span class="math inline">\(x\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(id\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Type Constructors</td>
<td style="text-align: left;"><span class="math inline">\(tycon\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(id\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Constructors</td>
<td style="text-align: left;"><span class="math inline">\(dcon\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(id\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Patterns</td>
<td style="text-align: left;"><span class="math inline">\(p\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;">x</td>
<td style="text-align: left;">variable</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>(</code> <span class="math inline">\(p\)</span> <code>)</code></td>
<td style="text-align: left;">parenthesization</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p_1\)</span> <code>,</code> <span class="math inline">\(p_2\)</span></td>
<td style="text-align: left;">pair</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(dcon\)</span> <code>(</code><span class="math inline">\(p\)</span><code>)</code></td>
<td style="text-align: left;">data pattern</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Types</td>
<td style="text-align: left;"><span class="math inline">\(\tau\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{Z}\)</span></td>
<td style="text-align: left;">integers</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\mathbb{B}\)</span></td>
<td style="text-align: left;">booleans</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\tau\)</span> <span class="math inline">\([\)</span> <code>*</code> <span class="math inline">\(\tau\)</span> <span class="math inline">\(]^+\)</span></td>
<td style="text-align: left;">products</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\tau \rightarrow\tau\)</span></td>
<td style="text-align: left;">functions</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(tycon\)</span></td>
<td style="text-align: left;">type constructors</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(dty\)</span></td>
<td style="text-align: left;">data types</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Data Types</td>
<td style="text-align: left;"><span class="math inline">\(dty\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(dcon\)</span><span class="math inline">\([\)</span><code>of</code> <span class="math inline">\(\tau\)</span> <span class="math inline">\(]\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(dcon\)</span><span class="math inline">\([\)</span> <code>of</code> <span class="math inline">\(\tau\)</span> <span class="math inline">\(]\)</span><code>|</code><span class="math inline">\(dty\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Values</td>
<td style="text-align: left;"><span class="math inline">\(v\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><code>0</code> <span class="math inline">\(\mid\)</span> <code>1</code> <span class="math inline">\(\mid\)</span> <span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;">integers</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>-1</code> <span class="math inline">\(\mid\)</span> <code>-2</code> <span class="math inline">\(\mid\)</span> <span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;">integers</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>true</code><span class="math inline">\(\mid\)</span> <code>false</code></td>
<td style="text-align: left;">booleans</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>not</code> <span class="math inline">\(\mid\)</span> <span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;">unary operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>and</code><span class="math inline">\(\mid\)</span> <code>plus</code> <span class="math inline">\(\mid\)</span> <span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;">binary operations</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(v_1, v_2\)</span></td>
<td style="text-align: left;">pairs</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>(</code> <span class="math inline">\(v\)</span> <code>)</code></td>
<td style="text-align: left;">parenthesis</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(dcon\)</span><code>(</code><span class="math inline">\(v\)</span><code>)</code></td>
<td style="text-align: left;">constructed data</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>lambda</code> <span class="math inline">\(p\)</span> . <span class="math inline">\(e\)</span></td>
<td style="text-align: left;">lambda functions</td>
</tr>
<tr class="even">
<td style="text-align: left;">Expression</td>
<td style="text-align: left;"><span class="math inline">\(e\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(x\)</span></td>
<td style="text-align: left;">variables</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(v\)</span></td>
<td style="text-align: left;">values</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(e_1\)</span> op <span class="math inline">\(e_2\)</span></td>
<td style="text-align: left;">infix operations</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(e_1\)</span><code>,</code> <span class="math inline">\(e_2\)</span></td>
<td style="text-align: left;">sequential pair</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(e_1\)</span> <code>||</code> <span class="math inline">\(e_2\)</span></td>
<td style="text-align: left;">parallel pair</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>(</code> <span class="math inline">\(e\)</span> <code>)</code></td>
<td style="text-align: left;">parenthesis</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>case</code><span class="math inline">\(e_1\)</span><span class="math inline">\([\)</span><code>|</code><span class="math inline">\(p\)</span><code>=&gt;</code><span class="math inline">\(e_2\)</span><span class="math inline">\(]^+\)</span></td>
<td style="text-align: left;">case</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>if</code><span class="math inline">\(e_1\)</span><code>then</code><span class="math inline">\(e_2\)</span><code>else</code><span class="math inline">\(e_3\)</span></td>
<td style="text-align: left;">conditionals</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(e_1\)</span><span class="math inline">\(e_2\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>let</code><span class="math inline">\(b^+\)</span><code>in</code><span class="math inline">\(e\)</span><code>end</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Operations</td>
<td style="text-align: left;"><span class="math inline">\(op\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><code>+</code>, <code>-</code>, <code>*</code>, <code>-</code>, <span class="math inline">\(\ldots\)</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bindings</td>
<td style="text-align: left;"><span class="math inline">\(b\)</span></td>
<td style="text-align: center;">:=</td>
<td style="text-align: left;"><span class="math inline">\(x\)</span> <code>(</code> <span class="math inline">\(p\)</span> <code>)</code> = <span class="math inline">\(e\)</span></td>
<td style="text-align: left;">bind function</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p\)</span> <code>=</code> <span class="math inline">\(e\)</span></td>
<td style="text-align: left;">bind pattern</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>type</code><span class="math inline">\(tycon\)</span> <code>=</code> <span class="math inline">\(\tau\)</span></td>
<td style="text-align: left;">bind type</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: left;"><code>type</code><span class="math inline">\(tycon\)</span> <code>=</code> <span class="math inline">\(dty\)</span></td>
<td style="text-align: left;">bind datatype</td>
</tr>
</tbody>
</table>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\setlength{\tabcolsep}{20mm}
\begin{tabular}{llcll}
Identifier
& $id$ & := & $\ldots$
\\

%
Variables
& $x$ & := & $id$
\\

Type Constructors 
& $tycon$ & := & $id$
\\

Data Constructors 
& $dcon$ & := & $id$
\\

Patterns & $p$ 
& := & x & variable
\\
& & $\mid$  & \cd{(} $p$ \cd{)} & parenthesization
\\
& & $\mid$  & $p_1$ \cd{,} $p_2$ & pair
\\
& & $\mid$  & $dcon$ \cd{(}$p$\cd{)} & data pattern
\\

Types & $\tau$ &  := & $\tyint$  & integers
\\
& &  $\mid$ &   $\tybool$  & booleans
\\
& &  $\mid$  & $\tau$ $[$ \cd{*} $\tau$ $]^+$  & products
\\
& &  $\mid$  & $\tau \ra \tau$ & functions
\\
& & $\mid$ & $tycon$         &  type constructors
\\
& & $\mid$ & $dty$ & data types
\\

Data Types & $dty$
& := &   $dcon$$[$\cd{of} $\tau$ $]$ 
\\
&  & $\mid$ &  $dcon$$[$ \cd{of} $\tau$ $]$\cd{|}$dty$
\\

Values & $v$
& := & \cd{0}  $\mid$  \cd{1}  $\mid$  $\ldots$ &  integers
\\
& & $\mid$ &  \cd{-1}  $\mid$ \cd{-2}  $\mid$ $\ldots$ &  integers
\\
& & $\mid$ & \ctrue  $\mid$  \cfalse & booleans
\\
& & $\mid$ & \cd{not}  $\mid$  $\ldots$ & unary operations
\\
& & $\mid$ & \cand  $\mid$  \cd{plus}  $\mid$  $\ldots$ & binary operations
\\
& & $\mid$ & $v_1, v_2$  & pairs
\\
& & $\mid$ & \cd{(} $v$ \cd{)}   & parenthesis
\\
& & $\mid$ & $dcon$\cd{(}$v$\cd{)}               & constructed data
\\
& & $\mid$ & \cfn{$p$}{$e$} & lambda functions
\\

Expression  & $e$ 
& := & $x$ & variables
\\
& & $\mid$ & $v$ & values
\\
& & $\mid$ & $e_1$ op $e_2$ & infix operations
\\
& & $\mid$ & $e_1$\cd{,} $e_2$ & sequential pair
\\
& & $\mid$ & $e_1$ \cd{||} $e_2$ & parallel pair
\\
& & $\mid$ & \cd{(} $e$ \cd{)} & parenthesis
\\
& & $\mid$ & \ccase$e_1$$[$\cd{|}$p$\cdra$e_2$$]^+$  & case
\\
& & $\mid$ & \cif$e_1$\cthen$e_2$\celse$e_3$  & conditionals
\\
& & $\mid$ & $e_1$$e_2$ & \mbox{function application}
\\
& & $\mid$ & \clet$b^+$\cin$e$\cend & \mbox{local bindings}
\\

Operations & $op$ & := & \cd{+}, \cd{-}, \cd{*}, \cd{-}, $\ldots$
\\

Bindings &  $b$ & := & 
$x$ \cd{(} $p$  \cd{)} = $e$ & bind function
\\
&  & $\mid$ & $p$ \cd{=} $e$ & bind pattern
\\
&  & $\mid$ & \ctype$tycon$ \cd{=} $\tau$ & bind type 
\\
&  & $\mid$ & \ctype$tycon$ \cd{=} $dty$ & bind datatype
\\

\end{tabular}

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Identifiers
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Identifiers
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In SPARC, variables, type constructors, and data constructors are given a name, or an  <span style="color: black"><span><strong><em>identifier</em></strong></span></span>. An identifer consist of only alphabetic and numeric characters (a-z, A-Z, 0-9), the underscore character (“_”), and optionally end with some number of “primes”. Example identifiers include, <span class="math inline">\(x&#39;\)</span>, <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_l\)</span>, <span class="math inline">\(myVar\)</span>, <span class="math inline">\(myType\)</span>, <span class="math inline">\(myData\)</span>, and <span class="math inline">\(my\_data\)</span>.</p>
<p>Program  <span style="color: black"><span><strong><em>variables</em></strong></span></span>,  <span style="color: black"><span><strong><em>type constructors</em></strong></span></span>, and  <span style="color: black"><span><strong><em>data constructors</em></strong></span></span> are all instances of identifiers. During evaluation of a SPARC expression, variables are bound to values, which may then be used in a computation later. In SPARC, variable are  <span style="color: black"><span><strong><em>bound</em></strong></span></span> during function application, as part of matching the formal arguments to a function to those specified by the application, and also by <span class="math inline">\(\texttt{let}\)</span> expressions. If, however, a variable appears in an expression but it is not bound by the expression, then it is  <span style="color: black"><span><strong><em>free</em></strong></span></span> in the expression. We say that an expression is  <span style="color: black"><span><strong><em>closed</em></strong></span></span> if it has no free variables.</p>
<p>Types constructors give names to types. For example, the type of binary trees may be given the type constructor <span class="math inline">\(\texttt{btree}\)</span>. Since for the purposes of simplicity, we rely on mathematical rather than formal specifications, we usually name our types behind mathematical conventions. For example, we denote the type of natural numbers by <span class="math inline">\(\mathbb{N}\)</span>, the type of integers by <span class="math inline">\(\mathbb{Z}\)</span>, and the type of booleans by <span class="math inline">\(\mathbb{B}\)</span>.</p>
<p>Data constructors serve the purpose of making complex data structures. By convention, we will capitalize data constructors, while starting variables always with lowercase letters.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In \pml, variables, type constructors, and data constructors are given
a name, or an~\defn{identifier}.  
%
An identifer consist of only alphabetic and numeric characters (a-z,
A-Z, 0-9), the underscore character (``\_''), and optionally end with
some number of ``primes''.  
%
Example identifiers include, $x'$, $x_1$, $x_l$, $myVar$,
$myType$, $myData$, and $my\_data$.

%but \cd{myVar1}, \cd{my-type} and \cd{my\_data} are not.

Program~\defn{variables},~\defn{type constructors}, and~\defn{data
  constructors} are all instances of identifiers.
%
%% Free or bound variables
During evaluation of a \pml expression, variables are bound to values,
which may then be used in  a computation later.  
%
In \pml, variable are~\defn{bound} during function application, as part
of matching the formal arguments to a function to those specified by
the application, and also by $\cd{let}$ expressions.
%
If, however, a variable appears in an expression but it is not bound
by the expression, then it is~\defn[free variables]{free}
in the expression.
%
We say that an expression is~\defn[closed expressions]{closed} if it
has no free variables.


Types constructors give names to types.  For example, the type of
binary trees may be given the type constructor $\cd{btree}$.
%
Since for the purposes of simplicity, we rely on mathematical rather
than formal specifications, we usually name our types behind
mathematical conventions.
%
For example, we denote the type of natural numbers by $\tynat$, the type
of integers by $\tyint$, and the type of booleans by $\tybool$.


Data constructors serve the purpose of making complex data structures.
%
By convention, we will capitalize data constructors, while starting
variables always with lowercase letters.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Patterns
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Patterns
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In SPARC, variables and data constructors can be used to construct more complex  <span style="color: black"><span><strong><em>patterns</em></strong></span></span> over data. For example, a pattern can be a pair <span class="math inline">\(\texttt{(x,y)}\)</span>, or a triple of variables <span class="math inline">\(\texttt{(x,y,z)}\)</span>, or it can consist of a data constructor followed by a pattern, e.g., <span class="math inline">\(\texttt{Cons}(x)\)</span> or <span class="math inline">\(\texttt{Cons}(x,y).\)</span> Patterns thus enable a convenient and concise way to pattern match over the data structures in SPARC.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In \pml, variables and data constructors can be used to construct more
complex~\defn{patterns} over data.
%
For example, a pattern can be a pair $\cd{(x,y)}$, or a triple of
variables $\cd{(x,y,z)}$, or it can consist of a data constructor
followed by a pattern, e.g., $\cd{Cons}(x)$ or $\cd{Cons}(x,y).$
%
Patterns thus enable a convenient and concise way to pattern match
over the data structures in \pml.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Built-in Types
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Built-in Types
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Types of SPARC include base types such as integers <span class="math inline">\(\mathbb{Z}\)</span>, booleans <span class="math inline">\(\mathbb{B}\)</span>, product types such as <span class="math inline">\(\tau_1 \texttt{*} \tau_2 \ldots \tau_n\)</span>, function types <span class="math inline">\(\tau_1 \rightarrow\tau_2\)</span> with domain <span class="math inline">\(\tau_1\)</span> and range <span class="math inline">\(\tau_2\)</span>, as well as user defined data types.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Types of \pml include base types such as integers $\tyint$, booleans
$\tybool$, product types such as $\tau_1 \cd{*} \tau_2 \ldots \tau_n$,
function types $\tau_1 \ra \tau_2$ with domain $\tau_1$ and range
$\tau_2$, as well as user defined data types.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Data Types
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Data Types
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In addition to built-in types, a program can define new  <span style="color: black"><span><strong><em>data types</em></strong></span></span> as a union of tagged types, also called variants, by “unioning” them via distinct  <span style="color: black"><span><strong><em>data constructors</em></strong></span></span>. For example, the following data type defines a point as a two-dimensional or a three-dimensional coordinate of integers. <span class="math display">\[\begin{array}{lcl} 
\texttt{type}~\texttt{point} &amp; = &amp; \texttt{Point2D}~\texttt{of}~\mathbb{Z}~\texttt{*}~\mathbb{Z}
\\ 
           &amp; | &amp; \texttt{Point3D}~\texttt{of}~\mathbb{Z}~\texttt{*}~\mathbb{Z}~\texttt{*}~\mathbb{Z}
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In addition to built-in types, a program can define new~\defn{data types} as a
union of tagged types, also called variants, by ``unioning'' them via
distinct~\defn{data constructors}. 
%
For example, the following data type defines a point as a
two-dimensional or a three-dimensional coordinate of integers.
%
%
\[
\begin{array}{lcl}
\cd{type}~\cd{point} & = & \cd{Point2D}~\cd{of}~\tyint~\cd{*}~\tyint
\\
           & | & \cd{Point3D}~\cd{of}~\tyint~\cd{*}~\tyint~\cd{*}~\tyint
\end{array} 
\]

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Recursive Data Types
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Recursive Data Types
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In SPARC recursive data types are relatively easy to define and compute with. For example, we can define a point list data type as follows <span class="math display">\[\begin{array}{l} 
\texttt{type}~\texttt{plist} = \texttt{Nil}~|~\texttt{Cons}~\texttt{of}~\mathbb{Z}* \texttt{plist}. 
\end{array}\]</span> Based on this definition the list <span class="math display">\[\begin{array}{l} 
\texttt{Cons}(\texttt{Point2D} (0,0),   
\\ 
~~~~~~~~~~\texttt{Cons}(\texttt{Point2D} (0,1),  
\\ 
~~~~~~~~~~~~~~~~~~~~\texttt{Cons}(\texttt{Point2D}(0,2), \texttt{Nil})))   
\end{array}\]</span> defines a list consisting of three points.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In \pml recursive data types are relatively easy to define and compute
with. For example, we can define a point list data type as follows
%
\[
\begin{array}{l}
\cd{type}~\cd{plist} = \cd{Nil}~|~\cd{Cons}~\cd{of}~\tyint * \cd{plist}.
\end{array}
\] 
%
Based on this definition the list 
%
\[
\begin{array}{l}
\cd{Cons}(\cd{Point2D} (0,0),  
\\
~~~~~~~~~~\cd{Cons}(\cd{Point2D} (0,1), 
\\
~~~~~~~~~~~~~~~~~~~~\cd{Cons}(\cd{Point2D}(0,2), \cd{Nil})))  
\end{array} 
\]
%
defines a list consisting of three points.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}
Booleans
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Booleans
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Some built-in types such as booleans, <span class="math inline">\(\mathbb{B}\)</span>, are in fact syntactic sugar and can be defined by using union types as follows. Describe how you can define booleans using data types of SPARC.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Some built-in types such as booleans, $\tybool$, are in fact syntactic
sugar and can be defined by using union types as follows.
%
Describe how you can define booleans using data types of \pml{}.

\end{dilFieldBodyDex}
\end{dilAtomExercise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSolution}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR8:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR8:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Booleans can be defined as folllows.</p>
<p><span class="math display">\[\begin{array}{l} 
\texttt{type}~\texttt{myBool} = \texttt{myTrue}~|~\texttt{myFalse}  
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Booleans can be defined as folllows.

\[
\begin{array}{l}
\cd{type}~\cd{myBool} = \cd{myTrue}~|~\cd{myFalse} 
\end{array}
\] 
%

\end{dilFieldBodyDex}
\end{dilAtomSolution}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Option Type
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Option Type
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Throughout the book, we use  <span style="color: black"><span><strong><em>option</em></strong></span></span> types quite frequently. Option types for natural numbers can be defined as follows. <span class="math display">\[\begin{array}{l} 
\texttt{type}~\texttt{option} = \texttt{None} ~|~ \texttt{Some}~\texttt{of}~\mathbb{N}
\end{array}\]</span> Similarly, we can define option types for integers. <span class="math display">\[\begin{array}{l} 
\texttt{type}~\texttt{int_option} = \texttt{INone} ~|~ \texttt{ISome}~\texttt{of}~\mathbb{Z}
\end{array}\]</span> Note that we used a different data constructor for naturals. This is necessary for type inference and type checking. Since, however, types are secondary for our purposes in this book, we are sometimes sloppy in our use of types for the sake of simplicity. For example, we use throughout <span class="math inline">\(\texttt{None}\)</span> and <span class="math inline">\(\texttt{Some}\)</span> for option types regardless of the type of the contents.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Throughout the book, we use~\defn{option} types quite frequently.
%
Option types for natural numbers can be defined as follows.
%
\[
\begin{array}{l}
\cd{type}~\cd{option} = \cd{None} ~|~ \cd{Some}~\cd{of}~\tynat
\end{array}
\]
%
Similarly, we can define option types for integers.
%
\[
\begin{array}{l}
\cd{type}~\cd{int_option} = \cd{INone} ~|~ \cd{ISome}~\cd{of}~\tyint
\end{array}
\]
%
Note that we used a different data constructor for naturals.  
%
This is necessary for type inference and type checking.
%
Since, however, types are secondary for our purposes in this book, we
are sometimes sloppy in our use of types for the sake of simplicity.
%
For example, we use throughout $\cd{None}$ and $\cd{Some}$ for option
types regardless of the type of the contents.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>TODO: SEQUENCES etc.SETS.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
TODO: SEQUENCES etc.SETS.

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Values
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Values
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Values of SPARC, which are the irreducible units of computation include natural numbers, integers, Boolean values <span class="math inline">\(\texttt{true}\)</span> and <span class="math inline">\(\texttt{false}\)</span>, unary primitive operations, such as boolean negation <span class="math inline">\(\texttt{not}\)</span>, arithmetic negation <span class="math inline">\(\texttt{-}\)</span>, as well as binary operations such as logical and <span class="math inline">\(\texttt{and}\)</span> and arithmetic operations such as <span class="math inline">\(\texttt{+}\)</span>. Values also include constant-length tuples, which correspond to product types, whose components are values. Example tuples used commonly through the book include binary tuples or pairs, and ternary tuples or triples. Similarly, data constructors applied to values, which correspond to sum types, are also values.</p>
<p>As a functional language, SPARC treats all function as values. The anonymous function <span class="math inline">\(\texttt{lambda}~p.~e\)</span> is a function whose arguments are specified by the pattern <span class="math inline">\(p\)</span>, and whose body is the expression <span class="math inline">\(e\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Values of \pml, which are the irreducible units of computation
include natural numbers, integers, Boolean values $\ctrue$ and $\cfalse$,
unary primitive operations, such as boolean negation $\cd{not}$,
arithmetic negation $\cminus$, as well as binary operations such as
logical and $\cand$ and arithmetic operations such as $\cplus$.
%
Values also include constant-length tuples, which correspond to
product types, whose components are values.
%
Example tuples used commonly through the book include binary tuples or
pairs, and ternary tuples or triples.
%
Similarly, data constructors applied to values, which correspond to
sum types, are also values.
%

As a functional language, \pml treats all function as values. 
%
The anonymous function
%
$\cd{lambda}~p.~e$
%
is a function whose arguments are specified by the pattern $p$, and
whose body is the expression $e$.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR12
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR12:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR12:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<ul>
<li><p>The function <span class="math inline">\(\texttt{lambda}~x. x~\texttt{+}~1\)</span> takes a single variable as an argument and adds one to it.</p></li>
<li><p>The function <span class="math inline">\(\texttt{lambda}~(x,y).~x\)</span> takes a pairs as an argument and returns the first component of the pair.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\begin{itemize}

\item

The function 
%
$\cd{lambda}~x. x~\cd{+}~1$ takes a single variable as an argument and
adds one to it.
%

\item
The function 
%
$\cd{lambda}~(x,y).~x$ takes a pairs as an argument and
returns the first component of the pair.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR13
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR13
\end{dilLabel}
\begin{dilNo}
13
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Expressions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Expressions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR13:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR13:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Expressions, denoted by <span class="math inline">\(e\)</span> and variants (with subscript, superscript, prime), are defined inductively, because in many cases, an expression contains other expressions. Expressions describe the computations that can be expressed in SPARC. Evaluating an expression via the operational semantics of SPARC produce the value for that expression.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Expressions, denoted by $e$ and variants (with subscript, superscript,
prime), are defined inductively, because in many cases, an expression
contains other expressions.
%
Expressions describe the computations that can be expressed in \pml. 
%
Evaluating an expression via the operational semantics of \pml
produce the value for that expression.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR14
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR14
\end{dilLabel}
\begin{dilNo}
14
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Infix Expressions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Infix Expressions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR14:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR14:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An  <span style="color: black"><span><strong><em>infix expression</em></strong></span></span>, <span class="math inline">\(e_1~\texttt{op}~e_2\)</span>, involve two expressions and an infix operator <span class="math inline">\(\texttt{op}\)</span>. The infix operators include <span class="math inline">\(\texttt{+}\)</span> (plus), <span class="math inline">\(\texttt{-}\)</span> (minus), <span class="math inline">\(\texttt{*}\)</span> (multiply), <span class="math inline">\(\texttt{/}\)</span> (divide), <span class="math inline">\(\texttt{&lt;}\)</span> (less), <span class="math inline">\(\texttt{&gt;}\)</span> (greater), <span class="math inline">\(\texttt{or}\)</span>, and <span class="math inline">\(\texttt{and}.\)</span> For all these operators the infix expression <span class="math inline">\(e_1~\texttt{op}~e_2\)</span> is just syntactic sugar for <span class="math inline">\(f(e_1, e_2)\)</span> where <span class="math inline">\(f\)</span> is the function corresponding to the operator <span class="math inline">\(\texttt{op}\)</span> (see parenthesized names that follow each operator above).</p>
<p>We use standard precedence rules on the operators to indicate their parsing. For example in the expression <span class="math display">\[\texttt{3 + 4 * 5}\]</span> the <span class="math inline">\(\texttt{*}\)</span> has a higher precedence than <span class="math inline">\(\texttt{+}\)</span> and therefore the expression is equivalent to <span class="math inline">\(\texttt{3 + (4 * 5)}\)</span>.</p>
<p>Furthermore all operators are left associative unless stated otherwise, i.e., that is to say that <span class="math inline">\(a~\texttt{op}_1~b~\texttt{op}_2~c = 
(a~\texttt{op}_1~b)~\texttt{op}_2~c\)</span> if <span class="math inline">\(\texttt{op}_1\)</span> and <span class="math inline">\(\texttt{op}_2\)</span> have the same precedence.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An~\defn{infix expression}, $e_1~\cd{op}~e_2$, involve two expressions
and an infix operator $\cd{op}$.  The infix operators include $\cd{+}$
(plus), $\cd{-}$ (minus), $\cd{*}$ (multiply), $\cd{/}$ (divide),
$\cd{<}$ (less), $\cd{>}$ (greater), $\cd{or}$, and $\cd{and}.$
%
For all these operators the infix expression
$e_1~\cd{op}~e_2$ is just syntactic sugar for $f(e_1, e_2)$ where
$f$ is the function corresponding to the operator $\cd{op}$ (see
parenthesized names that follow each operator above).  
%

We use standard precedence rules on the operators to indicate their
parsing.  For example in the expression
\[
\cd{3 + 4 * 5}
\]
the $\cd{*}$ has a higher precedence than $\cd{+}$ and therefore the
expression is equivalent to $\cd{3 + (4 * 5)}$. 
%

Furthermore all operators are left associative unless stated
otherwise, i.e., that is to say that $a~\cd{op}_1~b~\cd{op}_2~c =
(a~\cd{op}_1~b)~\cd{op}_2~c$ if $\cd{op}_1$ and $\cd{op}_2$ have the
same precedence.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR15
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR15
\end{dilLabel}
\begin{dilNo}
15
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR15:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR15:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The expressions <span class="math inline">\(\texttt{5 - 4 + 2}\)</span> evaluates to <span class="math inline">\(\texttt{(5-4) + 2 = 3}\)</span> not <span class="math inline">\(\texttt{5 - (4 + 2) = -1}\)</span>, because <span class="math inline">\(\texttt{-}\)</span> and <span class="math inline">\(\texttt{+}\)</span> have the same precedence.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The expressions $\cd{5 - 4 + 2}$ evaluates to $\cd{(5-4) + 2 = 3}$ not
$\cd{5 - (4 + 2) = -1}$, because $\cd{-}$ and $\cd{+}$ have the same
precedence.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR16
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR16
\end{dilLabel}
\begin{dilNo}
16
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR16:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR16:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span>Sequential and Parallel Composition</span> Expressions include two special infix operators: “<span class="math inline">\(,\)</span>” and <span class="math inline">\(||\)</span>, for generating ordered pairs, or tuples, either sequentially or in parallel.</p>
<p>The  <span style="color: black"><span><strong><em>comma</em></strong></span></span> operator or  <span style="color: black"><span><strong><em>sequential composition</em></strong></span></span> as in the infix expression <span class="math inline">\((e_1, e_2)\)</span>, evaluates <span class="math inline">\(e_1\)</span> and <span class="math inline">\(e_2\)</span> sequentially, one after the other, and returns the ordered pair consisting of the two resulting values. Parenthesis delimit tuples.</p>
<p>The  <span style="color: black"><span><strong><em>parallel</em></strong></span></span> operator or  <span style="color: black"><span><strong><em>parallel composition</em></strong></span></span> “<span class="math inline">\(||\)</span>”, as in the infix expression <span class="math inline">\((e_1~||~e_2)\)</span>, evaluates <span class="math inline">\(e_1\)</span> and <span class="math inline">\(e_2\)</span> in parallel, at the same time, and returns the ordered pair consisting of the two resulting values.</p>
<p>The two operators are identical in terms of their return values. However, we will see later, their cost semantics differ: one is sequential and the other parallel. The comma and parallel operators have the weakest, and equal, precedence.</p>
<p>Cost model pointer.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
{Sequential and Parallel Composition}
Expressions include two special infix operators: ``$,$'' and
$||$, for generating ordered pairs, or tuples, either
sequentially or in parallel.
%

The~\defn{comma} operator or~\defn{sequential composition} as in the
infix expression $(e_1, e_2)$, evaluates $e_1$ and
$e_2$ sequentially, one after the other, and returns the ordered pair
consisting of the two resulting values.
%
Parenthesis delimit  tuples.
%
%

The~\defn{parallel} operator or~\defn{parallel composition}
``$||$'', as in the infix expression
%
$(e_1~||~e_2)$,
%
evaluates $e_1$ and $e_2$ in parallel, at the same time, and
returns the ordered pair consisting of the two resulting values.
%


The two operators are identical in terms of their return values.
%
However, we will see later, their cost semantics differ: one is
sequential and the other parallel.  The comma and parallel operators
have the weakest, and equal, precedence.
%
\begin{teachnote}
Cost model pointer.
\end{teachnote}

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR17
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR17
\end{dilLabel}
\begin{dilNo}
17
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR17:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR17:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<ul>
<li><p>The expression <span class="math display">\[\begin{array}{l} 
\texttt{lambda}~(x, y).~(x~\texttt{*}~x, y~\texttt{*}~y) 
\end{array}\]</span> is a function that take two arguments <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and returns a pair consisting of the squares <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p></li>
<li><p>The expression <span class="math display">\[\begin{array}{l} 
\texttt{lambda}~(x, y).~(x~\texttt{*}~x~||~y~\texttt{*}~y) 
\end{array}\]</span> is a function that take two arguments <span class="math inline">\(\texttt{x}\)</span> and <span class="math inline">\(\texttt{y}\)</span> and returns a pair consisting of the squares <span class="math inline">\(\texttt{x}\)</span> and <span class="math inline">\(\texttt{y}\)</span> by squaring each of <span class="math inline">\(\texttt{x}\)</span> and <span class="math inline">\(\texttt{y}\)</span> in parallel.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\begin{itemize}

\item

The expression 
\[
\begin{array}{l}
\cd{lambda}~(x, y).~(x~\cd{*}~x, y~\cd{*}~y)
\end{array}
\]
is a function that take two arguments $x$ and $y$ and returns a
pair consisting of the squares $x$ and $y$.
%

\item
The expression
\[
\begin{array}{l}
\cd{lambda}~(x, y).~(x~\cd{*}~x~||~y~\cd{*}~y)
\end{array}
\]
is a function that take two arguments $\cd{x}$ and $\cd{y}$ and returns a
pair consisting of the squares $\cd{x}$ and $\cd{y}$ by squaring each of
$\cd{x}$ and $\cd{y}$ in parallel.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR18
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR18
\end{dilLabel}
\begin{dilNo}
18
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Case Expressions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Case Expressions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR18:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR18:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>case expression</em></strong></span></span> such as <span class="math display">\[\begin{array}{l} 
\texttt{case}~e_1 \\ 
\texttt{| Nil}\Rightarrow e_2 \\  
\texttt{| Cons}~(x,y)\Rightarrow e_3 \\ 
\end{array}\]</span> first evaluates the expression <span class="math inline">\(e_1\)</span> to a value <span class="math inline">\(v_1\)</span>, which must return data type. It then matches <span class="math inline">\(v_1\)</span> to one of the patterns, <span class="math inline">\(\texttt{Nil}\)</span> or <span class="math inline">\(\texttt{Cons}~(x,y)\)</span> in our example, binds the variable if any in the pattern to the respective sub-values of <span class="math inline">\(v_1\)</span>, and evaluates the “right hand side” of the matched pattern, i.e., the expression <span class="math inline">\(e_2\)</span> or <span class="math inline">\(e_3\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{case expression} such as 
%
\[
\begin{array}{l}
\cd{case}~e_1 \\
\cd{| Nil}\dra e_2 \\ 
\cd{| Cons}~(x,y)\dra e_3 \\
\end{array}
\]
%
first evaluates the expression $e_1$ to a value $v_1$, which must
return data type.
%
It then matches $v_1$ to one of the patterns, $\cd{Nil}$ or
$\cd{Cons}~(x,y)$ in our example, binds the variable if any in the
pattern to the respective sub-values of $v_1$, and evaluates the
``right hand side'' of the matched pattern, i.e., the expression $e_2$
or $e_3$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR19
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR19
\end{dilLabel}
\begin{dilNo}
19
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Conditionals
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Conditionals
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR19:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR19:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A conditional or an  <span style="color: black"><span><strong><em>if-then-else expression</em></strong></span></span>, <span class="math inline">\(\texttt{if}~e_1~\texttt{then}~e_2~\texttt{else}~e_3\)</span>, evaluates the expression <span class="math inline">\(e_1\)</span>, which must return a Boolean. If the value of <span class="math inline">\(e_1\)</span> is true then the result of the if-then-else expression is the result of evaluating <span class="math inline">\(e_2\)</span>, otherwise it is the result of evaluating <span class="math inline">\(e_3\)</span>. This allows for conditional evaluation of expressions.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A conditional or an~\defn{if-then-else expression},
$\cd{if}~e_1~\cd{then}~e_2~\cd{else}~e_3$, evaluates the expression $e_1$,
which must return a Boolean.
%
If the value of $e_1$ is true then the result of the if-then-else
expression is the result of evaluating $e_2$, otherwise it is the
result of evaluating $e_3$.  
%
This allows for conditional evaluation of expressions.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR20
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR20
\end{dilLabel}
\begin{dilNo}
20
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Function Application
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Function Application
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR20:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR20:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>function application</em></strong></span></span>, <span class="math inline">\(e_1~e_2\)</span>, applies the function generated by evaluating <span class="math inline">\(e_1\)</span> to the value generated by evaluating <span class="math inline">\(e_2\)</span>. For example, lets say that <span class="math inline">\(e_1\)</span> evaluates to the function <span class="math inline">\(f\)</span> and <span class="math inline">\(e_2\)</span> evaluates to the value <span class="math inline">\(v\)</span>, then we apply <span class="math inline">\(f\)</span> to <span class="math inline">\(v\)</span> by first matching <span class="math inline">\(v\)</span> to the argument of <span class="math inline">\(f\)</span>, which is pattern, to determine the values of each variable in the pattern. We then substitute in the body of <span class="math inline">\(f\)</span> the value of each variable for the variable. To  <span style="color: black"><span><strong><em>substitute</em></strong></span></span> a value in place of a variable <span class="math inline">\(x\)</span> in an expression <span class="math inline">\(e\)</span>, we replace each instance of <span class="math inline">\(x\)</span> with <span class="math inline">\(v\)</span>.</p>
<p>For example if function <span class="math inline">\(\texttt{lambda}~(x,y).~e\)</span> is applied to the pair <span class="math inline">\(\texttt{(2,3)}\)</span> then <span class="math inline">\(x\)</span> is given value <span class="math inline">\(\texttt{2}\)</span> and <span class="math inline">\(y\)</span> is given value <span class="math inline">\(\texttt{3}\)</span>. Any free occurrences of the variables <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> in the expression <span class="math inline">\(e\)</span> will now be bound to the values <span class="math inline">\(\texttt{2}\)</span> and <span class="math inline">\(\texttt{3}\)</span> respectively. We can think of function application as substituting the argument (or its parts) into the free occurrences of the variables in its body <span class="math inline">\(e\)</span>. The treatment of function application is why we call SPARC a  <span style="color: black"><span><strong><em>strict</em></strong></span></span> language. In strict languages, the argument to the function is always evaluated to a value before applying the function. In contrast non-strict languages wait to see if the argument will be used before evaluating it to a value.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{function application}, $e_1~e_2$, applies the function
generated by evaluating~$e_1$ to the value generated by
evaluating~$e_2$.  
%
For example, lets say that~$e_1$ evaluates to the function~$f$
and~$e_2$ evaluates to the value~$v$, then we apply~$f$ to~$v$ by
first matching~$v$ to the argument of $f$, which is pattern, to
determine the values of each variable in the pattern.
%
We then substitute in the body of~$f$ the value of each variable for
the variable.  To~\defn{substitute} a value in place of a variable~$x$
in an expression~$e$, we replace each instance of~$x$ with~$v$.
%

For example if function $\cd{lambda}~(x,y).~e$ is applied to the pair
$\cd{(2,3)}$ then $x$ is given value $\cd{2}$ and $y$ is given value
$\cd{3}$. 
%
Any free occurrences of the variables $x$ and $y$ in the
expression $e$ will now be bound to the values $\cd{2}$ and $\cd{3}$
respectively.  
%
We can think of function application as substituting
the argument (or its parts) into the free occurrences of the variables
in its body $e$.
%
The treatment of function application is why we call \pml{} a~\defn{strict} language. 
%
In strict languages, the argument to the function is always evaluated
to a value before applying the function.
%
In contrast non-strict languages wait to see if the argument will be
used before evaluating it to a value. 
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR21
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR21
\end{dilLabel}
\begin{dilNo}
21
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR21:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR21:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<ul>
<li><p>The expression <span class="math display">\[(\texttt{lambda}~(x,y).~x / y)~(8,2)\]</span><br />
evaluates to <span class="math inline">\(\texttt{4}\)</span> since <span class="math inline">\(\texttt{8}\)</span> and <span class="math inline">\(\texttt{2}\)</span> are bound to <span class="math inline">\(\texttt{x}\)</span> and <span class="math inline">\(\texttt{y}\)</span>, respectively, and then divided.</p></li>
<li><p>The expression <span class="math display">\[(\texttt{lambda}~(f,x).~f(x,x))~(\texttt{plus},3)\]</span> evaluates to <span class="math inline">\(\texttt{6}\)</span> because <span class="math inline">\(f\)</span> is bound to the function <span class="math inline">\(\texttt{plus}\)</span>, <span class="math inline">\(x\)</span> is bound to <span class="math inline">\(\texttt{3}\)</span>, and then <span class="math inline">\(\texttt{plus}\)</span> is applied to the pair <span class="math inline">\((\texttt{3},\texttt{3})\)</span>.</p></li>
<li><p>The expression <span class="math display">\[(\texttt{lambda}~x.~(\texttt{lambda}~y .~x~\texttt{+}~y ) )~3\]</span><br />
evaluates to a function that adds <span class="math inline">\(\texttt{3}\)</span> to any integer.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\begin{itemize}

\item
The expression
\[
(\cd{lambda}~(x,y).~x / y)~(8,2)
\]
\\
evaluates to $\cd{4}$ since $\cd{8}$ and 
$\cd{2}$ are bound to $\cd{x}$ and $\cd{y}$, respectively, and then divided.

\item
The expression 
\[
(\cd{lambda}~(f,x).~f(x,x))~(\cd{plus},3)
\] 
%
evaluates to $\cd{6}$ because $f$ is bound to the function
$\cd{plus}$, $x$ is bound to $\cd{3}$, and then $\cd{plus}$ is applied
to the pair $(\cd{3},\cd{3})$.

\item
The expression
\[
(\cd{lambda}~x.~(\cd{lambda}~y .~x~\cd{+}~y ) )~3
\]
\\
%
evaluates to a function that adds $\cd{3}$ to any integer.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR22
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR22
\end{dilLabel}
\begin{dilNo}
22
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Bindings
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Bindings
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR22:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR22:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The  <span style="color: black"><span><strong><em>let expression</em></strong></span></span>, <span class="math display">\[\texttt{let}~b^+\texttt{in}~e~\texttt{end},\]</span> consists of a sequence of bindings <span class="math inline">\(b^+\)</span>, which define local variables and types, followed by an expression <span class="math inline">\(e\)</span>, in which those bindings are visible. In the syntax for the bindings, the superscript <span class="math inline">\(+\)</span> means that <span class="math inline">\(b\)</span> is repeated one or more times. Each binding <span class="math inline">\(b\)</span> is either a variable binding, a function binding, or a type binding. The let expressionevaluates to the result of evaluating <span class="math inline">\(e\)</span> given the variable bindings defined in <span class="math inline">\(b\)</span>.</p>
<p>A  <span style="color: black"><span><strong><em>function binding</em></strong></span></span>, <span class="math inline">\(x (p) = e\)</span>, consists of a function name, <span class="math inline">\(x\)</span> (technically a variable), the arguments for the function, <span class="math inline">\(p\)</span>, which are themselves a pattern, and the body of the function, <span class="math inline">\(e\)</span>.</p>
<p>Each  <span style="color: black"><span><strong><em>type binding</em></strong></span></span> equates a type to a base type or a data type.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The~\defn{let expression}, 
\[
\cd{let}~b^+\cd{in}~e~\cd{end},
\] 
%
consists of a sequence of bindings $b^+$, which define local variables
and types, followed by an expression $e$, in which those bindings are
visible.  In the syntax for the bindings, the superscript $+$ means
that $b$ is repeated one or more times.  Each binding $b$ is either a
variable binding, a function binding, or a type binding.
%
The let expressionevaluates to the result of evaluating $e$ given the
variable bindings defined in $b$.

A~\defn{function binding}, $x (p) = e$, consists of a function
name, $x$ (technically a variable), the arguments for the function,
$p$, which are themselves a pattern, and the body of the function,
$e$. 

%

Each~\defn{type binding} equates a type to a base type or a data type.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR23
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR23
\end{dilLabel}
\begin{dilNo}
23
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR23:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR23:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider the following let expression. <span class="math display">\[\begin{array}{l} 
\texttt{let}\\  
~~x = 2~\texttt{+}~3\\ 
~~f (w) = (w~\texttt{*}~4, w~\texttt{-}~2)\\ 
~~(y,z) = f(x-1)\\ 
\texttt{in}\\  
~~x~\texttt{+}~y~\texttt{+}~z\\ 
\texttt{end}  
\end{array}\]</span></p>
<p>The first binding the variable <span class="math inline">\(x\)</span> to <span class="math inline">\(\texttt{2 + 3 = 5}\)</span>; The second binding defines a function <span class="math inline">\(f(w)\)</span> which returns a pair; The third binding applies the function <span class="math inline">\(f\)</span> to <span class="math inline">\(x~\texttt{-}~1 = 4\)</span> returning the pair <span class="math inline">\((\texttt{4 * 4}, \texttt{4 -2}) = (\texttt{16},\texttt{2})\)</span>, which <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> are bound to, respectively (i.e., <span class="math inline">\(y = \texttt{16}\)</span> and <span class="math inline">\(z = \texttt{2}\)</span>. Finally the let expressions adds <span class="math inline">\(x, y, z\)</span> and yields <span class="math inline">\(\texttt{5 + 16 + 2}\)</span>. The result of the expression is therefore <span class="math inline">\(\texttt{23}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider the following let expression.
\[
\begin{array}{l}
\cd{let}\\ 
~~x = 2~\cd{+}~3\\
~~f (w) = (w~\cd{*}~4, w~\cd{-}~2)\\
~~(y,z) = f(x-1)\\
\cd{in}\\ 
~~x~\cd{+}~y~\cd{+}~z\\
\cd{end} 
\end{array}
\]

The first  binding the variable $x$ to $\cd{2 + 3 = 5}$;
%
The second binding defines a function $f(w)$ which returns a pair;
%
The third binding applies the function $f$ to $x~\cd{-}~1 = 4$
returning the pair $(\cd{4 * 4}, \cd{4 -2}) = (\cd{16},\cd{2})$, which
  $y$ and $z$ are bound to, respectively (i.e., $y = \cd{16}$ and
  $z = \cd{2}$.
%
Finally the let expressions adds $x, y, z$ and yields $\cd{5 + 16 + 2}$.  The result of the expression is therefore $\cd{23}$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR24
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR24
\end{dilLabel}
\begin{dilNo}
24
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomNote}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR24:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR24:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Be careful about defining which variables each binding can see, as this is important in being able to define recursive functions. In SPARC the expression on the right of each binding in a <span class="math inline">\(\texttt{let}\)</span> can see all the variables defined in previous variable bindings, and can see the function name variables of all binding (including itself) within the <span class="math inline">\(\texttt{let}\)</span>. Therefore the function binding <span class="math display">\[\texttt{x}(p) = e\]</span> is not equivalent to the variable binding <span class="math display">\[\texttt{x} = \texttt{lambda}~p.e,\]</span> because in the prior <span class="math inline">\(x\)</span> can be used in <span class="math inline">\(e\)</span> and in the later it cannot. Function bindings therefore allow for the definition of recursive functions. Indeed they allow for mutually recursive functions since the body of function bindings within the same <span class="math inline">\(\texttt{let}\)</span> can reference each other.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Be careful about defining which variables each binding can see, as
this is important in being able to define recursive functions.  In
\pml{} the expression on the right of each binding in a $\cd{let}$ can
see all the variables defined in previous variable bindings, and can
see the function name variables of all binding (including itself)
within the $\cd{let}$.
%
Therefore the function binding
%
\[
\cd{x}(p) = e
\]
%
is not equivalent to the variable binding
%
\[
\cd{x} = \cd{lambda}~p.e,
\]
%
because in the prior $x$ can be used
in $e$ and in the later it cannot.
%
Function bindings therefore allow for the definition of
recursive functions.  
%
Indeed they allow for mutually recursive functions since the body of
function bindings within the same $\cd{let}$ can reference each other.

\end{dilFieldBodyDex}
\end{dilAtomNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR25
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR25
\end{dilLabel}
\begin{dilNo}
25
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR25:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR25:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The expression <span class="math display">\[\begin{array}{l} 
\texttt{let}\\ 
~~f(i) = \texttt{if} ~(i &lt; 2) ~\texttt{then}~ i ~\texttt{else}~ i ~\texttt{*}~ 
f(i~\texttt{-}~\texttt{1}) \\ 
\texttt{in} \\  
~~f(5) \\ 
\texttt{end}  
\end{array}\]</span> will evaluate to the factorial of <span class="math inline">\(\texttt{5}\)</span>, i.e., <span class="math inline">\(\texttt{5 * 4 * 3 * 2 
* 1}\)</span>, which is <span class="math inline">\(\texttt{120}.\)</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The expression
%
\[
\begin{array}{l}
\cd{let}\\
~~f(i) = \cd{if} ~(i < 2) ~\cd{then}~ i ~\cd{else}~ i ~\cd{*}~
f(i~\cd{-}~\cd{1}) \\
\cd{in} \\ 
~~f(5) \\
\cd{end} 
\end{array}
\]
will evaluate to the factorial of $\cd{5}$, i.e., $\cd{5 * 4 * 3 * 2
* 1}$, which is $\cd{120}.$

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR26
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR26
\end{dilLabel}
\begin{dilNo}
26
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR26:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR26:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The piece of code below illustrates an example use of data types and higher-order functions. <span class="math display">\[\begin{array}{l} 
\texttt{let} 
\\  
~~\texttt{type}~\texttt{point} = \texttt{Point2D}~\texttt{of}~\mathbb{Z}* \mathbb{Z}
\\  
~~~~~~~~~~~~~~~~~~~~~~~~|~~\texttt{Point3D}~\texttt{of}~ \mathbb{Z}* \mathbb{Z}* \mathbb{Z}
\\ 
~~\texttt{inject3D}~(\texttt{Point2D}~(x, y)) = \texttt{Point3D}~(x, y, 0) 
\\   
~~\texttt{project2D}~(\texttt{Point3D}~(x, y, z)) = \texttt{Point2D}~(x, y) 
\\  
~~\texttt{compose}~f~g = f~g   
\\ 
~~p0 = (0,0) 
\\ 
~~q0 = \texttt{project3D}~p0 
\\ 
~~p1 = (\texttt{compose}~\texttt{project2D}~\texttt{inject3D})~p0 
\\ 
\texttt{in}  
\\ 
~~(p0, q0) 
\\ 
\texttt{end} 
\end{array}\]</span></p>
<p>The example code above defines a <span class="math inline">\(\texttt{point}\)</span> as a two (consisting of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes) or three dimensional (consisting of <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span> axes) point in space. The function <span class="math inline">\(\texttt{inject3D}\)</span> takes a 2D point and transforms it to a 3D point by mapping it to a point on the <span class="math inline">\(z=0\)</span> plane. The function <span class="math inline">\(\texttt{project2D}\)</span> takes a 3D point and transforms it to a 2D point by dropping its <span class="math inline">\(z\)</span> coordinate. The function <span class="math inline">\(\texttt{compose}\)</span> takes two functions <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> and composes them. The function <span class="math inline">\(\texttt{compose}\)</span> is a higher-order function, since id operates on functions.</p>
<p>The point <span class="math inline">\(p0\)</span> is the origin in 2D. The point <span class="math inline">\(q0\)</span> is then computed as the origin in 3D. The point <span class="math inline">\(p1\)</span> is computed by injecting <span class="math inline">\(p0\)</span> to 3D and then projecting it back to 2D by dropping the <span class="math inline">\(z\)</span> components, which yields again <span class="math inline">\(p0\)</span>. In the end we thus have <span class="math inline">\(p0 = p1 = (0,0)\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The piece of code below illustrates an example use of data types and
higher-order functions.
%
\[
\begin{array}{l}
\cd{let}
\\ 
~~\cd{type}~\cd{point} = \cd{Point2D}~\cd{of}~\tyint * \tyint
\\ 
~~~~~~~~~~~~~~~~~~~~~~~~|~~\cd{Point3D}~\cd{of}~ \tyint * \tyint * \tyint
\\
~~\cd{inject3D}~(\cd{Point2D}~(x, y)) = \cd{Point3D}~(x, y, 0)
\\  
~~\cd{project2D}~(\cd{Point3D}~(x, y, z)) = \cd{Point2D}~(x, y)
\\ 
~~\cd{compose}~f~g = f~g  
\\
~~p0 = (0,0)
\\
~~q0 = \cd{project3D}~p0
\\
~~p1 = (\cd{compose}~\cd{project2D}~\cd{inject3D})~p0
\\
\cd{in} 
\\
~~(p0, q0)
\\
\cd{end}
\end{array}
\]

The example code above defines a $\cd{point}$ as a two (consisting of
$x$ and $y$ axes) or three dimensional (consisting of $x$, $y$, and
$z$ axes) point in space.
%
The function $\cd{inject3D}$ takes a 2D point and transforms it to a 3D
point by mapping it to a point on the $z=0$ plane. 
%
The function $\cd{project2D}$ takes a 3D point and transforms it to a 2D
point by dropping its $z$ coordinate.
%
The function $\cd{compose}$ takes two functions $f$ and $g$ and composes
them.
%
The function $\cd{compose}$ is a higher-order function, since id operates
on functions.

The point $p0$ is the origin in 2D.  The point $q0$ is then computed
as the origin in 3D.  The point $p1$ is computed by injecting $p0$ to
3D and then projecting it back to 2D by dropping the $z$ components,
which yields again $p0$.  
%
In the end we thus have $p0 = p1 = (0,0)$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR27
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR27
\end{dilLabel}
\begin{dilNo}
27
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR27:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR27:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following SPARC code, which defines a binary tree whose leaves and internal nodes holds keys of integer type. The function <span class="math inline">\(\texttt{find}\)</span> performs a lookup in a given binary-search tree <span class="math inline">\(t\)</span>, by recursively comparing the key <span class="math inline">\(x\)</span> to the keys along a path in the tree.</p>
<p><span class="math display">\[\begin{array}{l} 
\texttt{type}~\texttt{tree} = \texttt{Leaf}~\texttt{of}~\mathbb{Z}~|~\texttt{Node}~\texttt{of} (\texttt{tree}, \mathbb{Z}, \texttt{tree}) 
\\ 
\texttt{find} (t, x) =  
\\ 
~~\texttt{case}~x 
\\  
~~|~\texttt{Leaf}~y \Rightarrow x = y  
\\ 
~~|~\texttt{Node}~(\texttt{left}, y, \texttt{right}) \Rightarrow
\\ 
~~~~~~\texttt{if}~x = y~\texttt{then}  
\\ 
~~~~~~~~\texttt{return}~\texttt{true} 
\\ 
~~~~~~\texttt{else}~\texttt{if}~x &lt; y~\texttt{then}  
\\ 
~~~~~~~~\texttt{find}~(\texttt{left}, x) 
\\ 
~~~~~~\texttt{else} 
\\ 
~~~~~~~~\texttt{find}~(\texttt{right}, x) 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following \pml code, which defines a binary tree whose leaves and
internal nodes holds keys of integer type.
%
The function $\cd{find}$ performs a lookup in a given binary-search tree
$t$, by recursively comparing the key $x$ to the keys along a path in
the tree.

\[
\begin{array}{l}
\cd{type}~\cd{tree} = \cd{Leaf}~\cd{of}~\tyint~|~\cd{Node}~\cd{of} (\cd{tree}, \tyint, \cd{tree})
\\
\cd{find} (t, x) = 
\\
~~\cd{case}~x
\\ 
~~|~\cd{Leaf}~y \dra x = y 
\\
~~|~\cd{Node}~(\cd{left}, y, \cd{right}) \dra
\\
~~~~~~\cd{if}~x = y~\cd{then} 
\\
~~~~~~~~\cd{return}~\cd{true}
\\
~~~~~~\cd{else}~\cd{if}~x < y~\cd{then} 
\\
~~~~~~~~\cd{find}~(\cd{left}, x)
\\
~~~~~~\cd{else}
\\
~~~~~~~~\cd{find}~(\cd{right}, x)
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR28
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN2:GR28
\end{dilLabel}
\begin{dilNo}
28
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN2:GR28:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN2:GR28:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p> <br />
The definition <span class="math display">\[\texttt{lambda} \; x\,.\,(\texttt{lambda} \; y\,.\,f(x,y))\]</span> takes a function <span class="math inline">\(f\)</span> of a pair of arguments and converts it into a function that takes one of the arguments and returns a function which takes the second argument. This technique can be generalized to functions with multiple arguments and is often referred to as  <span style="color: black"><span><strong><em>currying</em></strong></span></span>, named after Haskell Curry (1900-1982), who developed the idea. It has nothing to do with the popular dish from Southern Asia, although that might be an easy way to remember the term.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
~\\
%\begin{minipage}[t]{3.5in}
The definition
\[
\cfn{x}{(\cfn{y}{f(x,y)})}
\]
  takes a function $f$ of a pair of arguments and converts it
  into a function that takes one of the arguments and returns a
  function which takes the second argument.  This technique can be
  generalized to functions with multiple arguments and is often
  referred to as~\defn{currying}, named after Haskell Curry
  (1900-1982), who developed the idea.  It has nothing to do with the
  popular dish from Southern Asia, although that might be an easy way
  to remember the term.
%\end{minipage}
%% %
%% \begin{notesonly}
%% \begin{minipage}[t]{2.2in}
%% \vspace*{0in}
%% \includegraphics[width=2.2in]{introduction/curry}
%% \end{minipage}
%% \end{notesonly}

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}
\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Derived Syntax for Loops
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Derived Syntax for Loops
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH3:SEC2:UN3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN3:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN3:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>SPARC does not have explicit syntax for loops but loops can be implemented with recursion. We use the syntactic sugar, which is defined below, for expressing while loops.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\pml{} does not have explicit syntax for loops but loops can be
implemented with recursion.
%
We use the syntactic sugar, which is defined below, for expressing
while loops.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN3:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSyntax}
\begin{dilFieldTitle}
While loops
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
While loops
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN3:GR2:AT1:syn:language::while
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The  <span style="color: black"><span><strong><em>while loop</em></strong></span></span> can appear as one of the bindings <span class="math inline">\(b\)</span> in a <code>let</code> expression and has the syntax the following syntax. <span class="math display">\[\begin{array}{ll} 
xs =  
&amp; \texttt{start}~p~\texttt{and} 
\\ 
&amp; \texttt{while}~e_{continue}~\texttt{do} 
\\ 
&amp;~~~~b^+ 
\end{array}\]</span> Here <span class="math inline">\(xs\)</span> are the result variables holding the values computed by the while loop, the pattern <span class="math inline">\(p\)</span> is the initial value for <span class="math inline">\(xs\)</span>. Such a <span class="math inline">\(\texttt{while}\)</span> loop evaluates by setting <span class="math inline">\(xs\)</span> to pattern <span class="math inline">\(p\)</span> and then evaluating the loop until <span class="math inline">\(e_{continue}\)</span> evaluates to <span class="math inline">\(\texttt{false}\)</span>. In a typical use the body of the loop <span class="math inline">\(b^+\)</span> defines the variables <span class="math inline">\(xs\)</span>, whose final value will be the value of <span class="math inline">\(xs\)</span> when the loop terminates.</p>
<p>We define the while loop syntax above to be equivalent to the following pair of bindings.</p>
<p><span class="math display">\[\begin{array}{l} 
f~xs = \texttt{if not}~e_{continue}~\texttt{then}~xs 
\\ 
~~~~~~~~~~~~~\texttt{else let}~b^+~\texttt{in}~f~xs~\texttt{end} 
\\ 
\texttt{xs} =  f~p 
\end{array}\]</span></p>
<p>Here <span class="math inline">\(xs\)</span>, <span class="math inline">\(p\)</span>, <span class="math inline">\(e_{continue}\)</span> and <span class="math inline">\(b^+\)</span> are substituted verbatim. The loop is expressed as a function that takes <span class="math inline">\(xs\)</span> as an argument and runs the body of the loop until the expression <span class="math inline">\(e_{continue}\)</span> becomes false at which time the variables <span class="math inline">\(xs\)</span> is returned. The variables <span class="math inline">\(xs\)</span> are passed from one iteration of the while to the next each of which might redefine them in the bindings. After the loop terminates, the variables take on the value they had at the end of the last iteration.</p>
<p>When evaluated a while loop starts by matching the variables <span class="math inline">\(xs\)</span> to the pattern <span class="math inline">\(p\)</span> and then continues to evaluate the while loop in the usual fashion. It first checks the value of <span class="math inline">\(e_{continue}\)</span>, if it is false, then the evaluation completes. If not, then the bindings in <span class="math inline">\(b^{+}\)</span>, which can use the variables <span class="math inline">\(xs\)</span>, are evaluated. Having finished the body, evaluation jumps to the beginning of the <span class="math inline">\(\texttt{while}\)</span> and evaluates the termination condition <span class="math inline">\(e_{continue}\)</span>, and continues on executing the loop body and so on.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The~\defn{while loop} can appear as one of the bindings $b$ in a
\cd{let} expression and has the syntax the following syntax.
%
\[
\begin{array}{ll}
xs = 
& \cd{start}~p~\cd{and}
\\
& \cd{while}~e_{continue}~\cd{do}
\\
&~~~~b^+
\end{array}
\]
%
Here $xs$ are the result variables holding the values computed by the
while loop, the pattern $p$ is the initial value for $xs$.
%
Such a $\cd{while}$ loop evaluates by setting $xs$ to pattern $p$ and
then evaluating the loop until $e_{continue}$ evaluates to $\cfalse$.
%
In a typical use the body of the loop $b^+$ defines the variables
$xs$, whose final value will be the value of $xs$ when the loop terminates.

We define the while loop syntax above  to be equivalent to the
following pair of bindings.

\[
\begin{array}{l}
f~xs = \cd{if not}~e_{continue}~\cd{then}~xs
\\
~~~~~~~~~~~~~\cd{else let}~b^+~\cd{in}~f~xs~\cd{end}
\\
\cd{xs} =  f~p
\end{array}
\]

%% \[
%% \begin{align}
%% f~xs  = & \cd{if not}~e_{continue}~\cd{then}~xs
%% \\
%%   & \cd{else let}~b^+~\cd{in}~f~xs~\cd{end}
%% \\
%% \cd{xs} & = & f~p
%% \end{align}
%% \]

Here $xs$, $p$, $e_{continue}$ and $b^+$ are substituted
verbatim.  
%
The loop is expressed as a function that takes $xs$ as an argument and
runs the body of the loop until the expression $e_{continue}$ becomes
false at which time the variables $xs$ is returned.
%
The variables $xs$ are passed from one iteration of the while to the next
each of which might redefine them in the bindings.  
%
After the loop terminates, the variables take on the value they had at
the end of the last iteration.

When evaluated a while loop starts by matching the variables $xs$ to
the pattern $p$ and then continues to evaluate the while loop in the
usual fashion.
%
It first checks the value of $e_{continue}$, if it is false, then the
evaluation completes.  
%
If not, then the  bindings in $b^{+}$, which can use the variables
$xs$, are evaluated.
%
Having finished the body, evaluation jumps to the beginning of the
$\cd{while}$ and evaluates the termination condition $e_{continue}$, and
continues on executing the loop body and so on.

\end{dilFieldBodyDex}
\end{dilAtomSyntax}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC2:UN3:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC2:UN3:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC2:UN3:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following code sums the squares of the integers from 1 to <span class="math inline">\(n\)</span>. <span class="math display">\[\begin{array}{l} 
\texttt{sumSquares}~(n) =  
\\ 
~~~~\texttt{let}~(s,n) = \texttt{start}~(0,n)~\texttt{and} \\  
~~~~~~~~~~~~~~~~~~~~~~~~~~\texttt{while}~n &gt; 0~\texttt{do} \\ 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~s = s~\texttt{+}~n~\texttt{*}~n \\ 
~~~~~~~~~~~~~n = n~\texttt{-}~\texttt{1}\\ 
~~~~\texttt{in}~s~\texttt{end} 
\end{array}\]</span> By definition it is equivalent to the following code. <span class="math display">\[\begin{array}{l} 
\texttt{sumSquares}~(n) =\\  
~~~~\texttt{let}~f(s,n) = \\  
~~~~~~~~~~~~~~~\texttt{if}~\texttt{not} (n &gt; 0) ~\texttt{then}\\ 
~~~~~~~~~~~~~~~~~~~(n,s) \\ 
~~~~~~~~~~~~~~~\texttt{else}\\ 
~~~~~~~~~~~~~~~~~~~\texttt{let} \\ 
~~~~~~~~~~~~~~~~~~~~~~~~s = s ~\texttt{+} n ~\texttt{*} n \\ 
~~~~~~~~~~~~~~~~~~~~~~~~n = n ~\texttt{-} 1 \\ 
~~~~~~~~~~~~~~~~~~~\texttt{in}~f(s,n)~\texttt{end}\\ 
~~~~~~~~~~~~~(s,n) = f(0,n)\\ 
~~~~\texttt{in}~s~\texttt{end} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following code sums the squares of the integers from 1 to $n$.
%
\[
\begin{array}{l}
\cd{sumSquares}~(n) = 
\\
~~~~\cd{let}~(s,n) = \cd{start}~(0,n)~\cd{and} \\ 
~~~~~~~~~~~~~~~~~~~~~~~~~~\cd{while}~n > 0~\cd{do} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~s = s~\cd{+}~n~\cd{*}~n \\
~~~~~~~~~~~~~n = n~\cd{-}~\cd{1}\\
~~~~\cd{in}~s~\cd{end}
\end{array}
\]
%
By definition it is equivalent
to the following code.
\[
\begin{array}{l}
\cd{sumSquares}~(n) =\\ 
~~~~\cd{let}~f(s,n) = \\ 
~~~~~~~~~~~~~~~\cd{if}~\cd{not} (n > 0) ~\cd{then}\\
~~~~~~~~~~~~~~~~~~~(n,s) \\
~~~~~~~~~~~~~~~\cd{else}\\
~~~~~~~~~~~~~~~~~~~\cd{let} \\
~~~~~~~~~~~~~~~~~~~~~~~~s = s ~\cd{+} n ~\cd{*} n \\
~~~~~~~~~~~~~~~~~~~~~~~~n = n ~\cd{-} 1 \\
~~~~~~~~~~~~~~~~~~~\cd{in}~f(s,n)~\cd{end}\\
~~~~~~~~~~~~~(s,n) = f(0,n)\\
~~~~\cd{in}~s~\cd{end}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Functional Algorithms
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Functional Algorithms
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH3:SEC3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}
...NO.INTRO...

\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Effects and Purity
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Effects and Purity
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH3:SEC3:UN4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Many parallel algorithms are  <span style="color: black"><span><strong><em>purely functional</em></strong></span></span>. To understand what this means, let’s review first what it means for an algorithm to be pure and functional.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Many parallel algorithms are~\defn{purely functional}.  To understand
what this means, let's review first what it means for an algorithm to
be pure and functional.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Side Effects
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Side Effects
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We say that a computation has a  <span style="color: black"><span><strong><em>side effect</em></strong></span></span>, if in addition to returning a value, it also performs an effect such as writing to an existing memory location, printing on the screen, or writing to a file.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We say that a computation has a~\defn{side effect}, if in addition to
returning a value, it also performs an effect such as writing to an
existing memory location, printing on the screen, or writing to a
file.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR2:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR2:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider a function that given a natural number <span class="math inline">\(n\)</span> as an argument computes and returns the <span class="math inline">\(n^{th}\)</span> Fibonacci number, and also updates the argument <span class="math inline">\(n\)</span> by overwriting it with the return value. This function has the side effect of changing the value of its argument.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number, and also updates
the argument $n$ by overwriting it with the return value.
%
This function has the side effect of changing the value of its
argument.
%

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Pure computation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Pure computation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We say that a computation is   <span style="color: black"><span><strong><em>pure</em></strong></span></span> if it doesn’t perform any side effects. Pure computations return a value without performing any side effects. In contrast an  <span style="color: black"><span><strong><em>impure</em></strong></span></span> or  <span style="color: black"><span><strong><em>imperative</em></strong></span></span> computation can perform side effects. The Fibonacci function described above is impure.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We say that  a computation is ~\defn{pure} if it doesn't perform any side
  effects.
%
Pure computations return a value without performing any side effects.
%
In contrast an~\defn{impure} or~\defn{imperative} computation can
perform side effects.  The Fibonacci function described above is
impure.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR3:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR3:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider a function that given a natural number <span class="math inline">\(n\)</span> as an argument computes and returns the <span class="math inline">\(n^{th}\)</span> Fibonacci number by recursively computing the <span class="math inline">\((n-1)^{st}\)</span> and <span class="math inline">\((n-2)^{nd}\)</span> Fibonacci numbers and summing them up. This function is pure because it has no side effects.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider a function that given a natural number $n$ as an argument
computes and returns the $n^{th}$ Fibonacci number by recursively
computing the $(n-1)^{st}$ and $(n-2)^{nd}$ Fibonacci numbers and
summing them up.
%
This function is pure because it has no side effects.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Pure computations correspond closely with mathematical systems or notation, where for example, determining the result of a calculation of formula does not affect the result of another. The notion of purity can be further extended to allow for effects that are not  <span style="color: black"><span><strong><em>observable</em></strong></span></span>. For example, the Fibonacci function described above may be implemented by using a mutable reference that holds some intermediate value that may be used to compute the result. If this reference is not observable (e.g., not visible to the caller of the function), the function has no observable effect, and can thus be considered pure. Such effects are sometimes called  <span style="color: black"><span><strong><em>benign effects</em></strong></span></span>. This more general notion of purity is important because it allows for example using side effects in a “responsible” fashion to improve efficiency.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Pure computations correspond closely with mathematical systems or
notation, where for example, determining the result of a calculation
of formula does not affect the result of another.
%
The notion of purity can be further extended to allow for effects
that are not~\defn{observable}.  
%
For example, the Fibonacci function
described above may be implemented by using a mutable reference that
holds some intermediate value that may be used to compute
the result.
%
If this reference is not observable (e.g., not visible to the caller
of the function), the function has no observable
effect, and can thus be considered pure.  Such effects are sometimes
called~\defn{benign effects}.
%
This more general notion of purity is important because it allows for
example using side effects in a ``responsible'' fashion to improve
efficiency.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomImportant}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Strictly speakig there is probably no non-trivial computation that is pure because almost any computation performs memory effects at the hardware level. Encapsulation of effects by observation is therefore essential for meaningful discussions of purity.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Strictly speakig there is probably no non-trivial computation that is
pure because almost any computation performs memory effects at the
hardware level.  Encapsulation of effects by observation is therefore
essential for meaningful discussions of purity.

\end{dilFieldBodyDex}
\end{dilAtomImportant}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Functional Programming
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Functional Programming
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A programming language is called  <span style="color: black"><span><strong><em>functional</em></strong></span></span>, if it does not restrict the use of functions any more than the use of other values such as natural numbers.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A programming language is called~\defn{functional}, if it does not
restrict the use of functions any more than the use of other values
such as natural numbers.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>This principle is sometimes referred to as “functions as first-class values” or “functions as first-class citizens”. Functional programming languages do not distinguish between a function and other values: both can be used as building blocks of values, stored in memory, and passed as arguments to functions, etc. For example, a function that returns the number <code>1</code> under some argument and the natural number <code>1</code> are the same for the purposes of computation. Treating functions as values leads to a powerful way to code. For example, we can write  <span style="color: black"><span><strong><em>higher-order functions</em></strong></span></span> that take functions as their arguments.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
This principle is sometimes referred to as ``functions as first-class
values'' or ``functions as first-class citizens''.  
%
Functional programming languages do not distinguish between a function
and other values: both can be used as building blocks of values,
stored in memory, and passed as arguments to functions, etc.
%
For example, a function that returns the number~\cd{1} under some
argument and the natural number \cd{1} are the same for the purposes
of computation.
%
Treating functions as values leads to a powerful way to code.  
%
For example, we can write~\defn{higher-order functions} that take
functions as their arguments.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Purely Functional Algorithm
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Purely Functional Algorithm
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>purely functional algorithm</em></strong></span></span> is an algorithm that is both pure and functional, i.e., it is described in a functional language and it avoids use of observable side effects such as imperative updates to memory locations that can be observed and can thus have an effect on other computations.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{purely functional algorithm} is an algorithm that is both pure
and functional, i.e., it is described in a functional language and it
avoids use of observable side effects such as imperative updates to
memory locations that can be observed and can thus have an effect on
other computations.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>What are the advantages of purely functional algorithms and programming?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
What are the advantages of purely functional algorithms and
programming?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Purely functional algorithms are particularly useful for parallelism for two important reasons.</p>
<ul>
<li><p>Purely functional algorithms are safe for parallelism. Different parts of the algorithm may be executed in parallel without affecting each other. In contrast, in imperative programming, the programmer must take care that side effects don’t alter the meaning of the program in unintended ways. The problem is that preventing side effects from altering the meaning of the program is very difficult, because 1) depending on the exact execution order (timing) of components, side effects may cause a computation to return different results at different times, and 2) there are exponentially many different orderings.</p></li>
<li><p>Second, higher-order functions (even in a language that is not pure) help with the design and implementation of parallel algorithm by encouraging the designer to think at a higher level of abstraction. For example, instead of thinking about a loop that iterates over the elements of an array to generate the sum, which is completely sequential, we can define a higher-order “reduce” function. In addition to taking the array as an argument, the reduce function takes a binary associative function as another argument. It then sums the array based on that binary associative function. The advantage is that the higher-order reduce allows for any binary associative function (e.g. maximum, minimum, multiplication). By implementing the reduce function as a tree sum, which is highly parallel, we can thus perform a variety of computations in parallel rather than sequentially as a loop. In general, thinking in higher order functions encourages working at a higher level of abstraction, moving us away from the one-at-a-time (loop) way of thinking that is detrimental to code quality and to parallelism.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Purely functional algorithms are particularly useful for parallelism
for  two important reasons.

\begin{itemize}

\item Purely functional algorithms are safe for parallelism.
%
Different parts of the algorithm may be executed in parallel without
affecting each other.
%
In contrast, in imperative programming, the programmer must take care
that side effects don't alter the meaning of the program in
unintended ways.
%
The problem is that preventing side effects from altering the meaning
of the program is very difficult, because 1) depending on the exact
execution order (timing) of components, side effects may cause a
computation to return different results at different times, and 2)
there are exponentially many different orderings.
%


\item
Second, higher-order functions (even in a language that is not pure)
help with the design and implementation of parallel algorithm by
encouraging the designer to think at a higher level of abstraction.
%
For example, instead of thinking about a loop that iterates over the
elements of an array to generate the sum, which is completely
sequential, we can define a higher-order ``reduce'' function. 
%
In addition to taking the array as an argument, the reduce function
takes a binary associative function as another argument.  It then sums
the array based on that binary associative function.
%
The advantage is that the higher-order reduce allows for any
binary associative function (e.g. maximum, minimum, multiplication).
%
By implementing the reduce function as a tree sum, which is highly
parallel, we can thus perform a variety of computations in parallel
rather than sequentially as a loop.
%
In general, thinking in higher order functions encourages working at a
higher level of abstraction, moving us away from the one-at-a-time
(loop) way of thinking that is detrimental to code quality and
to parallelism.
\end{itemize}
% Finally, functional programs don't have traditional loops.  We hope 
% that the lack of such loops discourages the use of sequential code,
% when parallel code is preferable.  For example we will use the 
% following notation 
% \[\cseq{f(x) : x \in S}\]
% to mean apply the function $f$ to each $x$ in the sequence $S$ and return 
% a new sequence.   This is purely functional (assuming $f$ has no side effects) 
% and is also parallel since all the applications of $f$ to each $x$ can 
% happen in parallel.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN4:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN4:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN4:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Coding a purely functional algorithm does not require a purely functional programming language. In fact, a purely functional algorithm can be coded in essentially any programming language—one just needs to be much more careful when coding imperatively in order to avoid errors caused by sharing of state and side effects. Some imperative parallel languages such as extension to the C language, in fact, encourage programming purely functional algorithms. The techniques that we describe thus are applicable to imperative programming languages as well.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Coding a purely functional algorithm does not require a purely
functional programming language.
%
In fact, a purely functional algorithm can be coded in essentially any
programming language---one just needs to be much more careful when
coding imperatively in order to avoid errors caused by sharing of
state and side effects.  
%
Some imperative parallel languages such as extension to the C
language, in fact, encourage programming purely functional algorithms.
%
The techniques that we describe thus are applicable to  imperative
programming languages as  well.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}
\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Race Conditions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Race Conditions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH3:SEC3:UN5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Race conditions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Race conditions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Side effects that alter the result of the computation based on the evaluation order (timing) are called  <span style="color: black"><span><strong><em>race conditions</em></strong></span></span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Side effects that alter the result of the computation based on the
evaluation order (timing) are called~\defn{race conditions}.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Functional algorithms avoid race condition because they do not permit observable side effects. For example, in SPARC, the language that we use to describe algorithms in this course, there is no syntax for memory effects. To discuss side effects and give example, we will extend SPARC with a simple  <span style="color: black"><span><strong><em>assignment</em></strong></span></span> operation, which overwrites the value of a variable. The syntax <span class="math display">\[x \leftarrow e\]</span> means that <span class="math inline">\(e\)</span> is evaluated to a value <span class="math inline">\(v\)</span>, <span class="math inline">\(v\)</span> is written into the variable <span class="math inline">\(x\)</span>, and a unit <span class="math inline">\(()\)</span> is returned. Note that this is different than <span class="math display">\[x = e,\]</span> because the latter defines a (new) variable <span class="math inline">\(x\)</span> whose value is that of <span class="math inline">\(e\)</span>. The variable may shadow an existing variable with the same name but cannot change its value.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Functional algorithms avoid race condition because they do not 
permit observable side effects.  For example, in \pml{}, the language
that we use to describe algorithms in this course, there is no syntax
for memory effects.  
%
To discuss side effects and give example, we will extend \pml{} with a
simple~\defn{assignment} operation, which overwrites the value of a
variable.
%
The syntax 
\[
x \la e
\]
means that $e$ is evaluated to a value $v$, $v$ is written into the
variable $x$, and a unit $()$ is returned. 
%
Note that this is different than 
\[
x = e,
\]
because the latter defines a (new) variable $x$ whose value is that of
$e$.  The variable may shadow an existing variable with the same name
but cannot change its value.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider the following piece of code where the function <span class="math inline">\(\texttt{select}\)</span> calls two functions <span class="math inline">\(\texttt{left}\)</span> and <span class="math inline">\(\texttt{right}\)</span> in parallel. The return value of <span class="math inline">\(\texttt{select}\)</span> depends on the order in which <span class="math inline">\(\texttt{left}\)</span> and <span class="math inline">\(\texttt{right}\)</span> execute because <span class="math inline">\(\texttt{select}\)</span> passes to both functions the same reference to write to, whose contents it returns.</p>
<p><span class="math display">\[\begin{array}{l} 
\texttt{left}~x = x \leftarrow\text{&#39;}\,{\texttt{left}}\,\text{&#39;} 
\\  
\texttt{right}~y = y \leftarrow\text{&#39;}\,{\texttt{right}}\,\text{&#39;} 
\\ 
\texttt{select}~() =  
\\ 
~~\texttt{let} 
 
\\ 
~~~~z \leftarrow\text{&#39;}\,{\texttt{center}}\,\text{&#39;} 
\\ 
~~~~(\texttt{left}~z)~||~(\texttt{right}~z) 
\\ 
~~\texttt{in} 
\\ 
~~~~!z 
\\ 
~~\texttt{end} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider the following piece of code where the function $\cd{select}$
calls two functions $\cd{left}$ and $\cd{right}$ in parallel.
%
The return value of $\cd{select}$ depends on the order in which
$\cd{left}$ and $\cd{right}$ execute because $\cd{select}$ passes to
both functions the same reference to write to, whose contents it
returns.

\[
\begin{array}{l}
\cd{left}~x = x \la \cstr{left}
\\ 
\cd{right}~y = y \la \cstr{right}
\\
\cd{select}~() = 
\\
~~\cd{let}

\\
~~~~z \la \cstr{center}
\\
~~~~(\cd{left}~z)~||~(\cd{right}~z)
\\
~~\cd{in}
\\
~~~~!z
\\
~~\cd{end}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider two tiny functions given below that read and write from the same references. The programmer convinced themselves that the function <span class="math inline">\(\texttt{select}\)</span> would return <span class="math inline">\((\texttt{left}, \texttt{right}).\)</span></p>
<p>Is the programmer correct? Prove or disprove?</p>
<p><span class="math display">\[\begin{array}{l} 
\texttt{left}~(x,y) =\\ 
~~y \leftarrow\text{&#39;}\,{\texttt{left}}\,\text{&#39;} 
\\  
~~x \leftarrow\text{&#39;}\,{\texttt{left}}\,\text{&#39;} 
\\ 
~~\\ 
\texttt{right}~(x,y) =\\ 
~~x \leftarrow\text{&#39;}\,{\texttt{right}}\,\text{&#39;} 
\\  
~~y \leftarrow\text{&#39;}\,{\texttt{right}}\,\text{&#39;} 
\\ 
~~\\ 
\texttt{select}~() =  
\\ 
~~\texttt{let} 
\\ 
~~~~x \leftarrow\text{&#39;}\,{\texttt{center}}\,\text{&#39;} 
\\ 
~~~~y \leftarrow\text{&#39;}\,{\texttt{center}}\,\text{&#39;} 
\\ 
~~~~((),()) = (\texttt{left}(x,y))~||~(\texttt{right}(x,y)) 
\\ 
~~\texttt{in} 
\\ 
~~~~(!x, !y) 
\\ 
~~\texttt{end} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider two tiny functions given below that read and write from the
same references.
%
The programmer convinced themselves that the function $\cd{select}$
would return $(\cd{left}, \cd{right}).$

Is the programmer correct? Prove or disprove? 
 
\[
\begin{array}{l}
\cd{left}~(x,y) =\\
~~y \la \cstr{left}
\\ 
~~x \la \cstr{left}
\\
~~\\
\cd{right}~(x,y) =\\
~~x \la \cstr{right}
\\ 
~~y \la \cstr{right}
\\
~~\\
\cd{select}~() = 
\\
~~\cd{let}
\\
~~~~x \la \cstr{center}
\\
~~~~y \la \cstr{center}
\\
~~~~((),()) = (\cd{left}(x,y))~||~(\cd{right}(x,y))
\\
~~\cd{in}
\\
~~~~(!x, !y)
\\
~~\cd{end}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomExercise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSolution}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR4:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR4:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The programmer might have reasoned like this: the two functions <span class="math inline">\(\texttt{left}\)</span> and <span class="math inline">\(\texttt{right}\)</span> finish by writing to two different references <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> respectively. Since they write respectively the values <span class="math inline">\(\text{&#39;}\,{\texttt{left}}\,\text{&#39;}\)</span> and <span class="math inline">\(\text{&#39;}\,{\texttt{right}}\,\text{&#39;}\)</span>, the returned value will be <span class="math inline">\((\text{&#39;}\,{\texttt{left}}\,\text{&#39;}, \text{&#39;}\,{\texttt{right}}\,\text{&#39;})\)</span>.</p>
<p>This is wrong because it consider only one possible execution order. There are many others. For example, the function <span class="math inline">\(\texttt{left}\)</span> might execute to completion and then <span class="math inline">\(\texttt{right}\)</span>. In this case, the returned value will be <span class="math inline">\((\text{&#39;}\,{\texttt{right}}\,\text{&#39;}, \text{&#39;}\,{\texttt{right}}\,\text{&#39;})\)</span>. The converse is also possible resulting in the return value <span class="math inline">\((\text{&#39;}\,{\texttt{left}}\,\text{&#39;}, \text{&#39;}\,{\texttt{left}}\,\text{&#39;})\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The programmer might have reasoned like this: the two functions
$\cd{left}$ and $\cd{right}$ finish by writing to two different
references $x$ and $y$ respectively.  Since they write respectively
the values $\cstr{left}$ and $\cstr{right}$, the returned value will
be $(\cstr{left}, \cstr{right})$.

This is wrong because it consider only one possible execution order.  
%
There are many others.  For example, the function $\cd{left}$ might
execute to completion and then $\cd{right}$.  In this case, the
returned value will be $(\cstr{right}, \cstr{right})$.
%
The converse is also possible resulting in the return value 
$(\cstr{left}, \cstr{left})$.

\end{dilFieldBodyDex}
\end{dilAtomSolution}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Verifying the correctness of an effectful algorithm can require checking a very large number, e.g., billions or more, of different execution possibilities. It is nearly impossible for any human being to comprehend such numbers of different possibilities. There are indeed many examples of parallelism or concurrency bugs in real systems that lead to sometimes catastrophic outcomes.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Verifying the correctness of an effectful algorithm can require
checking a very large number, e.g., billions or more, of different
execution possibilities.
%
It is nearly impossible for any human being to comprehend such numbers
of different possibilities.
%
There are indeed many examples of parallelism or concurrency bugs in
real systems that lead to sometimes catastrophic outcomes.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>There are several spectacular examples of correctness problems caused by race-conditions, including for example the Northeast blackout of 2003, which affected over 50 Million people in North America.</p>
<p>Here are some quotes from the spokesmen of the companies involved in this event.</p>
<p>The first quote below describes the problem, which is a race condition (multiple computations writing to the same piece of data). &quot;There was a couple of processes that were in contention for a common data structure, and through a software coding error in one of the application processes, they were both able to get write access to a data structure at the same time [...] And that corruption led to the alarm event application getting into an infinite loop and spinning.&quot;</p>
<p>The second quote describes the difficulty of finding the bug. &quot;This fault was so deeply embedded, it took them [the team of engineers] weeks of poring through millions of lines of code and data to find it.&quot;</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
There are several spectacular examples of correctness problems caused
by race-conditions, including for example the Northeast blackout of
2003, which affected over 50 Million people in North America.

Here are some quotes from the spokesmen of the companies involved in
this event.
%

The first quote below describes the problem, which is a race
condition (multiple computations writing to the same piece of data).
%
"There was a couple of processes that were in contention for a common
data structure, and through a software coding error in one of the
application processes, they were both able to get write access to a
data structure at the same time [...] And that corruption led to the
alarm event application getting into an infinite loop and spinning."
%

The second  quote describes the difficulty of finding the bug.
%
"This fault was so deeply embedded, it took them [the team of
  engineers] weeks of poring through millions of lines of code and
data to find it."

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}
Heisenbug
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Heisenbug
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Race conditions make it difficult to reason about the correctness and the efficiency of parallel algorithms. They also make debugging difficult, because each time the code is run, it might give a different answer. For example, each time we evaluate a piece of code, we may obtain a different answer or we may obtain a correct answer 99.99% of the time but not always.</p>
<p>The term  <span style="color: black"><span><strong><em>Heisenbug</em></strong></span></span> was coined in the early 80s to refer to a type of bug that “disappears” when you try to pinpoint or study it and “appears” when you stop studying it. They are named after the famous Heisenberg uncertainty principle which roughly says that if you localize one property, you will lose information about another complementary property. Often the most difficult Heisenbugs to find have to do with race conditions in parallel or concurrent code. These are sometimes also called concurrency bugs.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Race conditions make it difficult to reason about the correctness and
the efficiency of parallel algorithms.  They also make debugging
difficult, because each time the code is run, it might give a
different answer.
%
For example, each time we evaluate a piece of code, we may obtain a
different answer or we may obtain a correct answer 99.99\% of the time
but not always.
%

The term~\defn{Heisenbug} was coined in the early 80s to refer to a
type of bug that ``disappears'' when you try to pinpoint or study it
and ``appears'' when you stop studying it.  They are named after the
famous Heisenberg uncertainty principle which roughly says that if you
localize one property, you will lose information about another
complementary property.  Often the most difficult Heisenbugs to find
have to do with race conditions in parallel or concurrent code.  These
are sometimes also called concurrency bugs.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH3:SEC3:UN5:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}

\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH3:SEC3:UN5:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH3:SEC3:UN5:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>What are all the different outcomes of the example given above?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
What are all the different outcomes of the example given above?

\end{dilFieldBodyDex}
\end{dilAtomExercise}
\end{dilGroup}
\end{dilUnit}
\end{dilSection}
\end{dilChapter}
\end{dilBook}
\end{dilCourse}
