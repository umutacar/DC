<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Specification, Problem, and Implementation
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Specification, Problem, and Implementation
]]>
</field> <!-- title_src -->
<field name='label'>
ch:introduction::spec
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prmbl:introduction::spec::reviews
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='preamble'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prmbl:introduction::spec::reviews
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This chapter reviews the basic concepts of specification, problem, and implementation.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This chapter reviews the basic concepts of specification, problem, and
implementation.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- preamble -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Problem solving in computer science requires reasoning precisely about problems being studied and the properties of solutions. To facilitate such reasoning, we define problems by specifying them and describe the desired properties of solutions at different levels of abstraction, including the cost of the solution, and its implementation.</p>
<p>In this book, we are usually interested in two distinct classes of problems: algorithms or algorithmic problems and data structures problems.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Problem solving in computer science requires reasoning precisely about
problems being studied and the properties of solutions.
To facilitate such reasoning,  we define problems by
specifying them and describe the desired properties of solutions at
different levels of abstraction, including the cost of the solution, and its
implementation.

In this book, we are usually interested in two distinct classes of
problems: algorithms or algorithmic problems and data structures
problems.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Algorithm Specification
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Algorithm Specification
]]>
</field> <!-- title_src -->
<field name='label'>
sec:introduction::spec::algorithm-specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::specify
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::specify
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We specify an algorithm by describing what is expected of the algorithm via an  <strong><em>algorithm specification</em></strong> . For example, we can specify a sorting algorithm for sequences with respect to a given comparison function as follows.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We specify an algorithm by describing what is expected of the
algorithm via an~\defn{algorithm specification}.
For example, we can specify a sorting algorithm for sequences with
respect to a given comparison function as follows.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:introduction::spec::comparison-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Comparison Sort
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Comparison Sort
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:introduction::spec::comparison-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Given a sequence <span class="math inline">\(A\)</span> of <span class="math inline">\(n\)</span> elements taken from a totally ordered set with comparison operator <span class="math inline">\(&lt;\)</span>, return a sequence <span class="math inline">\(B\)</span> containing the same elements but such that <span class="math inline">\(B[i] \leq  
B[j]\)</span> for <span class="math inline">\(0 \leq i &lt; j &lt; n\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Given a sequence $A$ of $n$ elements taken from a totally ordered set
with comparison operator $<$, return a
sequence $B$ containing the same elements but such that $B[i] \leq
B[j]$ for $0 \leq i < j < n$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:nt:introduction::spec::specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
nt:introduction::spec::specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The specification describes  <strong><em>what</em></strong> the algorithm should do but it does not describe  <strong><em>how</em></strong> it achieves what is asked. This is intentional—and is exactly the point—because there can be many algorithms that meet a specification.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The specification describes~\defn{what} the algorithm should do but it
does not describe~\defn{how} it achieves what is asked.
This is intentional---and is exactly the point---because there can be
many algorithms that meet a specification.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::crucial
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::crucial
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A crucial property of any algorithm is its resource requirements or its  <strong><em>cost</em></strong> . For example, of the many ways algorithms for sorting a sequence, we may prefer some over the others. We specify the cost of class of algorithms with a  <strong><em>cost specification</em></strong> . The following cost specification states that a particular class of parallel sorting algorithms performs <span class="math inline">\(O(n  
\log{n})\)</span> work and <span class="math inline">\(O(\log^2{n})\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A crucial property of any algorithm is its resource requirements or
its~\defn{cost}.
For example, of the many ways algorithms for sorting a sequence, we
may prefer some over the others.  
We specify the cost of class of algorithms with a~\defn{cost
  specification}.  The following cost specification states that a
particular class of parallel sorting algorithms performs $O(n
\log{n})$ work and $O(\log^2{n})$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:cost:intro::spec::sorting-efficient
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='costspec'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Comparison Sort: Efficient &amp; Parallel
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Comparison Sort: Efficient \& Parallel
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
cost:intro::spec::sorting-efficient
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n \log n)\)</span> work and <span class="math inline">\(O(\log^2 n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{cost:intro::spec::sorting-efficient}
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n \log n)$
work and $O(\log^2 n)$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- costspec -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::cost
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::cost
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>There can be many cost specifications for sorting. For example, if we are not interested in parallelism, we can specify the work to be <span class="math inline">\(O(n  
\log{n})\)</span> but leave span unspecified. <a href="cost:intro::spec::sorting-inefficient">The cost specification below</a> requires even smaller span but allows for more work. We usually care more about work and thus would prefer the first cost specification; there might, however, be cases where the second specification is preferable.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
There can be many cost specifications for sorting.  For example, if we
are not interested in parallelism, we can specify the work to be $O(n
\log{n})$ but leave span unspecified. 
\href{cost:intro::spec::sorting-inefficient}{The cost specification below}
requires even smaller span but allows for more work.
We usually care more about work and thus would prefer the first cost
specification; there might, however, be cases where the second
specification is preferable.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:cost:intro::spec::sorting-inefficient
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='costspec'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Comparison Sort: Inefficient but Parallel
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Comparison Sort: Inefficient but Parallel
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
cost:intro::spec::sorting-inefficient
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Assuming the comparison function <span class="math inline">\(&lt;\)</span> does constant work, the cost for parallel comparison sorting a sequence of length <span class="math inline">\(n\)</span> is <span class="math inline">\(O(n^2)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{cost:intro::spec::sorting-inefficient}
Assuming the comparison function $<$ does constant work, the cost for
parallel comparison sorting a sequence of length $n$ is $O(n^2)$ work
and $O(\log n)$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- costspec -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Data Structure Specification
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Data Structure Specification
]]>
</field> <!-- title_src -->
<field name='label'>
sec:introduction::spec::data-structure-specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::data
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::data
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We specify a data structure by describing what is expected of the data structure via an  <strong><em>Abstract Data Type (ADT) specification</em></strong> . As with algorithms, we usually give cost specifications to data structures. For example, we can specify a priority queue ADT and give it a cost specification.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We specify a data structure by describing what is expected of the data
structure via an~\defn{Abstract Data Type (ADT) specification}.
As with algorithms, we usually give cost specifications to data
structures.
For example, we can specify a priority queue ADT and give it a cost
specification.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:adt:introduction::spec::priority-queue
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='datatype'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Priority Queue
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Priority Queue
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
adt:introduction::spec::priority-queue
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A priority queue consists of a priority queue type and supports three operations on values of this type. The operation <span class="math inline">\(\texttt{empty}\)</span> returns an empty queue. The operation <span class="math inline">\(\texttt{insert}\)</span> inserts a given value with a priority into the queue and returns the queue. The operation <span class="math inline">\(\texttt{removeMin}\)</span> removes the value with the smallest priority from the queue and returns it.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A priority queue consists of a priority queue type and supports three
operations on values of this type.  The operation $\cd{empty}$ returns
an empty queue.  The operation $\cd{insert}$ inserts a given value with
a priority into the queue and returns the queue.  The operation
$\cd{removeMin}$ removes the value with the smallest priority from the
queue and returns it.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- datatype -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:cst:introduction::spec::priority-queue-basic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='costspec'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Priority Queue: Basic
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Priority Queue: Basic
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
cst:introduction::spec::priority-queue-basic
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The work and span of a priority queue operations are as follows.</p>
<ul>
<li><p><span class="math inline">\(\texttt{empty}\)</span>: <span class="math inline">\(O(1)\)</span>, <span class="math inline">\(O(1)\)</span>.</p></li>
<li><p><span class="math inline">\(\texttt{insert}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
<li><p><span class="math inline">\(\texttt{removeMin}\)</span>: <span class="math inline">\(O(\log{n})\)</span>, <span class="math inline">\(O(\log{n})\)</span>.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The work and span of a priority queue operations are as follows.
\begin{itemize}
\item $\cd{empty}$: $O(1)$, $O(1)$.
\item $\cd{insert}$: $O(\log{n})$, $O(\log{n})$.
\item $\cd{removeMin}$: $O(\log{n})$, $O(\log{n})$.
\end{itemize}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- costspec -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Problem
]]>
</field> <!-- title_src -->
<field name='label'>
sec:introduction::spec::problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::requires
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::requires
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A  <strong><em>problem</em></strong> requires meeting an algorithm or an ADT specification and a corresponding cost specification. Since we allow specifying algorithms and data structures, we can distinguish between algorithms problems and data-structure problems.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A~\defn{problem} requires meeting an algorithm or an ADT specification
and a corresponding cost specification.
Since we allow specifying algorithms and data structures, we can
distinguish between algorithms problems and data-structure problems.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:intro::spec::algorithmic-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Algorithmic Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Algorithmic Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:intro::spec::algorithmic-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> An  <strong><em>algorithmic problem</em></strong>  or an  <strong><em>algorithms problem</em></strong>  requires designing an algorithm that satisfies the given algorithm specification and cost specification if any.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:intro::spec::algorithmic-problem}
An~\defn{algorithmic problem}~or an~\defn{algorithms problem}~requires
designing an algorithm that satisfies the given algorithm
specification and cost specification if any.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:intro::spec::ds-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Data-Structures Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Data-Structures Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:intro::spec::ds-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A  <strong><em>data-structures problem</em></strong>  requires meeting an ADT specification by designing a data structure that can support the desired operations with the required efficiency specified by the cost specification.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:intro::spec::ds-problem}

A~\defn{data-structures problem}~requires meeting an ADT
specification by designing a data structure that can
support the desired operations with the required efficiency specified
by the cost specification.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:nt:introduction::spec::difference
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
nt:introduction::spec::difference
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The difference between an algorithmic problem and a data-structures problem is that the latter involves designing a data structure and a collection of algorithms, one for each operation, that operate on that data structure.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The difference between an algorithmic problem and a data-structures
problem is that the latter involves designing a data structure and a
collection of algorithms, one for each operation, that operate on that
data structure.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:rmrk:introduction::spec::considering
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='remark'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
rmrk:introduction::spec::considering
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>When we are considering a problem, it is usually clear from the context whether we are talking about an algorithm or a data structure. We therefore usually use the simpler terms  <strong><em>specification</em></strong>   <strong><em>problem</em></strong>  to refer to the algorithm/ADT specification and the corresponding problem respectively.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
When we are considering a problem, it is usually clear from the context whether we are talking about an algorithm or a data structure.
We therefore usually use the simpler terms~\defn{specification}~\defn{problem}~to refer to the algorithm/ADT specification and the corresponding problem respectively.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- remark -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Implementation
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Implementation
]]>
</field> <!-- title_src -->
<field name='label'>
sec:introduction::spec::implementation
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:introduction::spec::solve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:introduction::spec::solve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can solve an algorithms or a data-structures problem by presenting an  <strong><em>implementation</em></strong> or code written is some formal or semi-formal programming language. The term  <strong><em>algorithm</em></strong>  refers to an implementation that solves an algorithms problem and the term  <strong><em>data structure</em></strong>  to refer to an implementation that solves a data-structures problem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can solve an algorithms or a data-structures problem by presenting an~\defn{implementation} or code written is some formal or semi-formal programming language.  
The term~\defn{algorithm}~refers to an implementation that solves an algorithms problem and the term~\defn{data structure}~to refer to an implementation that solves a data-structures problem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:nt:introduction::spec::distinction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
nt:introduction::spec::distinction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The distinction between algorithmic problems and algorithms is common in the literature but the distinction between abstract data types and data structures is less so.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The distinction between algorithmic problems and algorithms is common
in the literature but the distinction between abstract data types and
data structures is less so.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:introduction::spec::think
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachnote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:introduction::spec::think
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Why do we think this distinction is important?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Why do we think this distinction is important?
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachnote -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:xmpl:introduction::spec::insertion-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Insertion Sort
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Insertion Sort
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:introduction::spec::insertion-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In this book, we describe algorithms by using the pseudo-code notation based on SPARC, the language used in this book. For example, we can specify the classic insertion sort algorithm as follows.</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{insSort}~f~s =  
\\   
~~~~\texttt{if}~|s| = 0~\texttt{then}   
\\  
~~~~~~~~\left\langle\,  \,\right\rangle  
\\  
~~~~\texttt{else}~\mathit{insert}~f~s[0]~(\mathit{insSort}~f~(s[1,...,n-1]))  
\end{array}\]</span></p>
<p>In the algorithm, <span class="math inline">\(f\)</span> is the comparison function and <span class="math inline">\(s\)</span> is the input sequence. The algorithm uses a function (<span class="math inline">\(\texttt{insert}~f~x~s\)</span>) that takes the comparison function <span class="math inline">\(f\)</span>, an element <span class="math inline">\(x\)</span>, and a sequence <span class="math inline">\(s\)</span> sorted by <span class="math inline">\(f\)</span>, and inserts <span class="math inline">\(x\)</span> in the appropriate place. Inserting into a sorted sequence is itself an algorithmic problem, since we are not specifying how it is implemented, but just specifying its functionality.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In this book, we describe algorithms by using the pseudo-code notation based on \pml{}, the language used in this book.
For example, we can specify the classic insertion sort algorithm as
follows.

\[
\begin{array}{l}
\cdvar{insSort}~f~s =
\\ 
~~~~\cd{if}~|s| = 0~\cd{then} 
\\
~~~~~~~~\cseq{}
\\
~~~~\cd{else}~\cdvar{insert}~f~s[0]~(\cdvar{insSort}~f~(s[1,...,n-1]))
\end{array}
\]


In the algorithm, $f$ is the comparison function and $s$ is the input
sequence.  The algorithm uses a function ($\cd{insert}~f~x~s$) that takes the comparison function $f$, an element $x$, and a sequence $s$ sorted by $f$, and inserts $x$ in the appropriate place.  
Inserting into a sorted sequence is itself an algorithmic problem, since we are not specifying how it is implemented, but just specifying its functionality.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:xmpl:introduction::spec::cost-of-insertion-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost of Insertion Sort
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost of Insertion Sort
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:introduction::spec::cost-of-insertion-sort
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Considering insertion sort example, suppose that we are given a cost specification for <span class="math inline">\(\texttt{insert}\)</span>: for a sequence of length <span class="math inline">\(n\)</span> the cost of <span class="math inline">\(\texttt{insert}\)</span> should be <span class="math inline">\(O(n)\)</span> work and <span class="math inline">\(O(\log n)\)</span> span. We can then determine the overall asymptotic cost of <span class="math inline">\(\texttt{sort}\)</span> using our composition rules described in <a href="sec:introduction::parallelism::work-span">Section (Work, Span, and Parallel Time)</a>. Since the code uses <span class="math inline">\(\texttt{insert}\)</span> sequentially and since there are <span class="math inline">\(n\)</span> inserts, the algorithm <span class="math inline">\(\texttt{insSort}\)</span> has <span class="math inline">\(n \times O(n) = O(n^2)\)</span> work and <span class="math inline">\(n \times O(\log n) = O(n \log n)\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Considering insertion sort example, suppose that we are given a cost specification for $\cd{insert}$: for a sequence of length $n$ the cost of $\cd{insert}$ should be $O(n)$ work and $O(\log n)$ span.
We can then determine the overall asymptotic cost of $\cd{sort}$ using our composition rules described in 
\href{sec:introduction::parallelism::work-span}
{Section (Work, Span, and Parallel Time)}.
Since the code uses $\cd{insert}$ sequentially and since there are $n$ inserts, the algorithm $\cd{insSort}$ has $n \times O(n) = O(n^2)$ work and $n \times O(\log n) = O(n \log n)$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:xmpl:introduction::spec::priority-queues
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Priority Queues
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Priority Queues
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:introduction::spec::priority-queues
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can give a data structure by specifying the data type used by the implementation, and the algorithms for each operation. For example, we can implement a priority queue with a binary heap data structure and describe each operation as an algorithm that operates on this data structure. In other words, a data structure can be viewed as a collection of algorithms that operate on the same organization of the data.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can give a data structure by specifying the data type used by the implementation, and the algorithms for each operation.
For example, we can implement a priority queue with a binary heap data structure and describe each operation as an algorithm that operates on
this data structure.  
In other words, a data structure can be viewed as a collection of algorithms that operate on the same organization of the data.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:rmrk:introduction::spec::on-the-importance-of-specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='remark'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
On the Importance of Specification
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
On the Importance of Specification
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
rmrk:introduction::spec::on-the-importance-of-specification
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Distinguishing between specification and implementation is important due to several reasons.</p>
<p>First, specifications allow us to ignore the details of an implementation that we might not care to know. In many cases the specification of a problem is quite simple, but an efficient algorithm or implementation that solves it is complicated. Specifications allow us abstract from implementation details.</p>
<p>Second, specifications allow modularity. In computer science, it is important to improve implementations over time. As long as each implementation matches the same specification and the client only relies on the specification, then new implementations can be used without breaking things.</p>
<p>Third, when we compare the performance of different algorithms or data structures it is important that we do not compare apples and oranges. We have to make sure the compared objects solve the same problem—subtle differences in the problem specification can make a significant difference in how efficiently that problem can be solved.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Distinguishing between specification and implementation is important due to several reasons.

First, specifications allow us to ignore the details of an implementation that we might not care to know.
In many cases the specification of a problem is quite simple, but an efficient algorithm or implementation that solves it is complicated.
Specifications allow us abstract from implementation details.

Second, specifications allow modularity. In computer science, it is important to improve implementations over time.  As long as each implementation matches the same specification and the client only relies on the specification, then new implementations can be used without breaking things.

Third, when we compare the performance of different algorithms or data structures it is important that we do not compare apples and oranges. We have to make sure the compared objects solve the same problem---subtle differences in the problem specification can make a significant difference in how efficiently that problem can be solved.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- remark -->

</segment> <!-- cluster -->


</segment> <!-- section -->

</segment> <!-- chapter -->
