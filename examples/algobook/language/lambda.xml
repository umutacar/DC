<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
The Lambda Calculus
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
The Lambda Calculus
]]>
</field> <!-- title_src -->
<field name='label'>
ch:lambda-calculus
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prmbl:lambda-calculus::describes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='preamble'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prmbl:lambda-calculus::describes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This section briefly describes the lambda calculus, one of the earliest and most important contributions to computer science. It is is a pure language, only supporting pure functions, and it fully supports higher-order functions.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This section briefly describes the lambda calculus, one of the
earliest and most important contributions to computer science.   It is
is a pure language, only supporting pure functions, and it fully
supports higher-order functions.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- preamble -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::lamba
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::lamba
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The lamba calculus, developed by Alonzo Church in the early 30s, is arguably the first general purpose “programming language”. Although it is very simple with only three types of expressions, and one rule for “evaluation”, it captures many of the core ideas of modern programming languages. The idea of variables, functions, and function application are built in. Although conditionals and recursion are not built in, they can be easily implemented. Furthermore, although it has no primitive data types, integers, lists, trees, and other structures, can also be easily implemented. Perhaps most importantly for this book, and impressive given it was developed before computers even existed, the lambda calculus in inherently parallel. The language (pseudocode) we use in this book, SPARC, is effectively an extended and typed lambda calculus.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The lamba calculus, developed by Alonzo Church in the early 30s, is arguably
  the first general purpose ``programming language''.  
  Although it is very simple with
  only three types of expressions, and one rule for ``evaluation'', it
  captures many of the core ideas of modern
  programming languages.  
  The idea of variables, functions, and
  function application are built in.  
  Although conditionals and
  recursion are not built in, they can be easily implemented.
  Furthermore, although it has no primitive data types, integers,
  lists, trees, and other structures, can also be easily implemented.    
  Perhaps most importantly for this book, and impressive given it was
  developed before computers even existed, the lambda calculus in
  inherently parallel.
  The language (pseudocode) we use in this book, \PML{}, is
  effectively an extended and typed lambda calculus.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Syntax and Semantics
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Syntax and Semantics
]]>
</field> <!-- title_src -->
<field name='label'>
sec:lc::syntax-and-semantics
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:lc::syntax
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Syntax of the Lambda Calculus
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Syntax of the Lambda Calculus
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:lc::syntax
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> The lambda calculus consists of expressions <span class="math inline">\(e\)</span> that are in one of the following three forms:</p>
<ul>
<li><p>a <strong><em>variable</em></strong> , such as <span class="math inline">\(x, y, z, \ldots\)</span>,</p></li>
<li><p>a <strong><em>lambda abstraction</em></strong> , written as <span class="math inline">\((\lambda~x~.~e)\)</span>, where <span class="math inline">\(x\)</span> is a variable name and <span class="math inline">\(e\)</span> is an expression, or</p></li>
<li><p>an <strong><em>application</em></strong> , written as <span class="math inline">\((e_1~e_2)\)</span>, where <span class="math inline">\(e_1\)</span> and <span class="math inline">\(e_2\)</span> are expressions.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:lc::syntax}
The lambda calculus consists of expressions $e$ that are in one
of the following three forms:

\begin{itemize}
\item a \defn{variable}, such as $x, y, z, \ldots$,

\item a \defn{lambda abstraction}, written as $(\lambda~x~.~e)$, where $x$ is a variable name and $e$ is
  an expression, or

\item an \defn{application}, written as $(e_1~e_2)$, where $e_1$ and
  $e_2$ are expressions.
\end{itemize}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::lambda
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::lambda
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A lambda abstraction <span class="math inline">\((\lambda~x~.~e)\)</span> defines a function where <span class="math inline">\(x\)</span> is the argument parameter and <span class="math inline">\(e\)</span> is the body of the function, likely containing <span class="math inline">\(x\)</span>, possibly more than once. An application <span class="math inline">\((e_1~e_2)\)</span> indicates that the function calculated from <span class="math inline">\(e_1\)</span> should be applied to the expression <span class="math inline">\(e_2\)</span>. This idea of function application is captured by beta reduction.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
{}
A lambda abstraction $(\lambda~x~.~e)$  defines a function where $x$ is the argument parameter 
and $e$ is the body of the function, likely containing $x$, possibly
more than once.    An application $(e_1~e_2)$ indicates 
that the function calculated from $e_1$ should be applied to the expression $e_2$.   This idea 
of function application is captured by beta reduction.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:lc::beta
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Beta Reduction
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Beta Reduction
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:lc::beta
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> For any application for which the left hand expression is a lambda abstraction, beta reduction “applies the function” by making the transformation: <span class="math display">\[(\lambda~x~.~e_1)~e_2 \longrightarrow e_1[x/e_2]\]</span> where <span class="math inline">\(e_1[x/e_2]\)</span> roughly means for every (free) occurrence of <span class="math inline">\(x\)</span> in <span class="math inline">\(e_1\)</span>, substitute it with <span class="math inline">\(e_2\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:lc::beta}
For any application for which the left hand expression is a lambda abstraction, beta reduction ``applies the function'' by making the 
transformation: 
\[ (\lambda~x~.~e_1)~e_2 \longrightarrow e_1[x/e_2] \]
where $e_1[x/e_2]$ roughly means for every (free) occurrence of $x$ in 
$e_1$, substitute it with $e_2$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::standard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::standard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that this is the standard notion of function application, in which we pass in the value or the argument(s) by setting the function variables to those values.</p>
<p>Computation in the lambda calculus consists of using beta reduction until there is nothing left to reduce. An expression that has nothing left to reduce is in <strong><em>normal form</em></strong> . It is possible that an expression in the lambda calculus can “loop forever” never reducing to normal form. Indeed, the possibility of looping forever is crucial in any general (Church-Turing complete) computational model.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that this is the standard notion of function application, in
which we pass in the value or the argument(s) by setting the function variables
to those values.

Computation in the \lc{} consists of 
using beta reduction until there is nothing left to reduce.  
An expression that has nothing left to reduce is in \defn{normal
  form}.
It is possible that an expression in the lambda calculus can ``loop
forever'' never reducing to normal form.   Indeed, the possibility of
looping forever is crucial in any general (Church-Turing complete) computational model.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

<atom name='exercise'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xrcs:lambda-calculus::argue
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Argue that the following expression in the lamba calculus never reduces to normal form, i.e., however many times beta reduction is applied, it can still be applied again. <span class="math display">\[((\lambda~x~.(x~x))~(\lambda~x~.(x~x)))~.\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Argue that the following expression in the lamba calculus never
reduces to normal form, i.e., however many times beta reduction is
applied, it can still be applied again.
\[ ((\lambda~x~.(x~x))~(\lambda~x~.(x~x)))~.\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- exercise -->

<atom name='solution'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
sol:lambda-calculus::beta
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A beta reduction will replace the two <span class="math inline">\(x\)</span>s in the first lambda with the second lambda. This will generate the same expression as the original. This can be repeated any number of times, and will always come to the same point.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A beta reduction will replace the two $x$s in the first lambda with
the second lambda.    This will generate the same expression as the
original.   This can be repeated any number of times, and will always
come to the same point.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- solution -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::church-turing-hypothesis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Church-Turing Hypothesis
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Church-Turing Hypothesis
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::church-turing-hypothesis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In the early 30s, soon after he developed the language, Church argued that anything that can be “effectively computed” can be computed with the lambda calculus, and therefore it is a universal mechanism for computation. However, it was not until a few years later when Alan Turing developed the Turing machine and showed its equivalence to the lambda calculus that the concept of universality became widely accepted. The fact that the models were so different, but equivalent in what they can compute, was a powerful argument for the universality of the models. We now refer to the hypothesis that anything that can be computed can be computed with the lambda calculus, or equivalently the Turing machine, as the  <strong><em>Church-Turing hypothesis</em></strong> , and refer to any computational model that is computationally equivalent to the lambda calculus as  <strong><em>Church-Turing complete</em></strong> .</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In the early 30s, soon after he developed the language, Church argued that anything that can be ``effectively
computed'' can be computed with the lambda calculus, and therefore
it is a universal mechanism for computation.  
However, it was not until a few years later when Alan Turing developed
the Turing machine and showed its equivalence to the lambda calculus
that the concept of universality became widely accepted.  The fact
that the models were so different, but equivalent in what they can
compute, was a powerful argument for the universality of the models.
We now refer to the hypothesis that anything that can be computed can
be computed with the lambda calculus, or equivalently the Turing
machine, as the~\defn{Church-Turing hypothesis}, and refer to any
computational model that is computationally equivalent to the lambda
calculus as~\defn{Church-Turing complete}.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Parallelism and Reduction Order
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Parallelism and Reduction Order
]]>
</field> <!-- title_src -->
<field name='label'>
sec:lc::call-by-value-and-need
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::unlike
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::unlike
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Unlike the Turing machine, the lambda calculus is inherently parallel. This is because there can be many applications in an expression for which beta reduction can be applied, and the lambda calculus allows them to be applied in any order, including a parallel order—e.g., all at once. We have to be careful, however, since the number of reductions needed to evaluate an expression (reduce to normal form) can depend significantly on the reduction order. In fact, some orders might terminate while others will not. Because of this, specific orders are used in practice. The two most prominent orders adopted by programming languages are called “call-by-value” and “call-by-need.” In both these orders lambda abstractions are considered values and beta reductions are not applied inside of them.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Unlike the Turing machine, the lambda calculus is inherently parallel.
This is because there can be many applications in an expression
for which beta reduction can be applied,
and the lambda calculus allows them to be applied in any order,
including a parallel order---e.g., all at once.
We have to be careful, however, since the number of reductions needed
to evaluate an expression (reduce to normal form) can depend
significantly on the reduction order.  In fact, some orders might
terminate while others will not.
Because of this, specific orders are used in practice.
The two most prominent orders adopted by programming
languages are called ``call-by-value'' and
``call-by-need.''    
In both these orders lambda abstractions are considered values and 
beta reductions are not applied inside of them.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:lambda-calculus::call-by-value
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Call-by-Value
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Call-by-Value
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:lambda-calculus::call-by-value
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In  <strong><em>call-by-value</em></strong> evaluation order, beta reduction is only applied to <span class="math inline">\((\lambda~x~.~e_1)~e_2\)</span> if the expression <span class="math inline">\(e_2\)</span> is a value, i.e., <span class="math inline">\(e_2\)</span> is evaluated to a value (lambda abstraction) first, and then beta reduction is applied.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In~\defn{call-by-value} evaluation order, beta reduction is only applied to
$(\lambda~x~.~e_1)~e_2$ if the expression $e_2$
is a value, i.e., $e_2$ is evaluated to a value (lambda abstraction)
first, and then
beta reduction is applied.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:lambda-calculus::class
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The ML class of languages such as Standard ML, CAML, and OCAML, all use call-by-value evaluation order.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The ML class of languages such as Standard ML, CAML, and OCAML, all
use call-by-value evaluation order.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:lambda-calculus::call-by-need
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Call-by-Need
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Call-by-Need
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:lambda-calculus::call-by-need
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In  <strong><em>call-by-need</em></strong> evaluation order, beta reduction is applied to <span class="math inline">\((\lambda~x~.~e_1)~e_2\)</span> even if <span class="math inline">\(e_2\)</span> is not a value (it could be another application). If during beta reduction <span class="math inline">\(e_2\)</span> is copied into each variable <span class="math inline">\(x\)</span> in the body, this reduction order is called  <strong><em>call-by-name</em></strong> , and if <span class="math inline">\(e_2\)</span> is shared, it is called call-by-need.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In~\defn{call-by-need} evaluation order,
beta reduction is applied to
$(\lambda~x~.~e_1)~e_2$ even if $e_2$ is not a value (it could be another application).
If during beta reduction $e_2$ is copied into each variable $x$ in the
body, this reduction order is called~\defn{call-by-name}, and if $e_2$
is shared, it is called call-by-need.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:lambda-calculus::haskell
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The Haskell language is perhaps the most well known example of a call-by-need (or lazy) functional language.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The Haskell language is perhaps the most well known example of a
call-by-need (or lazy) functional language.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::neither
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::neither
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Since neither reduction order reduce inside of a lambda abstraction, neither of them reduce expressions to normal form. Instead they reduce to what is called “weak head normal form”. However, both reduction orders, as with most orders, remain Church-Turing complete.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Since neither reduction order reduce inside of a
  lambda abstraction, neither of them reduce expressions to normal form.  Instead they
  reduce to what is called ``weak head normal form''.
  However, both reduction orders, as with most orders, remain Church-Turing complete.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:lambda-calculus::call-by-value
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:lambda-calculus::call-by-value
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Call-by-value is an inherently parallel reduction order. This is because in an expression <span class="math inline">\((e_1~e_2)\)</span> the two subexpressions can be evaluated (reduced) in parallel, and when both are fully reduced we can apply beta reduction to the results. Evaluating in parallel, or not, has no effect on which reductions are applied, only on the order in which they are applied. On the other hand call-by-need is inherently sequential. In an expression <span class="math inline">\((e_1~e_2)\)</span> only the first subexpression can be evaluated and when completed we can apply beta reduction to the resulting lamba abstraction by substituting in the second expression. Therefore the second expression cannot be evaluated until the first is done without potentially changing which reductions are applied.</p>
<p>In this book we use call-by-value.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Call-by-value is an inherently parallel reduction order.    This is
because in an expression $(e_1~e_2)$ the two subexpressions can be
evaluated (reduced) in parallel, and when both are fully reduced we can apply
beta reduction to the results.    Evaluating in parallel, or not, has no
effect on which reductions are applied, only on the order in which
they are applied.
On the other hand call-by-need is inherently sequential.    In an
expression $(e_1~e_2)$  only the first subexpression can be evaluated and
when completed we can apply beta reduction to the resulting lamba
abstraction by substituting in the second expression.     Therefore
the second expression cannot be evaluated until the first is done
without potentially changing which reductions are applied.

In this book we use call-by-value.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

</segment> <!-- chapter -->
