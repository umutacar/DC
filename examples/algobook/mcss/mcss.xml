<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Maximum Contiguous Subsequence Sum
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Maximum Contiguous Subsequence Sum
]]>
</field> <!-- title_src -->
<field name='label'>
ch:mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prmbl:mcss::reviews
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='preamble'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prmbl:mcss::reviews
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This chapter reviews the classic problem of finding the contiguous subsequence of a sequence with the maximal value, and provides several algorithms for the problem by applying several design techniques including <a href="sec:design::bf">brute force</a>, <a href="sec:design::reduction">reduction</a>, and <a href="ch:design::dc">divide and conquer</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This chapter reviews the classic problem of finding the contiguous
subsequence of a sequence with the maximal value, 
and provides several algorithms for the problem by applying several design techniques including
\href{sec:design::bf}{brute force},
\href{sec:design::reduction}{reduction}, and
\href{ch:design::dc}{divide and conquer}.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- preamble -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
The Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
The Problem
]]>
</field> <!-- title_src -->
<field name='label'>
ch:mcss::problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::lecture
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachnote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::lecture
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This lecture needs a bit more structure. There are quite a few moving pieces complete the plot below and use it as a guide.</p>
<p>There are some glitches with -infty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This lecture needs a bit more structure.  There are quite a few moving
pieces complete the plot below and use it as a guide.  

There are some glitches with -infty.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachnote -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::graph
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachnote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::graph
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Here is a graph of various problems that we will consider.</p>
<p><img src="./mcss/media/mcs-reductions.jpg" alt="image" style="width:4in" /></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Here is a graph of various problems that we will consider.

\includegraphics[width=4in]{./mcss/media/mcs-reductions.jpg}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachnote -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::introduction::subseq
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Subsequence
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Subsequence
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::introduction::subseq
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A  <strong><em>subsequence</em></strong>  <span class="math inline">\(b\)</span> of a sequence <span class="math inline">\(a\)</span> is a sequence that can be derived from <span class="math inline">\(a\)</span> by deleting zero or more elements of <span class="math inline">\(a\)</span> without changing the order of remaining elements.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:mcss::introduction::subseq}

A~\defn{subsequence}~$b$ of a sequence~$a$ is a sequence that can be
derived from~$a$ by deleting zero or more elements of~$a$ without changing the
order of remaining elements.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:mcss::follow
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Several examples follow.</p>
<ul>
<li><p>The sequence <span class="math inline">\(\left\langle\, 0,2,4 \,\right\rangle\)</span> is a subsequence of <span class="math inline">\(\left\langle\, 0,1,2,2,3,4,5 \,\right\rangle\)</span>.</p></li>
<li><p>The sequence <span class="math inline">\(\left\langle\, 2,4,3 \,\right\rangle\)</span> is a not subsequence of <span class="math inline">\(\left\langle\, 0,1,2,2,3,4,5 \,\right\rangle\)</span> but <span class="math inline">\(\left\langle\, 2,3,4 \,\right\rangle\)</span> is.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Several examples follow.
\begin{itemize}
\item
The sequence $\cseq{0,2,4}$ is a subsequence of
$\cseq{0,1,2,2,3,4,5}$.

\item
The sequence $\cseq{2,4,3}$ is a not
subsequence of $\cseq{0,1,2,2,3,4,5}$ but $\cseq{2,3,4}$ is.
\end{itemize}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::introduction::consubseq
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Contiguous Subsequence
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Contiguous Subsequence
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::introduction::consubseq
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> A  <strong><em>contiguous subsequence</em></strong> is a subsequence that appears contiguously in the original sequence. For any sequence <span class="math inline">\(a\)</span> of <span class="math inline">\(n\)</span> elements, the subsequence <span class="math display">\[b =  a[i \cdots j], 0 \le i \le j &lt; n,\]</span> consisting of the elements of <span class="math inline">\(a\)</span> at positions <span class="math inline">\(i, i+1, \ldots, j\)</span> is a contiguous subsequence of <span class="math inline">\(b\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:mcss::introduction::consubseq}
A~\defn{contiguous subsequence} is a subsequence that appears
contiguously in the original sequence.
For any sequence~$a$ of~$n$ elements, the subsequence
\[
b =  a\cirange{i}{j}, 0 \le i \le j < n,
\]
consisting of the elements of~$a$ at positions~$i, i+1, \ldots, j$ is
a contiguous subsequence of~$b$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:mcss::contiguous
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>For <span class="math inline">\(a = \langle 1, -2, 0, 3, -1, 0, 2, -3 \left.\right\rangle\)</span>, here are some contiguous subsequences:</p>
<ul>
<li><p><span class="math inline">\(\left\langle\right.1 \left.\right\rangle\)</span>,</p></li>
<li><p><span class="math inline">\(\left\langle\right.-2, 0, 3 \left.\right\rangle\)</span>, and</p></li>
<li><p><span class="math inline">\(\left\langle\right.3, -1,  0, 2, -3 \left.\right\rangle\)</span>.</p></li>
</ul>
<p>The sequence <span class="math inline">\(\left\langle\right.-1,2,-3 \left.\right\rangle\)</span> is not a contiguous subsequence, even though it is a subsequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
For $a = \langle 1, -2, 0, 3, -1, 0, 2, -3 \cseqee$, here are some
contiguous subsequences:
\begin{itemize}
\item 
$\cseqbb 1 \cseqee$,

\item
$\cseqbb -2, 0, 3 \cseqee$, and

\item
$\cseqbb 3, -1,  0, 2, -3 \cseqee$.

\end{itemize}

The sequence~$\cseqbb -1,2,-3 \cseqee$ is not a contiguous subsequence,
even though it is a subsequence.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::introduction::mcs-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
The Maximum Contiguous Subsequence (<span class="sans-serif">MCS</span>) Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
The Maximum Contiguous Subsequence (\MCS{}) Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::introduction::mcs-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Given a sequence of integers, the  <strong><em>Maximum Contiguous Subsequence Problem</em></strong> (<span class="sans-serif">MCS</span>) requires finding the contiguous subsequence of the sequence with maximum total sum, i.e., <span class="math display">\[\begin{aligned}
    \textsf{MCS}{}\,(a) = \mathbf{arg\,max\,}_{0 \leq i,j &lt; |a|} \left( {\left( \sum_{k=i}^j a[k]  \right)} \right).  \end{aligned}\]</span> We define the sum of an empty sequence to be <span class="math inline">\({-\infty}{}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:mcss::introduction::mcs-problem}

Given a sequence of integers, 
the~\defn{Maximum Contiguous Subsequence Problem} (\MCS{}) requires finding the contiguous subsequence of the sequence with maximum total sum, i.e.,
\begin{eqnarray*}
    \MCS{}\,(a) = \argmax{0 \leq i,j < |a|}{\left( \sum_{k=i}^j a[k]  \right)}.
\end{eqnarray*}
We define the sum of an empty sequence to be~$\ninfty{}$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:mcss::-2
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>For <span class="math inline">\(a = \left\langle\, 1, -2, 0, 3, -1, 0, 2, -3 \left.\right\rangle \,\right\rangle,\)</span> a maximum contiguous subsequence is, <span class="math inline">\(\left\langle\, 3, -1, 0, 2 \,\right\rangle\)</span>; another is <span class="math inline">\(\left\langle\right.0, 3, -1, 0, 2 \left.\right\rangle.\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
For 
$a = \cseq{1, -2, 0, 3, -1, 0, 2, -3 \cseqee},$ 
a maximum contiguous subsequence is, 
$\cseq{3, -1, 0, 2}$;
another is 
$\cseqbb 0, 3, -1, 0, 2 \cseqee.$
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::introduction::mcss-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
The Maximum Contiguous Subsequence Sum (<span class="sans-serif">MCSS</span>) Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
The Maximum Contiguous Subsequence Sum (\MCSS{}) Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::introduction::mcss-problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Given a sequence of integers, the  <strong><em>Maximum Contiguous Subsequence Sum Problem</em></strong> (<span class="sans-serif">MCSS</span>)</p>
<p>requires finding the total sum of the elements in the contiguous subsequence of the sequence with maximum total sum, i.e., <span class="math display">\[\begin{aligned}
    \textsf{MCSS}{}\,(a) = \max \left\{ \sum_{k=i}^j a[k] \;:\; 0 \leq i,j &lt;  
      |a| \right\}.  
  \end{aligned}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{def:mcss::introduction::mcss-problem}
Given a sequence of integers,
the~\defn{Maximum Contiguous Subsequence Sum Problem} (\MCSS{})

requires finding
the total sum of the elements in the contiguous subsequence of the
sequence with maximum total sum, i.e.,
  \begin{eqnarray*}
    \MCSS{}\,(a) = \max \left\{ \sum_{k=i}^j a[k] \;:\; 0 \leq i,j <
      |a| \right\}.
  \end{eqnarray*}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:mcss::-1
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>For <span class="math inline">\(a = \left\langle\, 1, -2, 0, 3, -1, 0, 2, -3 \left.\right\rangle \,\right\rangle,\)</span> a maximum contiguous subsequence is, <span class="math inline">\(\left\langle\, 3, -1, 0, 2 \,\right\rangle;\)</span> another is <span class="math inline">\(\left\langle\right.0, 3, -1, 0, 2 \left.\right\rangle.\)</span> Thus <span class="math inline">\(\textsf{MCSS}{}~(a) = 4\)</span>.</p>
<p>For the empty sequence, <span class="math inline">\(\textsf{MCSS}{} = -\infty\)</span> because the sum of an empty sequence is defined as <span class="math inline">\(-\infty\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
For $a = \cseq{1, -2, 0, 3, -1, 0, 2, -3 \cseqee},$ a maximum contiguous
subsequence is, $\cseq{3, -1, 0, 2};$ 
another is $\cseqbb 0, 3, -1, 0, 2 \cseqee.$
Thus $\MCSS{}~(a) = 4$.

For the empty sequence,~$\MCSS{} = -\infty$ because the sum of an
empty sequence is defined as~$-\infty$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::define
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachnote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::define
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We define <span class="math inline">\({-\infty}{}\)</span> for the empty case instead of <span class="math inline">\(0\)</span> to allow for negative numbers to matter.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We define $\ninfty{}$ for the empty case instead of $0$ to allow for
negative numbers to matter.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachnote -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:nt:mcss::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
nt:mcss::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Here we only consider sequences of integers and the addition operation to compute the sum, the techniques that we describe should apply to sequences of other types and other associative sum operations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Here we only consider sequences of integers and the addition operation
to compute the sum, the techniques that we describe should apply to
sequences of other types and other associative sum operations.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::lower-bound
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Lower Bound
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Lower Bound
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::lower-bound
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To solve the <span class="sans-serif">MCSS</span> problem, we need to inspect, at the very least, each and every element of the sequence. This requires linear work in the length of the sequence and thus solve the <span class="sans-serif">MCSS</span> problem requires <span class="math inline">\(\Omega(n)\)</span> work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To solve the \MCSS{} problem, we need to inspect, at the very least, each and  every element of the sequence.  This requires linear work in the length of the sequence and thus   solve the \MCSS{} problem requires $\Omega(n)$  work.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:not:mcss::introduction::mcss-history
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
History of the Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
History of the Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
not:mcss::introduction::mcss-history
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The study of maximum contiguous subsequence problem goes to 1970’s. The problem was first proposed in by Ulf Grenander, a Swedish statistician and a professor of applied mathematics at Brown University, in 1977. The problem has several names, such maximum subarray sum problem, or maximum segment sum problem, the former of which appears to be the name originally used by Grenander. Grenander intended it to be a simplified model for maximum likelihood estimation of patterns in digitized images, whose structure he wanted to understand.</p>
<p>According to Jon Bentley (Jon Bentley, Programming Pearls (1st edition), page 76.) in 1977, Grenander described the problem to Michael Shamos of Carnegie Mellon University who overnight designed a divide and conquer algorithm, which corresponds to our <a href="alg:mcss::dc::first">first divide-and-conquer algorithm</a>. When Shamos and Bentley discussed the problem and Shamos’ solution, they thought that it was probably the best possible. A few days later Shamos described the problem and its history at a Carnegie Mellon seminar attended by statistician Joseph (Jay) Kadane, who designed the work efficient algorithm within a minute. Kadane’s algorithm correspond to the <a href="alg:mcs::iterative">linear work and span algorithm</a> described below.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{not:mcss::introduction::mcss-history}

The study of  maximum contiguous subsequence problem goes to 1970's.  
The problem was first proposed in by Ulf Grenander, a Swedish
statistician and a professor of applied mathematics at Brown
University, in 1977.
The problem has several names, such maximum subarray sum problem, or
maximum segment sum problem, the former of which appears to be the
name originally used by Grenander.
Grenander intended it to be a simplified model for maximum likelihood
estimation of patterns in digitized images, whose structure he wanted
to understand.


According to Jon Bentley
(Jon Bentley, Programming Pearls (1st edition), page 76.)
in 1977, Grenander described the problem to Michael Shamos of
Carnegie Mellon University who overnight designed a divide and
conquer algorithm, which corresponds to our 
\href{alg:mcss::dc::first}{first divide-and-conquer algorithm}.
When Shamos and Bentley discussed the problem and Shamos' solution,
they thought that it was probably the best possible.
A few days later Shamos described the problem and its history at a
Carnegie Mellon seminar attended by statistician Joseph (Jay) Kadane,
who designed the work efficient algorithm within a minute.
Kadane's algorithm correspond to the 
\href{alg:mcs::iterative}{linear work and span algorithm} 
described below.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:gr:mcss::problem::roadmap
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Roadmap
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Roadmap
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
gr:mcss::problem::roadmap
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> The remaining sections apply various algorithm-design techniques to the MCS and <span class="sans-serif">MCSS</span> problems. To exercise our vocabulary for algorithm design, the content is organized to identify carefully the design techniques, sometimes at a level of precision that may, especially in subsequent reads, feel pedantic.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{gr:mcss::problem::roadmap}
The remaining sections apply various algorithm-design
techniques to the MCS and \MCSS{} problems.
To exercise our vocabulary for algorithm design, the content is
organized to identify carefully the design techniques, sometimes at a
level of precision that may, especially in subsequent reads, feel
pedantic.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Brute Force
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Brute Force
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::bf
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::presents
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::presents
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>This section presents a first solution to the <span class="sans-serif">MCSS</span> problem by using the <a href="sec:design::bf">brute force technique</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
This section presents a first solution to the \MCSS{} problem by using
the \href{sec:design::bf}{brute force technique}.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::bf-alg::brutest
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSS</span>: Brutest Force
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSS{}: Brutest Force
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::bf-alg::brutest
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can solve the <span class="sans-serif">MCSS</span> problem by brute force. First, we identify the set of candidate solutions as the set of all integers. Then we enumerate all integers and, for each one, check that there is a contiguous subsequence whose sum is equal to that integer. We stop when we find the largest integer with a matching subsequence.</p>
<p>Perhaps obviously, such an algorithm would not terminate, because we don’t know when to stop. Notice, however, that the solution is bounded by the sum of all positive integers in the sequence. We can thus stop the search when we reach that bound.</p>
<p>This algorithm terminates but has the undesirable characteristic that its bound depends on the values of the elements in the sequence rather that its length.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::bf-alg::brutest}

We can solve the \MCSS{} problem by brute force.
First, we identify the set of candidate solutions as the set of all
integers.
Then we enumerate all integers and, for each one, check that there is
a contiguous subsequence whose sum is equal to that integer.
We stop when we find the largest integer with a matching subsequence.


Perhaps obviously, such an algorithm would not terminate, because we
don't know when to stop.
Notice, however, that the solution is bounded by the sum of all
positive integers in the sequence.
We can thus stop the search when we reach that bound.

This algorithm terminates but has the undesirable characteristic that
its bound depends on the values of the elements in the sequence rather
that its length.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::reduction-to
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Reduction to <span class="sans-serif">MCS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reduction to \MCS{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::reduction-to
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><a href="alg:mcss::bf-alg::brutest">Our first algorithm</a> is rather inefficient in the worst case, because it tries a large number of candidate solutions. We can achieve a better bound by reducing <span class="sans-serif">MCSS</span> problem to the <a href="def:mcss::introduction::mcss-problem">Maximum Contiguous Subsequence (<span class="sans-serif">MCS</span>) problem</a>, which requires finding the contiguous subsequence with the largest sum.</p>
<p>The reduction itself is straightforward: because both problems operate on the same input, there is no need to transform the input. To compute the output, we sum the elements in the sequence returned by the <span class="sans-serif">MCS</span> problem. Using <span class="math inline">\(\mathit{reduce}\)</span>, this requires <span class="math inline">\(O(n)\)</span> work and <span class="math inline">\(O(\lg{n})\)</span> span. Thus, the work and span of the reduction is <span class="math inline">\(O(n)\)</span> and <span class="math inline">\(O(\lg{n})\)</span> respectively.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\href{alg:mcss::bf-alg::brutest}{Our first algorithm} is rather
inefficient in the worst case, because it tries a large number of
candidate solutions.
We can achieve a better bound by reducing \MCSS{} problem to the
\href{def:mcss::introduction::mcss-problem}{Maximum Contiguous Subsequence (\MCS{}) problem}, which requires finding the contiguous subsequence with the
largest sum.

The reduction itself is straightforward: because both problems operate
on the same input, there is no need to transform the input.
To compute the output, we sum the elements in the sequence returned by
the \MCS{} problem.
Using $\cdvar{reduce}$, this requires $O(n)$ work and $O(\lg{n})$ span.
Thus, the work and span of the reduction is $O(n)$ and $O(\lg{n})$
respectively.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::bf-alg::mcs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCS</span>: Brute Force
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCS{}: Brute Force
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::bf-alg::mcs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> We can solve the <span class="sans-serif">MCS</span> problem by brute force: we enumerate all candidate solutions, which consist of all the contiguous subsequences of the sequence, and find the one with the largest sum. To generate all contiguous subsequences, we can generate all pairs of integers <span class="math inline">\((i,j)\)</span>, <span class="math inline">\(0 \le i \le j &lt; n\)</span>, compute the sum of the subsequence that corresponds to the pair, and pick the one with the largest total. We write the algorithm as follows: <span class="math display">\[\begin{array}{l}  
\mathit{MCSBF}~a =  
\\  
~~~~\texttt{let}   
\\  
~~~~~~~~\mathit{maxSum}~((i, j, s), (k, \ell, t)) = \texttt{if}~s &gt; t~\texttt{then}~(i, j, s)~\texttt{else}~(k, \ell, t)   
\\  
~~~~~~~~b = \left\langle\right.(i, j, \mathit{reduce}~+~0~a[i \cdots j])  : 0  \le i \le j &lt; n \left.\right\rangle
\\  
~~~~~~~~(i, j, s) = \mathit{reduce}~\mathit{maxSum}~(-1, -1, {-\infty}{})~b  
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~(i, j)  
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::bf-alg::mcs}
We can solve the \MCS{} problem by brute force: we enumerate all
candidate solutions, which consist of all the contiguous subsequences
of the sequence, and find the one with the largest sum.
To generate all contiguous subsequences, we can generate all pairs of
integers $(i,j)$, $0 \le i \le j < n$, compute the sum of the
subsequence that corresponds to the pair, and pick the  one with the
largest total.  We write the algorithm as follows:
\[
\begin{array}{l}
\cdvar{MCSBF}~a =
\\
~~~~\cd{let} 
\\
~~~~~~~~\cdvar{maxSum}~((i, j, s), (k, \ell, t)) = \cd{if}~s > t~\cd{then}~(i, j, s)~\cd{else}~(k, \ell, t) 
\\
~~~~~~~~b = \cseqbb (i, j, \cdvar{reduce}~+~0~a\cirange{i}{j})  : 0  \le i \le j < n \cseqee
\\
~~~~~~~~(i, j, s) = \cdvar{reduce}~\cdvar{maxSum}~(-1, -1, \ninfty{})~b
\\
~~~~\cd{in}
\\
~~~~~~~~(i, j)
\\
~~~~\cd{end}
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::cost-of-brute-force
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost of Brute Force <span class="sans-serif">MCSS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost of Brute Force \MCSS{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::cost-of-brute-force
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Using array sequence costs, generating the <span class="math inline">\(n^2\)</span> subsequences requires a total of <span class="math inline">\(O(n^2)\)</span> work and <span class="math inline">\(O(\lg{n})\)</span> span. Reducing over each subsequence using <span class="math inline">\(\mathit{reduce}\)</span> adds linear work per subsequence, bringing the total work to <span class="math inline">\(O(n^3)\)</span>. The final reduce that select the maximal subsequence require <span class="math inline">\(O(n^2)\)</span> work. The total work is thus dominated by the computation of sums for each subsequence, and therefore is <span class="math inline">\(O(n^3)\)</span>.</p>
<p>Because we can generate all pairs in parallel and compute their sum in parallel in <span class="math inline">\(\Theta(\lg{n})\)</span> span using <span class="math inline">\(\mathit{reduce}\)</span>, the algorithm requires <span class="math inline">\(\Theta(\lg{n})\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Using array sequence costs, generating the $n^2$ subsequences requires
a total of $O(n^2)$ work and $O(\lg{n})$ span.
Reducing over each subsequence using $\cdvar{reduce}$ adds linear work
per subsequence, bringing the total work to $O(n^3)$. 
The final reduce that select the maximal subsequence require $O(n^2)$
work.
The total work is thus dominated by the computation of sums for each
subsequence, and therefore is $O(n^3)$.

Because we can generate all pairs in parallel and compute their sum in
parallel in $\Theta(\lg{n})$ span using $\cdvar{reduce}$, the algorithm
requires $\Theta(\lg{n})$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::bf-alg::mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
MCSS: Brute Force
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
MCSS: Brute Force
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::bf-alg::mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Our first algorithm uses brute force technique and a reduction to the <span class="sans-serif">MCS</span> problem, which we again solve by brute force using the <a href="alg:mcss::bf-alg::mcs">brute-force <span class="sans-serif">MCS</span> algorithm</a>. We can write the algorithm as follows:</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSBF}~a =  
\\  
~~~~\texttt{let}   
\\  
~~~~~~~~(i, j) =  \mathit{MCSBF}~a  
\\  
~~~~~~~~\mathit{sum} = \mathit{reduce}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a[i \cdots j]  
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~\mathit{sum}  
\\  
~~~~\texttt{end}.  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::bf-alg::mcss}

Our first algorithm uses brute force technique and a reduction to the
\MCS{} problem, which we again solve by brute force using the
\href{alg:mcss::bf-alg::mcs}{brute-force \MCS{} algorithm}.
We can write the algorithm as follows:

\[
\begin{array}{l}
\cdvar{MCSSBF}~a =
\\
~~~~\cd{let} 
\\
~~~~~~~~(i, j) =  \cdvar{MCSBF}~a
\\
~~~~~~~~\cdvar{sum} = \cdvar{reduce}~\cstr{+}~0~a\cirange{i}{j}
\\
~~~~\cd{in}
\\
~~~~~~~~\cdvar{sum}
\\
~~~~\cd{end}.
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::strengthening
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Strengthening
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Strengthening
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::strengthening
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The <a href="alg:mcss::bf-alg::mcss">brute force algorithm</a> has some redundancy: to find the solution, it computes the result for the <span class="sans-serif">MCS</span> problem and then computes the sum of the result sequence, which is already computed by the <span class="sans-serif">MCS</span> algorithm. We can eliminate this redundancy by strengthening the <span class="sans-serif">MCS</span> problem and requiring it to return the sum in addition to the subsequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The \href{alg:mcss::bf-alg::mcss}{brute force algorithm} 
has some redundancy: to find the solution, it computes the result for
the \MCS{} problem and then computes the sum of the result sequence,
which is already computed by the \MCS{} algorithm.
We can eliminate this redundancy by strengthening the \MCS{} problem
and requiring it to return the sum in addition to the subsequence.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:xrcs:mcss::describe
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='exercise'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xrcs:mcss::describe
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Describe the changes to the algorithms Algorithm <a href="#alg:mcss::bf-alg::mcs" data-reference-type="ref" data-reference="alg:mcss::bf-alg::mcs">[alg:mcss::bf-alg::mcs]</a> and Algorithm <a href="#alg:mcss::bf-alg::mcss" data-reference-type="ref" data-reference="alg:mcss::bf-alg::mcss">[alg:mcss::bf-alg::mcss]</a> to implement the strengthening described above. How does strengthening impact the work and span costs?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Describe the changes to the algorithms 
\algref{mcss::bf-alg::mcs} and 
\algref{mcss::bf-alg::mcss}
to implement the strengthening described above.
How does strengthening impact the work and span costs?
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- exercise -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::bf-alg::mcss-strong
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
MCSS: Brute Force Strengthened
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
MCSS: Brute Force Strengthened
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::bf-alg::mcss-strong
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can write the algorithm based on strengthening directly as follows. Because the problem description requires returning only the sum, we simplify the algorithm by not tracking the subsequences. <span class="math display">\[\begin{array}{l}  
\mathit{MCSSBF}~a =  
\\  
~~~~\texttt{let}   
\\  
~~~~~~~~b = \left\langle\right.\mathit{reduce}~+~0~a[i \cdots j]  : 0  \le i \le j &lt; n \left.\right\rangle
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~\mathit{reduce}~\mathit{max}~{-\infty}{}~b  
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::bf-alg::mcss-strong}

We can write the algorithm based on strengthening directly as follows.
Because the problem description requires returning only the sum, we
simplify the algorithm by not tracking the subsequences.
\[
\begin{array}{l}
\cdvar{MCSSBF}~a =
\\
~~~~\cd{let} 
\\
~~~~~~~~b = \cseqbb \cdvar{reduce}~+~0~a\cirange{i}{j}  : 0  \le i \le j < n \cseqee
\\
~~~~\cd{in}
\\
~~~~~~~~\cdvar{reduce}~\cdvar{max}~\ninfty{}~b
\\
~~~~\cd{end}
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::cost-analysis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::cost-analysis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s analyze the work and span of <a href="alg:mcss::bf-alg::mcss-strong">the strengthened brute-force algorithm</a> by using <a href="sec:sequences::cost::arrays">array sequences</a> and by appealing to our cost bounds for <span class="math inline">\(\mathit{reduce}\)</span>, <span class="math inline">\(\mathit{subseq}\)</span>, and <span class="math inline">\(\mathit{tabulate}\)</span>. The cost bounds for enumerating all possible subsequences and computing their sums is as follows. <span class="math display">\[\begin{array}{lllll}  
  W(n) &amp; = &amp; 1 + \displaystyle\sum_{1 \leq i\leq j\leq n} W_{\mathit{reduce}}(j-i) \leq  
           1 + n^2 \cdot W_{\mathit{reduce}}(n)   
       &amp; = &amp; \Theta(n^3)   
\\  
  S(n) &amp; = &amp; 1 + \displaystyle\max_{1 \leq i\leq j\leq n} S_{\textrm{reduce}}(j-i) \leq   
           1 + S_{\mathit{reduce}}(n)   
       &amp; = &amp; \Theta(\lg n)   
\end{array}\]</span> The final step of the brute-force algorithm is to find the maximum over these <span class="math inline">\(\Theta(n^2)\)</span> combinations. Since the reduce for this step has <span class="math inline">\(\Theta(n^2)\)</span> work and <span class="math inline">\(\Theta(\lg n)\)</span> span the cost of the final step is subsumed by other costs analyzed above. Overall, we have an <span class="math inline">\(\Theta(n^3)\)</span>-work <span class="math inline">\(\Theta(\lg n)\)</span>-span algorithm.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's analyze the work and span of 
\href{alg:mcss::bf-alg::mcss-strong}{the strengthened brute-force algorithm} by using 
\href{sec:sequences::cost::arrays}{array sequences}
and by appealing to our cost bounds for
$\cdvar{reduce}$, $\cdvar{subseq}$, and $\cdvar{tabulate}$.
The cost bounds for enumerating all possible subsequences and
computing their sums is as follows.
\[
\begin{array}{lllll}
  W(n) & = & 1 + \displaystyle\sum_{1 \leq i\leq j\leq n} W_{\cdvar{reduce}}(j-i) \leq
           1 + n^2 \cdot W_{\cdvar{reduce}}(n) 
       & = & \Theta(n^3) 
\\
  S(n) & = & 1 + \displaystyle\max_{1 \leq i\leq j\leq n} S_{\textrm{reduce}}(j-i) \leq 
           1 + S_{\cdvar{reduce}}(n) 
       & = & \Theta(\lg n) 
\end{array}
\]
The final step of the brute-force algorithm is to find the maximum
over these $\Theta(n^2)$ combinations.
Since the reduce for this step has $\Theta(n^2)$ work and $\Theta(\lg n)$
span
 the cost of the final step is subsumed by other costs analyzed
above.  
Overall, we have an $\Theta(n^3)$-work $\Theta(\lg n)$-span algorithm.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

<atom name='note'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
nt:mcss::span
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Note that the span requires the maximum over <span class="math inline">\(\binom{n}{2} \leq n^2\)</span> values, but since <span class="math inline">\(\lg n^k = k \lg n\)</span>, this is simply <span class="math inline">\(\Theta(\lg n)\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Note that the span requires the maximum over
$\binom{n}{2} \leq n^2$ values, 
but since $\lg n^k = k \lg n$, this is simply
$\Theta(\lg n)$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- note -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::summary
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Summary
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Summary
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::summary
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>When trying to apply the brute-force technique to the <span class="sans-serif">MCSS</span> problem, we encountered a problem. We solved this problem by reducing <span class="sans-serif">MCSS</span> problem to another problem, <span class="sans-serif">MCS</span>. We then realized a redundancy in the resulting algorithm and eliminated that redundancy by strengthening <span class="sans-serif">MCS</span>. This is a quite common route when designing a good algorithm: we find ourselves refining the problem and the solution until it is (close to) perfect.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
When trying to apply the brute-force technique to the \MCSS{} problem,
  we encountered a problem.  We solved this problem by reducing \MCSS{}
  problem to another problem, \MCS{}. We then realized a redundancy in
  the resulting algorithm and eliminated that redundancy by
  strengthening \MCS{}.  This is a quite common route when designing a
  good algorithm: we find ourselves refining the problem and the
  solution until it is (close to) perfect.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Applying Reduction
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Applying Reduction
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::reduction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><a href="sec:mcss::bf">In the previous section</a>, we used the brute-force technique to develop an algorithm that has logarithmic span but large (cubic) work. In this section, we apply the reduction technique to obtain a low span and work-efficient (linear work) algorithm for the <span class="sans-serif">MCSS</span> problem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\href{sec:mcss::bf}{In the previous section}, we used the brute-force
technique to develop an algorithm that has logarithmic span but large
(cubic) work.
In this section, we apply the reduction technique to obtain a
low span and work-efficient (linear work) algorithm for the \MCSS{}
problem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Auxiliary Problems
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Auxiliary Problems
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::auxiliary-problems
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::overlapping-subsequences-and-redundancy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Overlapping Subsequences and Redundancy
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Overlapping Subsequences and Redundancy
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::overlapping-subsequences-and-redundancy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To understand how we might improve the amount of work, observe that the brute-force algorithm performs a lot of repeated and thus redundant work. To see why, consider the subsequences that start at some location. For each position, e.g., the middle, the algorithm considers a subsequence that starts at the position and at any other position that comes after it. Even though each subsequence differs from another by a single element (in the ending positions), the algorithm computes the total sum for each of these subsequences independently, requiring linear work per subsequence. The algorithm does not take advantage of the overlap between the many subsequences it considers.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To understand how we might improve the amount of work, observe that
the brute-force algorithm performs a lot of repeated and thus redundant work.
To see why, consider the subsequences that start at some location.
For each position, e.g., the middle, the algorithm considers a
subsequence that starts at the position and at any other position that
comes after it.
Even though each subsequence differs from another by a single element
(in the ending positions), the algorithm computes the total sum for
each of these subsequences independently, requiring linear work per
subsequence.
The algorithm does not take advantage of the overlap between the many subsequences it considers.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::reducing-redundancy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Reducing Redundancy
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reducing Redundancy
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::reducing-redundancy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can reduce redundancy by taking advantage of the overlaps and computing all subsequences that start or end at a given position together. Our basic strategy in applying the reduction technique is to use this observation. To this end, we define two problems that are closely related to the <span class="sans-serif">MCSS</span> problem, present efficient and parallel algorithm for these problems, and then reduce the <span class="sans-serif">MCSS</span> to them.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can reduce redundancy by taking advantage of the overlaps and
computing all subsequences that start or end at a given position
together.
Our basic strategy in applying the reduction technique is to use this
observation.
To this end, we define two problems that are closely related to the
\MCSS{} problem, present efficient and parallel algorithm for these
problems, and then reduce the \MCSS{} to them.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::maximum
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSSS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSSS{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::maximum
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The  <strong><em>Maximum Contiguous Subsequence Sum with Start</em></strong> , abbreviated  <strong><em><span class="sans-serif">MCSSS</span></em></strong> , problem requires finding the maximum contiguous subsequence of a sequence that starts at a given position.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The~\defn{Maximum Contiguous Subsequence Sum with Start},
abbreviated~\defn{\MCSSS{}}, problem requires finding the maximum
contiguous subsequence of a sequence that starts at a given position.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:def:mcss::problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='definition'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSSE</span> Problem
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSSE{} Problem
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
def:mcss::problem
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The  <strong><em>Maximum Contiguous Subsequence with Ending</em></strong> , i.e., the  <strong><em><span class="sans-serif">MCSSE</span></em></strong> problem requires finding the maximum contiguous subsequence ending at a specified end position.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The~\defn{Maximum Contiguous Subsequence with Ending}, i.e.,
the~\defn{\MCSSE{}} problem requires finding the maximum contiguous
subsequence ending at a specified end position.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- definition -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::reducing-to-and
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Reducing <span class="sans-serif">MCSS</span> to <span class="sans-serif">MCSSS</span> and <span class="sans-serif">MCSSE</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reducing \MCSS{} to \MCSSS{} and \MCSSE{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::reducing-to-and
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Observe that we can reduce the <span class="sans-serif">MCSS</span> problem to <span class="sans-serif">MCSSS</span> problem by enumerating over all starting positions, solving <span class="sans-serif">MCSSS</span> for each position, and taking the maximum over the results. A similar reduction works for the <span class="sans-serif">MCSSE</span> problem.</p>
<p>Because the inputs to all these problems are essentially the same, we don’t need to transform the input. To compute the output for <span class="sans-serif">MCSS</span>, we need to perform a <span class="math inline">\(\mathit{reduce}\)</span>. The reduction itself is thus efficient.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Observe that we can reduce the \MCSS{} problem to \MCSSS{} problem by
enumerating over all starting positions, solving \MCSSS{} for each
position, and taking the maximum over the results.
A similar reduction works for the \MCSSE{} problem.

Because the inputs to all these problems are essentially the same, we
don't need to transform the input.  To compute the output for \MCSS{},
we need to perform a $\cdvar{reduce}$.
The reduction itself is thus efficient.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::reduction::mcsss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
An Optimal Alggorithm for <span class="sans-serif">MCSSS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
An Optimal Alggorithm for \MCSSS{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::reduction::mcsss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> We can solve the <span class="sans-serif">MCSSS</span> problem by first computing the sum for all subsequences that start at the given position using <span class="math inline">\(\mathit{scan}\)</span> and then finding their maximum. <span class="math display">\[\begin{array}{l}  
\mathit{MCSSSOpt}~a~i =  
\\   
~~~~\texttt{let}   
\\   
~~~~~~~~b = \mathit{scanI}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a~[i \cdots (|a|-1)]  
\\   
~~~~\texttt{in}  
\\   
~~~~~~~~\mathit{reduce}~\mathit{max}~{-\infty}{}~b  
\\   
~~~~\texttt{end}  
\end{array}\]</span></p>
<p>Because the algorithm performs one scan and one reduce, it performs <span class="math inline">\(\Theta(n-i)\)</span> work in <span class="math inline">\(\Theta(\lg{n-i})\)</span> span. This is asymptotically optimal because, any algorithm for the <span class="sans-serif">MCSSS</span> problem must inspect as least <span class="math inline">\(n-i\)</span> elements of the input sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::reduction::mcsss}
We can solve the \MCSSS{} problem by first computing the sum for all
subsequences that start at the given position using $\cdvar{scan}$ and then finding
their maximum.
\[
\begin{array}{l}
\cdvar{MCSSSOpt}~a~i =
\\ 
~~~~\cd{let} 
\\ 
~~~~~~~~b = \cdvar{scanI}~\cstr{+}~0~a~\cirange{i}{(|a|-1)}
\\ 
~~~~\cd{in}
\\ 
~~~~~~~~\cdvar{reduce}~\cdvar{max}~\ninfty{}~b
\\ 
~~~~\cd{end}
\end{array}
\]

Because the algorithm performs one scan and one reduce, it performs
$\Theta(n-i)$ work in $\Theta(\lg{n-i})$ span.  This is asymptotically
optimal because, any algorithm for the \MCSSS{} problem must inspect
as least $n-i$ elements of the input sequence.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::reduction:mcsse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
An Optimal Alggorithm for <span class="sans-serif">MCSSS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
An Optimal Alggorithm for \MCSSS{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::reduction:mcsse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> To solve the <span class="sans-serif">MCSSE</span> problem efficiently and in low span, we observe that any contiguous subsequence of a given sequence can be expressed in terms of the difference between two prefixes of the sequence: the subsequence <span class="math inline">\(A[i \cdots j]\)</span> is equivalent to the difference between the subsequence <span class="math inline">\(A[0 \cdots j]\)</span> and the subsequence <span class="math inline">\(A[0 \cdots i-1]\)</span>.</p>
<p>Thus, we can compute the sum of the elements in a contiguous subsequence as <span class="math display">\[\mathit{reduce}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a[i \cdots j]  
=   
\left(\mathit{reduce}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a[0 \cdots j]\right)  
-   
\left(\mathit{reduce}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a[0 \cdots i-1]\right)\]</span> where the “-” is the subtraction operation on integers.</p>
<p>This observation leads us to a solution to the <span class="sans-serif">MCSSE</span> problem. Consider an ending position <span class="math inline">\(j\)</span> and suppose that we have the sum for each prefix that ends at <span class="math inline">\(i &lt; j\)</span>. Since we can express any subsequence ending at position <span class="math inline">\(j\)</span> by subtracting the corresponding prefix, we can compute the sum for the subsequence <span class="math inline">\(A[i \cdots j]\)</span> by subtracting the sum for the prefix ending at <span class="math inline">\(j\)</span> from the prefix ending at <span class="math inline">\(i-1\)</span>. Thus the maximum contiguous sequence ending at position <span class="math inline">\(j\)</span> starts at position <span class="math inline">\(i\)</span> which has the minimum of all prefixes up to <span class="math inline">\(i\)</span>. We can compute the minimum prefix that comes before <span class="math inline">\(j\)</span> by using just another scan. These observations lead to the following algorithm.</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSEOpt}~a~j=  
\\  
~~~~\texttt{let}  
\\  
~~~~~~~~(b,v) = \mathit{scan}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a[0 \cdots j]  
\\  
~~~~~~~~w= \mathit{reduce}~\mathit{min}~\infty~b  
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~v - w   
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
<p>Using array sequences, this algorithm performs <span class="math inline">\(\Theta(j)\)</span> work and <span class="math inline">\(\Theta(\lg (j))\)</span> span. This is optimal because any algorithm for <span class="sans-serif">MCSSE</span> must inspect at least <span class="math inline">\(j\)</span> elements of the input sequence.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::reduction:mcsse}
To solve the \MCSSE{} problem efficiently and in low span, we observe
that any contiguous subsequence of a given sequence can be expressed
in terms of the difference between two prefixes of the sequence:
the subsequence $A\cirange{i}{j}$ is equivalent to the difference
between the subsequence $A\cirange{0}{j}$ and the subsequence
$A\cirange{0}{i-1}$.

Thus, we can compute the sum of the elements in
a contiguous subsequence as
\[
\cdvar{reduce}~\cstr{+}~0~a\cirange{i}{j}
= 
\left(\cdvar{reduce}~\cstr{+}~0~a\cirange{0}{j}\right)
- 
\left(\cdvar{reduce}~\cstr{+}~0~a\cirange{0}{i-1}\right)
\]
where the ``-'' is the subtraction operation on integers.

This observation leads us to a solution to the \MCSSE{} problem.
Consider an ending position $j$ and suppose that we have
the sum for each prefix that ends at $i < j$.
Since we can express any subsequence ending at position $j$ by
subtracting the corresponding prefix, we can compute the sum for the
subsequence $A\cirange{i}{j}$ by subtracting the sum for the prefix
ending at $j$ from the prefix ending at $i-1$.
Thus the maximum contiguous sequence ending at position $j$ starts at
position $i$ which has the minimum of all prefixes up to $i$.
We can compute the minimum prefix that comes before $j$ by using just
another scan.  
These observations lead to the following algorithm.

\[
\begin{array}{l}
\cdvar{MCSSEOpt}~a~j=
\\
~~~~\cd{let}
\\
~~~~~~~~(b,v) = \cdvar{scan}~\cstr{+}~0~a\cirange{0}{j}
\\
~~~~~~~~w= \cdvar{reduce}~\cdvar{min}~\infty~b
\\
~~~~\cd{in}
\\
~~~~~~~~v - w 
\\
~~~~\cd{end}
\end{array}
\]

Using array sequences, this algorithm performs $\Theta(j)$ work and
$\Theta(\lg (j))$ span.  This is optimal because any algorithm for \MCSSE{} must inspect at least $j$ elements of the input sequence.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Reduction to <span class="sans-serif">MCSSS</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reduction to \MCSSS{}
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::reduction-to
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::improve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachask'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::improve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Can you improve the brute-force algorithm by reducing the <span class="sans-serif">MCSS</span> problem to <span class="sans-serif">MCSSS</span> problem?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Can you improve the brute-force algorithm by reducing the \MCSS{}
problem to \MCSSS{} problem?
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachask -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::reduction::mcss-red-mcsss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSS</span>: Reduced Force
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSS{}: Reduced Force
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::reduction::mcss-red-mcsss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can find a more efficient brute-force algorithm for <span class="sans-serif">MCSS</span> by reducing the problem to <span class="sans-serif">MCSSS</span> and using <a href="alg:mcss::reduction::mcsss">the optimal algorithm for it</a>.</p>
<p>The idea is to try all possible start positions, solve the <span class="sans-serif">MCSSS</span> problem for each, and select their maximum. The code for the algorithm is shown below. <span class="math display">\[\begin{array}{l}  
\mathit{MCSSReducedForce}~a =   
\\  
~~~~\mathit{reduce}~\mathit{max}~{-\infty}{}~\left\langle\, (\mathit{MCSSSOpt}~a~i) : 0 \le i &lt; n \,\right\rangle.  
\end{array}\]</span> In the worst case, the algorithm performs <span class="math inline">\(\Theta(n^2)\)</span> work in <span class="math inline">\(\Theta(\lg{n})\)</span> span, delivering a linear-factor improvement in work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::reduction::mcss-red-mcsss}

We can find a more efficient brute-force algorithm for \MCSS{} by
reducing the problem to \MCSSS{} and
using \href{alg:mcss::reduction::mcsss}{the optimal algorithm for it}.

The idea is to try all possible start positions, solve the \MCSSS{}
problem for each, and select their maximum.
The code for the algorithm is shown below.
\[
\begin{array}{l}
\cdvar{MCSSReducedForce}~a = 
\\
~~~~\cdvar{reduce}~\cdvar{max}~\ninfty{}~\cseq{(\cdvar{MCSSSOpt}~a~i) : 0 \le i < n}.
\end{array}
\]
In the worst case, the algorithm performs $\Theta(n^2)$ work in
$\Theta(\lg{n})$ span, delivering a linear-factor improvement in
work.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:rmrk:mcss::reducing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='remark'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
rmrk:mcss::reducing
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>By reducing <span class="sans-serif">MCSS</span> to <span class="sans-serif">MCSSS</span>, we were able to eliminate a certain kind of redundancy: namely those that occur when solving for subsequences starting at a given position. In the next section, we will see, how to improve our bound further.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
By reducing \MCSS{} to \MCSSS{}, we were able to eliminate a certain
kind of redundancy: namely those that occur when solving for
subsequences starting at a given position.
In the next section, we will see, how to improve our bound further.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- remark -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Reduction to <span class="sans-serif">MCSSE</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Reduction to \MCSSE{}
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::mcss-by-reduction-to
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::reduction::mcss-red-mcsse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
MCSS by Reduction to <span class="sans-serif">MCSSE</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
MCSS by Reduction to \MCSSE{}
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::reduction::mcss-red-mcsse
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can solve the <span class="sans-serif">MCSS</span> problem by enumerating all instances of the <span class="sans-serif">MCSSE</span> problem and selecting the maximum. <span class="math display">\[\begin{array}{l}  
\mathit{MCSSReducedForce2}~a=  
\\  
~~~~\mathit{reduce}~\mathit{max}~{-\infty}~\left\langle\, (\mathit{MCSSEOpt}~a~i) : 0 \le i &lt; |a| \,\right\rangle  
\end{array}\]</span></p>
<p>This algorithm has <span class="math inline">\(O(n^2)\)</span> work and <span class="math inline">\(O(\lg{n})\)</span> span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::reduction::mcss-red-mcsse}

We can solve the \MCSS{} problem by enumerating all instances of
the \MCSSE{} problem and selecting the maximum.
\[
\begin{array}{l}
\cdvar{MCSSReducedForce2}~a=
\\
~~~~\cdvar{reduce}~\cdvar{max}~\ninfty~\cseq{(\cdvar{MCSSEOpt}~a~i) : 0 \le i < |a|}
\end{array}
\]

This algorithm has $O(n^2)$ work and $O(\lg{n})$ span.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::obtained
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::obtained
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The two algorithms obtained by <a href="alg:mcss::reduction::mcss-red-mcsss">reduction to <span class="sans-serif">MCSSS</span></a> and <a href="alg:mcss::reduction::mcss-red-mcsse">reduction to <span class="sans-serif">MCSSE</span></a> both reduce some of the redundant work, but not all, because they don’t reduce redundancies when solving for subsequences ending (or starting) at different positions. Next, we will see, how to eliminate these redundant computations.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The two algorithms obtained by
\href{alg:mcss::reduction::mcss-red-mcsss}{reduction to \MCSSS{}}
and
\href{alg:mcss::reduction::mcss-red-mcsse}{reduction to \MCSSE{}}
both reduce some of the redundant work, but not all, because they don't reduce redundancies when solving for subsequences ending (or starting) at different positions.
Next, we will see, how to eliminate these redundant computations.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:lem:mcss::reduction::mcsse-extension
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='lemma'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSSE</span> Extension
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSSE{} Extension
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
lem:mcss::reduction::mcsse-extension
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Suppose that we are given the maximum contiguous sequence, <span class="math inline">\(M_{i}\)</span> ending at position <span class="math inline">\(i\)</span>. We can compute the maximum contiguous sequence ending at position <span class="math inline">\(i+1\)</span>, <span class="math inline">\(M_{i+1}\)</span>, from this by noticing that</p>
<ul>
<li><p><span class="math inline">\(M_{i+1} = {M_{i}}~+\!\!+~{\left\langle\, a[i] \,\right\rangle},\)</span> or</p></li>
<li><p><span class="math inline">\(M_{i+1} = \left\langle\, a[i] \,\right\rangle,\)</span></p></li>
</ul>
<p>depending on the sum for each.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{lem:mcss::reduction::mcsse-extension}
Suppose that we are given the maximum contiguous sequence, $M_{i}$
ending at position~$i$.
We can compute the maximum contiguous sequence ending at position~$i+1$,
$M_{i+1}$, from this by noticing that 
\begin{itemize}
\item $M_{i+1} = \kwappend{M_{i}}{\cseq{a[i]}},$ or 
\item $M_{i+1} = \cseq{a[i]},$
\end{itemize}
depending on the sum for each.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- lemma -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:xrcs:mcss::prove
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='exercise'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xrcs:mcss::prove
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Prove <a href="lem:mcss::reduction::mcsse-extension">the <span class="sans-serif">MCSSE</span> Extension lemma</a>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Prove 
\href{lem:mcss::reduction::mcsse-extension}{the \MCSSE{} Extension lemma}.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- exercise -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::solving
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The algorithm for solving <span class="sans-serif">MCSS</span> by reduction to <span class="sans-serif">MCSSE</span> solves many instances of <span class="sans-serif">MCSSE</span> in parallel. If we give up some parallelism, it turns out that we can improve the work efficiency further based on <a href="lem:mcss::reduction::mcsse-extension">the <span class="sans-serif">MCSSE</span> Extension lemma</a>. The idea is to iterate over the sequence and solve the <span class="sans-serif">MCSSE</span> problem for each ending position. To solve the <span class="sans-serif">MCSSE</span> problem, we then take the maximum over all positions.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The algorithm for solving \MCSS{} by reduction to \MCSSE{} solves many
instances of \MCSSE{} in parallel.
If we give up some parallelism, it turns out that we can improve the
work efficiency further based on
\href{lem:mcss::reduction::mcsse-extension}{the \MCSSE{} Extension lemma}.
The idea is to iterate over the sequence and solve the \MCSSE{}
problem for each ending position.
To solve the \MCSSE{} problem, we then take the maximum over all
positions.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcs::iterative
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSS</span> with Iteration
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSS{} with Iteration
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcs::iterative
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> The SPARC code for the algorithm for <span class="sans-serif">MCSS</span> obtained by reduction to <span class="sans-serif">MCSSE</span> is shown below. We use the function <span class="math inline">\(\mathit{iteratePrefixes}\)</span> to iterate over the input sequence and construct a sequence whose <span class="math inline">\(i^{th}\)</span> position contains the solution to the <span class="sans-serif">MCSSE</span> problem at that position.</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSIterative}~a =   
\\  
~~~~\texttt{let}  
\\   
~~~~~~~~f~(\mathit{sum},x) =  
\\  
~~~~~~~~~~~~\texttt{if}~\mathit{sum} + x \ge x~\texttt{then}  
\\   
~~~~~~~~~~~~~~~~\mathit{sum} + x  
\\  
~~~~~~~~~~~~\texttt{else}  
\\  
~~~~~~~~~~~~~~~~x  
\\   
~~~~~~~~b = \mathit{iteratePrefixes}~f~{-\infty}{}~a  
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~\mathit{reduce}~\mathit{max}~{-\infty}{}~b  
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcs::iterative}
The \PML code for the algorithm for \MCSS{} obtained by reduction to
\MCSSE{} is shown below.
We use the function $\cdvar{iteratePrefixes}$ to iterate over the input
sequence and construct a sequence whose $i^{th}$ position contains the
solution to the \MCSSE{} problem at that position.

\[
\begin{array}{l}
\cdvar{MCSSIterative}~a = 
\\
~~~~\cd{let}
\\ 
~~~~~~~~f~(\cdvar{sum},x) =
\\
~~~~~~~~~~~~\cd{if}~\cdvar{sum} + x \ge x~\cd{then}
\\ 
~~~~~~~~~~~~~~~~\cdvar{sum} + x
\\
~~~~~~~~~~~~\cd{else}
\\
~~~~~~~~~~~~~~~~x
\\ 
~~~~~~~~b = \cdvar{iteratePrefixes}~f~\ninfty{}~a
\\
~~~~\cd{in}
\\
~~~~~~~~\cdvar{reduce}~\cdvar{max}~\ninfty{}~b
\\
~~~~\cd{end}
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::cost
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::cost
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Using array sequences, <span class="math inline">\(\mathit{iteratePrefixes}\)</span> and <span class="math inline">\(\mathit{reduce}\)</span> we are both linear work, because the functions <span class="math inline">\(f\)</span> and <span class="math inline">\(\mathit{max}\)</span> both perform constant work. Because of <span class="math inline">\(\mathit{iteratePrefixes}\)</span>, the span is also linear.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Using array sequences, $\cdvar{iteratePrefixes}$ and $\cdvar{reduce}$
we are both linear work, because the functions $f$ and $\cdvar{max}$
both perform constant work. 
Because of $\cdvar{iteratePrefixes}$, the span is also linear.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::work-optimal-and-low-span
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
<span class="sans-serif">MCSS</span>: Work Optimal and Low Span
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
\MCSS{}: Work Optimal and Low Span
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::work-optimal-and-low-span
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In our <span class="math inline">\(\mathit{scan}\)</span>-based <a href="alg:mcss::reduction:mcsse">algorithm for <span class="sans-serif">MCSSE</span></a>, we used the observation that the maximal contiguous subsequence ending at a given position is identified by subtracting the prefix at the ending position from the minimum sum over all preceeding prefixes. Our new algorithm, uses the same intuition but refines it further by noticing that</p>
<ul>
<li><p>we can compute the sum for all prefixes in one scan, and</p></li>
<li><p>we can compute the minimum prefix sum preceeding all positions in one scan.</p></li>
</ul>
<p>After computing these quantities, all that remains is to take the difference and select the maximum.</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSOpt}~a =  
\\  
~~~~\texttt{let}  
\\  
~~~~~~~~(b,v) = \mathit{scan}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~a  
\\  
~~~~~~~~c = \mathit{append}~b~\left\langle\, v \,\right\rangle  
\\  
~~~~~~~~(d,\_) = \mathit{scan}~\mathit{min}~\infty~c  
\\  
~~~~~~~~e = \left\langle\, c[i]-d[i]: 0 &lt; i &lt; |a| \,\right\rangle  
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~\mathit{reduce}~\mathit{max}~{-\infty}{}~e  
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In our $\cdvar{scan}$-based 
\href{alg:mcss::reduction:mcsse}{algorithm for \MCSSE{}},
we used the observation that 
the maximal contiguous subsequence ending at a given position is
identified by subtracting the prefix at the ending position from the
minimum sum over all preceeding prefixes.
Our new algorithm,  uses the same intuition but refines it
further by noticing that
\begin{itemize}
\item we can compute the sum for all prefixes in one
  scan, and
\item we can compute the minimum prefix sum preceeding all positions in one scan.
\end{itemize}

After computing these quantities, all that remains is to take the
difference and select the maximum.

\[
\begin{array}{l}
\cdvar{MCSSOpt}~a =
\\
~~~~\cd{let}
\\
~~~~~~~~(b,v) = \cdvar{scan}~\cstr{+}~0~a
\\
~~~~~~~~c = \cdvar{append}~b~\cseq{v}
\\
~~~~~~~~(d,\_) = \cdvar{scan}~\cdvar{min}~\infty~c
\\
~~~~~~~~e = \cseq{c[i]-d[i]: 0 < i < |a|}
\\
~~~~\cd{in}
\\
~~~~~~~~\cdvar{reduce}~\cdvar{max}~\ninfty{}~e
\\
~~~~\cd{end}
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
ex:mcs:scan-based
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Consider the sequence <span class="math inline">\(a\)</span> <span class="math display">\[a = \left\langle\, 1, -2, 0, 3, -1, 0, 2, -3 \,\right\rangle.\]</span></p>
<p>Compute <span class="math display">\[\begin{array}{lcl}  
(b,v) &amp; = &amp; \mathit{scan}~\mathit{+}~0~a  
\\  
c  &amp; = &amp; \mathit{append}~ b~ \left\langle\, v \,\right\rangle.  
\end{array}\]</span> We have <span class="math inline">\(c =  \left\langle\, 0, 1, -1, -1, 2, 1, 1, 3, 0 \,\right\rangle\)</span>.</p>
<p>The sequence <span class="math inline">\(c\)</span> contains the prefix sums ending at each position, including the element at the position; it also contains the empty prefix.</p>
<p>Using the sequence <span class="math inline">\(c\)</span>, we can find the minimum prefix up to all positions as <span class="math display">\[(d,\_) = \mathit{scan}~\mathit{min}~\infty~c\]</span> to obtain <span class="math display">\[d = \left\langle\, \infty, 0, 0, -1, -1 -1, -1, -1, -1 \,\right\rangle.\]</span></p>
<p>We can now find the maximum subsequence ending at any position <span class="math inline">\(i\)</span> by subtracting the value for <span class="math inline">\(i\)</span> in <span class="math inline">\(c\)</span> from the value for all the prior prefixes calculated in <span class="math inline">\(d\)</span>.</p>
<p>Compute <span class="math display">\[\begin{array}{lcl}  
e &amp; = &amp; \left\langle\, c[i]-d[i]: 0 &lt; i &lt; |a| \,\right\rangle   
\\  
  &amp; = &amp; \left\langle\, 1, -1, 0, 3, 2, 2, 4, 1 \,\right\rangle.  
\end{array}\]</span></p>
<p>It is not difficult to verify in this small example that the values in <span class="math inline">\(e\)</span> are indeed the maximum contiguous subsequences ending in each position of the original sequence. Finally, we take the maximum of all the values is <span class="math inline">\(e\)</span> to compute the result <span class="math display">\[\mathit{reduce}~\mathit{max}~{-\infty}{}~e = 4.\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{ex:mcs:scan-based}
Consider the sequence $a$
\[
a = \cseq{1, -2, 0, 3, -1, 0, 2, -3}.
\]

Compute
\[
\begin{array}{lcl}
(b,v) & = & \cdvar{scan}~\cdvar{+}~0~a
\\
c  & = & \cdvar{append}~ b~ \cseq{v}.
\end{array}
\]
We have $c =  \cseq{0, 1, -1, -1, 2, 1, 1, 3, 0}$.

The sequence~$c$ contains the prefix sums ending at each position,
including the element at the position; it also contains the empty
prefix.


Using the sequence $c$, we can find the minimum prefix up to all
positions as
\[
(d,\_) = \cdvar{scan}~\cdvar{min}~\infty~c
\]
to obtain
\[
d = \cseq{\infty, 0, 0, -1, -1 -1, -1, -1, -1}.
\]

We can now find the maximum subsequence ending at any position $i$ by
subtracting the value for $i$ in $c$ from the value for all the prior
prefixes calculated in $d$.

Compute
\[
\begin{array}{lcl}
e & = & \cseq{c[i]-d[i]: 0 < i < |a|} 
\\
  & = & \cseq{1, -1, 0, 3, 2, 2, 4, 1}.
\end{array}
\]

It is not difficult to verify in this small example that the values in
$e$ are indeed the maximum contiguous subsequences ending in each
position of the original sequence.  Finally, we take the maximum of
all the values is $e$ to compute the result
\[
\cdvar{reduce}~\cdvar{max}~\ninfty{}~e = 4.
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::cost-of-the-algorithm
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost of the Algorithm
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost of the Algorithm
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::cost-of-the-algorithm
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Using array sequences, and the fact that addition and minimum take constant work, the algorithm performs <span class="math inline">\(\Theta(n)\)</span> work in <span class="math inline">\(\Theta(\lg  
n)\)</span> span. The algorithm is work optimal because any algorithm must inspect each and every element of the sequence to solve the <span class="sans-serif">MCSS</span> problem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Using array sequences, and the fact that addition and minimum take
constant work, the algorithm performs $\Theta(n)$ work in $\Theta(\lg
n)$ span.  
The algorithm is work optimal because any algorithm must inspect each
and every element of the sequence to solve the \MCSS{} problem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- subsection -->

</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Divide And Conquer
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Divide And Conquer
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::dc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->


<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
A First Solution
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
A First Solution
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::dc::first
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::dividing-the-input
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Dividing the Input
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Dividing the Input
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::dividing-the-input
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To apply divide and conquer, we first need to figure out how to divide the input. There are many possibilities, but dividing the input in two halves is usually a good starting point, because it reduces the input for both subproblems equally, reducing thus the size of the largest component, which is important in bounding the overall span. Correctness is usually independent of the particular strategy of division.</p>
<p>Let us divide the sequence into two halves, recursively solve the problem on both parts, and combine the solutions to solve the original problem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To apply divide and conquer, we first need to figure out how to divide the input.
There are many possibilities, but dividing the input in two halves is
usually a good starting point, because it reduces the input for both
subproblems equally, reducing thus the size of the largest component,
which is important in bounding the overall span.
Correctness is usually independent of the particular strategy of
division.

Let us divide the sequence into two halves, recursively solve the
problem on both parts, and combine the solutions to solve the original
problem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
ex:mcss1
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Let <span class="math inline">\(a = \left\langle\, 1, -2, 0, 3, -1, 0, 2, -3 \,\right\rangle\)</span>. By using the approach, we divide the sequence into two sequences <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> as follows <span class="math display">\[b = \left\langle\, 1, -2, 0, 3 \,\right\rangle\]</span> and <span class="math display">\[c = \left\langle\, -1, 0, 2, -3 \,\right\rangle\]</span> We can now solve each part to obtain <span class="math inline">\(3\)</span> and <span class="math inline">\(2\)</span> as the solutions to the subproblems. Note that there are multiple sequences that yield the maximum sum.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{ex:mcss1}
Let $a = \cseq{1, -2, 0, 3, -1, 0, 2, -3}$.  By using the approach, we
divide the sequence into two sequences $b$ and $c$ as follows
\[
b = \cseq{1, -2, 0, 3}
\]
and
\[
c = \cseq{-1, 0, 2, -3}
\]
We can now solve each part to obtain $3$ and $2$ as the solutions to
the subproblems.
Note that there are multiple sequences that yield the maximum sum.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::combine
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachask'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::combine
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>How can we combine the solutions for the two halves to solve the original problem?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
How can we combine the solutions for the two halves to solve the
original problem?
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachask -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::using-solutions-to-subproblems
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Using Solutions to Subproblems
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Using Solutions to Subproblems
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::using-solutions-to-subproblems
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To construct a solution for the original problem from those of the subproblems, let’s consider where the solution subsequence might come from. There are three possibilities.</p>
<ol>
<li><p>The maximum sum lies completely in the left subproblem.</p></li>
<li><p>The maximum sum lies completely in the right subproblem.</p></li>
<li><p>The maximum sum overlaps with both halves, spanning the cut.</p></li>
</ol>
<p>The three cases are illustrated below</p>
<p><img src="./mcss/media/mcss-dandc-simple.jpg" alt="image" style="width:4.5in" /></p>
<p>The first two cases are already solved by the recursive calls, but not the last. Assuming we can find the largest subsequence that spans the cut, we can write our algorithm as shown below.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To construct a solution for the original problem from those of the
subproblems, let's consider where the solution subsequence might come
from.  There are three possibilities.
\begin{enumerate}
\item  
The maximum sum lies completely in the left subproblem.

\item 
The maximum sum lies completely in the right subproblem.

\item
The maximum sum overlaps with both halves, spanning the cut.
\end{enumerate}

The three cases are illustrated below

\begin{center}
\includegraphics[width=4.5in]{./mcss/media/mcss-dandc-simple.jpg}
\end{center}

The first two cases are already solved by the recursive calls, but not
the last.  Assuming we can find the largest subsequence that spans the
cut, we can write our algorithm as shown below.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::dc::first
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Simple Divide-and-Conquer for MCSS
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Simple Divide-and-Conquer for MCSS
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::dc::first
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Using a function called <span class="math inline">\(\mathit{bestAcross}\)</span> to find the largest subsequence that spans the cut, we can write our algorithm as follows.</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSDC}~a =  
\\  
~~~~\texttt{if}~ |a| = 0~\texttt{then}  
\\  
~~~~~~~~{-\infty}{}  
\\  
~~~~\texttt{else if}~|a| = 1 ~\texttt{then}  
\\   
~~~~~~~~a[0]  
\\  
~~~~\texttt{else}  
\\   
~~~~~~~~\texttt{let}  
\\   
~~~~~~~~~~~~(b, c)  = \mathit{splitMid}~a  
\\   
~~~~~~~~~~~~(m_b, m_c) = \left( \mathit{MCSSDC}~b \ ||\ \mathit{MCSSDC}~c \right)  
\\   
~~~~~~~~~~~~m_{bc} = \mathit{bestAcross}~(b, c)  
\\   
~~~~~~~~\texttt{in}  
\\   
~~~~~~~~~~~~\max\{m_b, m_c, m_{bc}\}  
\\   
~~~~~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::dc::first}
Using a function called $\cdvar{bestAcross}$ to find the largest
subsequence that spans the cut, we can write our algorithm as follows.

\[
\begin{array}{l}
\cdvar{MCSSDC}~a =
\\
~~~~\cd{if}~ |a| = 0~\cd{then}
\\
~~~~~~~~\ninfty{}
\\
~~~~\cd{else if}~|a| = 1 ~\cd{then}
\\ 
~~~~~~~~a[0]
\\
~~~~\cd{else}
\\ 
~~~~~~~~\cd{let}
\\ 
~~~~~~~~~~~~(b, c)  = \cdvar{splitMid}~a
\\ 
~~~~~~~~~~~~(m_b, m_c) = \left( \cdvar{MCSSDC}~b \ ||\ \cdvar{MCSSDC}~c \right)
\\ 
~~~~~~~~~~~~m_{bc} = \cdvar{bestAcross}~(b, c)
\\ 
~~~~~~~~\cd{in}
\\ 
~~~~~~~~~~~~\max\{m_b, m_c, m_{bc}\}
\\ 
~~~~~~~~\cd{end}
\end{array} 
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::dc::first::bestacross
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Maximum Subsequence Spanning the Cut
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Maximum Subsequence Spanning the Cut
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::dc::first::bestacross
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can reduce the problem of finding the maximum subsequence spanning the cut to two problems that we have seen already: Maximum-Contiguous-Subsequence Sum with Start, <span class="sans-serif">MCSSS</span>, and Maximum-Contiguous-Subsequence Sum at Ending, <span class="sans-serif">MCSSE</span>. The maximum sum spanning the cut is the sum of the largest suffix on the left plus the largest prefix on the right. The prefix of the right part is easy as it directly maps to the solution of <span class="sans-serif">MCSSS</span> problem at position <span class="math inline">\(0\)</span>. Similarly, the suffix for the left part is exactly an instance of <span class="sans-serif">MCSSE</span> problem. We can thus use the algorithms that we have seen in the previous section for solving this problem, Algorithm <a href="#alg:mcss::reduction::mcsss" data-reference-type="ref" data-reference="alg:mcss::reduction::mcsss">[alg:mcss::reduction::mcsss]</a>, and, Algorithm <a href="#alg:mcss::reduction:mcsse" data-reference-type="ref" data-reference="alg:mcss::reduction:mcsse">[alg:mcss::reduction:mcsse]</a> respectively.</p>
<p>The cost of both of these algorithms is <span class="math inline">\(\Theta(n)\)</span> work and <span class="math inline">\(\Theta(\lg{n})\)</span> span and thus the total cost is also the same.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{alg:mcss::dc::first::bestacross}

We can reduce the problem of finding the maximum subsequence spanning
the cut to two problems that we have seen already:
Maximum-Contiguous-Subsequence Sum with Start, \MCSSS{}, and
Maximum-Contiguous-Subsequence Sum at Ending, \MCSSE{}.
The maximum sum spanning the cut is the sum of the largest suffix on
the left plus the largest prefix on the right.  
The prefix of the right part is easy as it directly maps to the
solution of \MCSSS{} problem at position $0$.
Similarly, the suffix for the left part is exactly an instance of
\MCSSE{} problem.
We can thus use the algorithms that we have seen in the previous
section for solving this problem,
\algref{mcss::reduction::mcsss},
and, 
\algref{mcss::reduction:mcsse}
respectively.

The cost of both of these algorithms is $\Theta(n)$ work and
$\Theta(\lg{n})$ span and thus the total cost is also the same.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

<atom name='example'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:mcss::largest
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In the example above, the largest suffix on the left is <span class="math inline">\(3\)</span>, which is given by the sequence <span class="math inline">\(\left\langle\, 3 \,\right\rangle\)</span> or <span class="math inline">\(\left\langle\, 0, 3 \,\right\rangle\)</span>.</p>
<p>The largest prefix on the right is <span class="math inline">\(1\)</span> given by the sequence <span class="math inline">\(\left\langle\, -1, 0, 2 \,\right\rangle\)</span>. Therefore the largest sum that crosses the middle is <span class="math inline">\(3 + 1 = 4\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In the example above, the largest suffix on the left is $3$, which is
given by the sequence 
$\cseq{3}$ or $\cseq{0, 3}$.

The largest prefix on the right is $1$ given by the sequence
$\cseq{-1, 0, 2}$.
Therefore the largest sum that crosses the middle is $3 + 1 = 4$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- example -->

</segment> <!-- flex -->


<segment name='subsubsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Correctness
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Correctness
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::dc::first::correctness
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::prove
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::prove
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>To prove a divide-and-conquer algorithm correct, we use the technique of strong induction, which enables to assume that correctness remains correct for all smaller subproblems. We now present such a correctness proof for the algorithm <span class="math inline">\(\mathit{MCSSDC}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
To prove a divide-and-conquer algorithm correct, we use the technique
of strong induction, which enables to assume that correctness remains
correct for all smaller subproblems.
We now present such a correctness proof for the algorithm~$\cdvar{MCSSDC}$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:thm:mcss::correctness-of-the-algorithm-mcssdc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='theorem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Correctness of the algorithm <span class="math inline">\(\mathit{MCSSDC}\)</span>
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Correctness of the algorithm $\cdvar{MCSSDC}$
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
thm:mcss::correctness-of-the-algorithm-mcssdc
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let <span class="math inline">\(a\)</span> be a sequence. The algorithm <span class="math inline">\(\mathit{MCSSDC}\)</span> returns the maximum contiguous subsequence sum in a gives sequence—and returns <span class="math inline">\({-\infty}{}\)</span> if <span class="math inline">\(a\)</span> is empty.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let $a$ be a sequence. The algorithm $\cdvar{MCSSDC}$ returns the
  maximum contiguous subsequence sum in a gives sequence---and returns
  $\ninfty{}$ if $a$ is empty.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- theorem -->

<atom name='proof'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prf:mcss::strong
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The proof will be by (strong) induction on length of the input sequence. Our induction hypothesis is that the theorem above holds for all inputs smaller than the current input.</p>
<p>We have two base cases: one when the sequence is empty and one when it has one element. On the empty sequence, the algorithm returns <span class="math inline">\({-\infty}{}\)</span> and thus the theorem holds. On any singleton sequence <span class="math inline">\(\left\langle\right.x \left.\right\rangle\)</span>, the <span class="sans-serif">MCSS</span> is <span class="math inline">\(x\)</span>, because <span class="math display">\[\max \left\{ \sum_{k=i}^j a[k] \;:\; 0 \leq i &lt;  
    1, 0 \leq j &lt; 1 \right\} = \sum_{k=0}^0 a[0] = a[0] = x\,.\]</span> The theorem therefore holds.</p>
<p>For the inductive step, let <span class="math inline">\(a\)</span> be a sequence of length <span class="math inline">\(n \ge 1\)</span>, and assume inductively that for any sequence <span class="math inline">\(a&#39;\)</span> of length <span class="math inline">\(n&#39; &lt; n\)</span>, the algorithm correctly computes the maximum contiguous subsequence sum. Now consider the sequence <span class="math inline">\(a\)</span> and let <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> denote the left and right subsequences resulted from dividing <span class="math inline">\(a\)</span> into two parts (i.e., <span class="math inline">\(\mathit{(b, c) = splitMid a}\)</span>). Furthermore, let <span class="math inline">\(a[i \cdots j]\)</span> be any contiguous subsequence of <span class="math inline">\(a\)</span> that has the largest sum, and this value is <span class="math inline">\(v\)</span>. Note that the proof has to account for the possibility that there may be many other subsequences with equal sum. Every contiguous subsequence must start somewhere and end after it. We consider the following <span class="math inline">\(3\)</span> possibilities corresponding to how the sequence <span class="math inline">\(a[i \cdots j]\)</span> lies with respect to <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span>:</p>
<ul>
<li><p>If the sequence <span class="math inline">\(a[i \cdots j]\)</span> starts in <span class="math inline">\(b\)</span> and ends <span class="math inline">\(c\)</span>. Then its sum equals its part in <span class="math inline">\(b\)</span> (a suffix of <span class="math inline">\(b\)</span>) and its part in <span class="math inline">\(c\)</span> (a prefix of <span class="math inline">\(c\)</span>). If we take the maximum of all suffixes in <span class="math inline">\(c\)</span> and prefixes in <span class="math inline">\(b\)</span> and add them this is equal the maximum of all contiguous sequences bridging the two, because <span class="math inline">\(\max\left\{ x + y : x  
  \in X, y \in Y\} \right\} = \max\left\{ x \in X \right\} + \max\left\{ y \in Y \right\}\)</span>. By assumption this equals the sum of <span class="math inline">\(a[i \cdots j]\)</span> which is <span class="math inline">\(v\)</span>. Furthermore by induction <span class="math inline">\(m_b\)</span> and <span class="math inline">\(m_c\)</span> are sums of other subsequences so they cannot be any larger than <span class="math inline">\(v\)</span> and hence <span class="math inline">\(\max\{m_b, m_c, m_{bc}\} = v\)</span>.</p></li>
<li><p>If <span class="math inline">\(a[i \cdots j]\)</span> lies entirely in <span class="math inline">\(b\)</span>, then it follows from our inductive hypothesis that <span class="math inline">\(m_b = v\)</span>. Furthermore <span class="math inline">\(m_c\)</span> and <span class="math inline">\(m_{bc}\)</span> correspond to the maximum sum of other subsequences, which cannot be larger than <span class="math inline">\(v\)</span>. So again <span class="math inline">\(\max\{m_b, m_c, m_{bc}\} = v\)</span>.</p></li>
<li><p>Similarly, if <span class="math inline">\(a_{i..j}\)</span> lies entirely in <span class="math inline">\(c\)</span>, then it follows from our inductive hypothesis that <span class="math inline">\(m_c = \max\{m_b, m_c, m_{bc}\} =  
  v\)</span>.</p></li>
</ul>
<p>We conclude that in all cases, we return <span class="math inline">\(\max\{m_b, m_c, m_{bc}\} = v\)</span>, as claimed.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The proof will be by (strong) induction on length of the input
sequence.  Our induction hypothesis is that the theorem above holds
for all inputs smaller than the current input.

We have two base cases: one when the sequence is empty and one when it
has one element.  
On the empty sequence, the algorithm returns $\ninfty{}$ and thus the
theorem holds.
On any singleton sequence $\cseqbb x \cseqee$, the \MCSS{} is $x$,
because
\[
\max \left\{ \sum_{k=i}^j a[k] \;:\; 0 \leq i <
    1, 0 \leq j < 1 \right\} = \sum_{k=0}^0 a[0] = a[0] = x\,.
\]
The theorem therefore holds.

For the inductive step, let $a$ be a sequence of length $n \ge 1$, and
assume inductively that for any sequence $a'$ of length $n' < n$, the
algorithm correctly computes the maximum contiguous subsequence sum.
Now consider the sequence $a$ and let $b$ and $c$ denote the left and
right subsequences resulted from dividing $a$ into two parts (i.e.,
$\cdvar{(b, c) = splitMid a}$).  
Furthermore, let $a\cirange{i}{j}$ be any contiguous subsequence of $a$
that has the largest sum, and this value is $v$.  
Note that the proof has to account for the possibility that there may
be many other subsequences with equal sum.  
Every contiguous subsequence must start somewhere and end after it.
We consider the following $3$ possibilities corresponding to how the
sequence $a\cirange{i}{j}$ lies with respect to $b$ and $c$:

\begin{itemize}
\item 
If the sequence $a\cirange{i}{j}$ starts in $b$ and ends $c$. Then its
sum equals its part in $b$ (a suffix of $b$) and its part in $c$ (a
prefix of $c$).  
If we take the maximum of all suffixes in $c$ and
prefixes in $b$ and add them this is equal the maximum of all
contiguous sequences bridging the two, because $\max\cset{x + y : x
  \in X, y \in Y\}} = \max\cset{x \in X} + \max\cset{y \in Y}$. 
By assumption this equals the sum of $a\cirange{i}{j}$ which is $v$.
Furthermore by induction $m_b$ and $m_c$ are sums of other
subsequences so they cannot be any larger than $v$ and hence
$\max\{m_b, m_c, m_{bc}\} = v$.


\item 
If $a\cirange{i}{j}$ lies entirely in $b$, then it follows from our
inductive hypothesis that $m_b = v$.  Furthermore $m_c$ and $m_{bc}$
correspond to the maximum sum of other subsequences, which cannot be
larger than $v$. 
So again $\max\{m_b, m_c, m_{bc}\} = v$.

\item Similarly, if $a_{i..j}$ lies entirely in $c$, then it follows
  from our inductive hypothesis that $m_c = \max\{m_b, m_c, m_{bc}\} =
  v$.

\end{itemize}

We conclude that in all cases, we return $\max\{m_b, m_c, m_{bc}\} = v$,
as claimed.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- proof -->

</segment> <!-- flex -->


</segment> <!-- subsubsection -->

<segment name='subsubsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::dc::first::cost
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::bestacross
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::bestacross
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>By Algorithm <a href="#alg:mcss::dc::first::bestacross" data-reference-type="ref" data-reference="alg:mcss::dc::first::bestacross">[alg:mcss::dc::first::bestacross]</a>, we know that the maximum subsequence crossing the cut in <span class="math inline">\(\Theta(n)\)</span> work and <span class="math inline">\(\Theta(\lg{n})\)</span> span. Note also that <span class="math inline">\(\mathit{splitMid}\)</span> requires <span class="math inline">\(O(1)\)</span> work and span for array sequences and <span class="math inline">\(O(\lg n)\)</span> work and span for tree sequences, so in either case the work and span are bounded by <span class="math inline">\(O(\lg n)\)</span>. We thus have the following recurrences with array-sequence or tree-sequence specifications <span class="math display">\[\begin{align*}  
  W(n) &amp;= 2W(n/2) + \Theta(n)\\  
  S(n) &amp;= S(n/2) +  \Theta(\lg n).  
\end{align*}\]</span></p>
<p>Using the definition of big-<span class="math inline">\(\Theta\)</span>, we know that <span class="math display">\[\begin{align*}  
  W(n) &amp;\leq 2W(n/2) + k_1\cdot n + k_2,  
\end{align*}\]</span> where <span class="math inline">\(k_1\)</span> and <span class="math inline">\(k_2\)</span> are constants. By using the tree method, we can conclude that <span class="math inline">\(W(n) = \Theta(n\lg{n})\)</span> and <span class="math inline">\(S(n) = \lg^2{n}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
By \algref{mcss::dc::first::bestacross}, we know that the maximum
subsequence crossing the cut in $\Theta(n)$ work and $\Theta(\lg{n})$
span.
Note also that $\cdvar{splitMid}$ requires $O(1)$ work and span for array sequences 
and $O(\lg n)$ work and span for tree sequences, so in either case the work and span
are bounded by $O(\lg n)$.
We thus have the following recurrences with array-sequence or
tree-sequence specifications
\[ \begin{align*}
  W(n) &= 2W(n/2) + \Theta(n)\\
  S(n) &= S(n/2) +  \Theta(\lg n).
\end{align*} \]

Using the definition of big-$\Theta$, we know
that
\[ \begin{align*}
  W(n) &\leq 2W(n/2) + k_1\cdot n + k_2,
\end{align*} \]
where $k_1$ and $k_2$ are constants.
By using the tree method, we can conclude that $W(n) = \Theta(n\lg{n})$ and
$S(n) = \lg^2{n}$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::solving-the-recurrence-using-substitution-method
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Solving the Recurrence Using Substitution Method
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Solving the Recurrence Using Substitution Method
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::solving-the-recurrence-using-substitution-method
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s now redo the recurrences above using the substitution method. Specifically, we’ll prove the following theorem using (strong) induction on <span class="math inline">\(n\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's now redo the recurrences above using the substitution method.
Specifically, we'll prove the following theorem using (strong)
induction on $n$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:thm:mcss::constant
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='theorem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
thm:mcss::constant
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let a constant <span class="math inline">\(k &gt; 0\)</span> be given. If <span class="math inline">\(W(n) \leq 2 W(n/2) + k \cdot n\)</span> for <span class="math inline">\(n &gt;  
  1\)</span> and <span class="math inline">\(W(1) \leq k\)</span> for <span class="math inline">\(n \leq 1\)</span>, then we can find constants <span class="math inline">\(\kappa_1\)</span> and <span class="math inline">\(\kappa_2\)</span> such that <span class="math display">\[W(n) \;\leq\; \kappa_1 \cdot n \lg n + \kappa_2.\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let a constant $k > 0$ be given.  If $W(n) \leq 2 W(n/2) + k \cdot n$ for $n >
  1$ and $W(1) \leq k$ for $n \leq 1$, then we can find constants $\kappa_1$ and
  $\kappa_2$ such that \[ W(n) \;\leq\; \kappa_1 \cdot n \lg n + \kappa_2.\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- theorem -->

<atom name='proof'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prf:mcss::assume
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let <span class="math inline">\(\kappa_1 = 2k\)</span> and <span class="math inline">\(\kappa_2 = k\)</span>. For the base case (<span class="math inline">\(n=1\)</span>), we check that <span class="math inline">\(W(1) = k \leq \kappa_2\)</span>. For the inductive step (<span class="math inline">\(n&gt;1\)</span>), we assume that <span class="math display">\[W(n/2) \leq \kappa_1 \cdot \tfrac{n}2 \lg (\tfrac{n}2) + \kappa_2,\]</span> And we’ll show that <span class="math inline">\(W(n) \leq \kappa_1 \cdot n \lg n + \kappa_2\)</span>. To show this, we substitute an upper bound for <span class="math inline">\(W(n/2)\)</span> from our assumption into the recurrence, yielding <span class="math display">\[\begin{align*}  
    W(n) \;&amp;\leq\; 2W(n/2) + k \cdot n  \\  
    \;&amp;\leq\; 2(\kappa_1 \cdot \tfrac{n}2 \lg (\tfrac{n}2) + \kappa_2) + k \cdot n\\  
    \;&amp;=\; \kappa_1 n (\lg n - 1) + 2 \kappa_2 + k \cdot n\\  
    \;&amp;=\; \kappa_1 n \lg n + \kappa_2 + (k \cdot n + \kappa_2 - \kappa_1 \cdot n)\\  
    \;&amp;\leq\; \kappa_1 n \lg n + \kappa_2,  
  \end{align*}\]</span> where the final step follows because <span class="math inline">\(k \cdot n + \kappa_2 - \kappa_1 \cdot n \leq  
  0\)</span> as long as <span class="math inline">\(n &gt; 1\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let $\kappa_1 = 2k$ and $\kappa_2 = k$.  For the base case ($n=1$), we check
  that $W(1) = k \leq \kappa_2$.  For the inductive step ($n>1$), we assume that
  \[
  W(n/2) \leq \kappa_1 \cdot \tfrac{n}2 \lg (\tfrac{n}2) + \kappa_2,
  \]
  And we'll show that $W(n) \leq \kappa_1 \cdot n \lg n + \kappa_2$.  To show
  this, we substitute an upper bound for $W(n/2)$ from our assumption into the
  recurrence, yielding
  \[ \begin{align*}
    W(n) \;&\leq\; 2W(n/2) + k \cdot n  \\
    \;&\leq\; 2(\kappa_1 \cdot \tfrac{n}2 \lg (\tfrac{n}2) + \kappa_2) + k \cdot n\\
    \;&=\; \kappa_1 n (\lg n - 1) + 2 \kappa_2 + k \cdot n\\
    \;&=\; \kappa_1 n \lg n + \kappa_2 + (k \cdot n + \kappa_2 - \kappa_1 \cdot n)\\
    \;&\leq\; \kappa_1 n \lg n + \kappa_2,
  \end{align*} \]
  where the final step follows because $k \cdot n + \kappa_2 - \kappa_1 \cdot n \leq
  0$ as long as $n > 1$.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- proof -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:tch:mcss::using
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='teachnote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tch:mcss::using
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Using divide and conquer, we were able to reduce work to <span class="math inline">\(\Theta(n\lg{n})\)</span> from <span class="math inline">\(\Theta(n^2)\)</span>, which was the bound that we obtained using the brute-fore algorithm. The improved brute-force algorithm still performs poorly, because it performs redundant work by considering seperately subsequences that overlap significantly.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Using divide and conquer, we were able to reduce work to
$\Theta(n\lg{n})$ from $\Theta(n^2)$, which was the bound that we
obtained using the brute-fore algorithm.
The improved brute-force algorithm still performs poorly, because it
performs  redundant work by considering seperately subsequences
that overlap significantly.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- teachnote -->

</segment> <!-- cluster -->


</segment> <!-- subsubsection -->

</segment> <!-- subsection -->

<segment name='subsection'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Divide And Conquer with Strengthening
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Divide And Conquer with Strengthening
]]>
</field> <!-- title_src -->
<field name='label'>
sec:mcss::divide-and-conquer-with-strengthening
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::divide-and-conquer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::divide-and-conquer
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Our first divide-and-conquer algorithm performs <span class="math inline">\(O(n \lg n)\)</span> work, which is <span class="math inline">\(O(\lg{n})\)</span> factor more than the optimal. In this section, we shall reduce the work to <span class="math inline">\(O(n)\)</span> by being more careful about avoiding redundant work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Our first divide-and-conquer algorithm performs $O(n \lg n)$ work,
which is $O(\lg{n})$ factor more than the optimal.
In this section, we shall reduce the work to $O(n)$ by being more
careful about avoiding redundant work.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::intuition
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Intuition
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Intuition
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::intuition
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Our divide-and-conquer algorithm has an important redundancy: the maximum prefix and maximum suffix are computed recursively to solve the subproblems for the two halves but are computed again at the combine step of the divide-and-conquer algorithm.</p>
<p>Because these are computed as part of solving the subproblems, we could return them from the recursive calls. To do this, we will strengthen the problem so that it returns the maximum prefix and suffix. This problem, which we shall call  <strong><em><span class="sans-serif">MCSSPS</span></em></strong> , matches the original <span class="sans-serif">MCSS</span> problem in its input and returns strictly more information. Solving <span class="sans-serif">MCSS</span> using <span class="sans-serif">MCSSPS</span> is therefore trivial. We thus focus on the <span class="sans-serif">MCSSPS</span> problem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Our divide-and-conquer algorithm has an important redundancy: the
maximum prefix and maximum suffix are computed recursively to solve
the subproblems for the two halves but are computed again at the
combine step of the divide-and-conquer algorithm.

Because these are computed as part of solving the subproblems, we
could return them from the recursive calls.  
To do this, we will strengthen the problem so that it returns the
maximum prefix and suffix.  
This problem, which we shall call~\defn{\MCSSPS{}}, matches the
original \MCSS{} problem in its input and returns strictly more
information.
Solving \MCSS{} using \MCSSPS{} is therefore trivial.  
We thus focus on the \MCSSPS{} problem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::solving-mcssps
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Solving MCSSPS
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Solving MCSSPS
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::solving-mcssps
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can solve this problem by strengthening our divide-and-conquer algorithm from the previous section. We need to return a total of three values:</p>
<ul>
<li><p>the max subsequence sum,</p></li>
<li><p>the max prefix sum, and</p></li>
<li><p>the max suffix sum.</p></li>
</ul>
<p>At the base cases, when the sequence is empty or consists of a single element, this is easy to do. For the recursive case, we need to consider how to produce the desired return values from those of the subproblems. Suppose that the two subproblems return <span class="math inline">\((m_1, p_1, s_1)\)</span> and <span class="math inline">\((m_2, p_2, s_2)\)</span>.</p>
<p>One possibility to compute as result <span class="math display">\[(\max(s_1+p_2, m_1, m_2), p_1, s_2).\]</span></p>
<p><img src="./mcss/media/mcss-dandc.jpg" alt="image" style="width:4.5in" /></p>
<p>Note that we don’t have to consider the case when <span class="math inline">\(s_1\)</span> or <span class="math inline">\(p_2\)</span> is the maximum, because that case is checked in the computation of <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> by the two subproblems.</p>
<p>This solution fails to account for the case when the suffix and prefix can span the whole sequence.</p>
<p>We can fix this problem by returning the total for each subsequence so that we can compute the maximum prefix and suffix correctly. Thus, we need to return a total of four values:</p>
<ul>
<li><p>the max subsequence sum,</p></li>
<li><p>the max prefix sum,</p></li>
<li><p>the max suffix sum, and</p></li>
<li><p>the overall sum.</p></li>
</ul>
<p>Having this information from the subproblems is enough to produce a similar answer tuple for all levels up, in constant work and span per level. Thus what we have discovered is that to solve the strengthened problem efficiently we have to strengthen the problem once again. Thus if the recursive calls return <span class="math inline">\((m_1, p_1, s_1, t_1)\)</span> and <span class="math inline">\((m_2,  
p_2, s_2, t_2)\)</span>, then we return <span class="math display">\[(\max(s_1+p_2, m_1, m_2), \max(p_1,  
  t_1+p_2), \max(s_1+t_2, s_2), t_1+t_2).\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can solve this problem by strengthening our divide-and-conquer
algorithm from the previous section.
We need to return a total of three values: 
\begin{itemize}
\item the max subsequence sum,
\item the max prefix sum, and
\item the max suffix sum.
\end{itemize}

At the base cases, when the sequence is empty or consists of a single
element, this is easy to do.
For the recursive case, we need to consider how to produce the desired
return values from those of the subproblems.
Suppose that the two subproblems return  $(m_1, p_1, s_1)$ and $(m_2, p_2, s_2)$.

One possibility to compute as result
\[
  (\max(s_1+p_2, m_1, m_2), p_1, s_2).
\]


\includegraphics[width=4.5in]{./mcss/media/mcss-dandc.jpg}


Note that we don't have to consider the case when $s_1$ or $p_2$ is
the maximum, because that case is checked in the computation of $m_1$
and $m_2$ by the two subproblems.


This solution fails to account for the case when the suffix and
prefix can span the whole sequence.

We can fix this problem by returning the total for each subsequence so
that we can compute the maximum prefix and suffix correctly.  Thus, we
need to return a total of four values: 
\begin{itemize}
\item the max subsequence sum,
\item the
max prefix sum, 
\item the max suffix sum, and 
\item the overall sum.
\end{itemize}

Having this information from the subproblems is enough to produce a
similar answer tuple for all levels up, in constant work and span per
level. Thus what we have discovered is that to solve the strengthened
problem efficiently we have to strengthen the problem once again.
Thus if the recursive calls return $(m_1, p_1, s_1, t_1)$ and $(m_2,
p_2, s_2, t_2)$, then we return
\[
  (\max(s_1+p_2, m_1, m_2), \max(p_1,
  t_1+p_2), \max(s_1+t_2, s_2), t_1+t_2).
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:alg:mcss::linear-work-divide-and-conquer-mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='algorithm'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Linear Work Divide-and-Conquer MCSS
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Linear Work Divide-and-Conquer MCSS
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
alg:mcss::linear-work-divide-and-conquer-mcss
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[\begin{array}{l}  
\mathit{MCSSDCAux}~a =   
\\  
~~~~\texttt{if}~|a| = 0~\texttt{then}  
\\  
~~~~~~~~({-\infty}{},{-\infty}{},{-\infty}{},0)  
\\  
~~~~\texttt{else}~if |a| = 1 \texttt{then}  
\\  
~~~~~~~~(a[0], a[0], a[0], a[0])  
\\  
~~~~\texttt{else}  
\\  
~~~~~~~~\texttt{let}   
\\  
~~~~~~~~~~~~(b,c) = \mathit{splitMid}~a   
\\  
~~~~~~~~~~~~((m_1, p_1, s_1, t_1), (m_2, p_2, s_2, t_2)) = (\mathit{MCSSDCAux}~b~\mid\mid{}~\mathit{MCSSDCAux}~c)  
\\  
~~~~~~~~\texttt{in}   
\\  
~~~~~~~~~~~~(\mathit{max}~(s_1+p_2, m_1, m_2),     
\\  
~~~~~~~~~~~~~\mathit{max}~(p_1, t_1+p_2),        
\\  
~~~~~~~~~~~~~\mathit{max}~(s_1+t_2, s_2),       
\\  
~~~~~~~~~~~~~t_1+t_2)                
\\  
~~~~~~~~\texttt{end}  
\\  
\mathit{MCSSDC}~a =   
\\  
~~~~\texttt{let}   
\\  
~~~~~~~~(m, \_, \_, \_) = \mathit{MCSSDCAux}~a   
\\  
~~~~\texttt{in}  
\\  
~~~~~~~~m   
\\  
~~~~\texttt{end}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\[
\begin{array}{l}
\cdvar{MCSSDCAux}~a = 
\\
~~~~\cd{if}~|a| = 0~\cd{then}
\\
~~~~~~~~(\ninfty{},\ninfty{},\ninfty{},0)
\\
~~~~\cd{else}~if |a| = 1 \cd{then}
\\
~~~~~~~~(a[0], a[0], a[0], a[0])
\\
~~~~\cd{else}
\\
~~~~~~~~\cd{let} 
\\
~~~~~~~~~~~~(b,c) = \cdvar{splitMid}~a 
\\
~~~~~~~~~~~~((m_1, p_1, s_1, t_1), (m_2, p_2, s_2, t_2)) = (\cdvar{MCSSDCAux}~b~\cpar{}~\cdvar{MCSSDCAux}~c)
\\
~~~~~~~~\cd{in} 
\\
~~~~~~~~~~~~(\cdvar{max}~(s_1+p_2, m_1, m_2),   
\\
~~~~~~~~~~~~~\cdvar{max}~(p_1, t_1+p_2),      
\\
~~~~~~~~~~~~~\cdvar{max}~(s_1+t_2, s_2),     
\\
~~~~~~~~~~~~~t_1+t_2)              
\\
~~~~~~~~\cd{end}
\\
\cdvar{MCSSDC}~a = 
\\
~~~~\cd{let} 
\\
~~~~~~~~(m, \_, \_, \_) = \cdvar{MCSSDCAux}~a 
\\
~~~~\cd{in}
\\
~~~~~~~~m 
\\
~~~~\cd{end}
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- algorithm -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::analysis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost Analysis
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::analysis
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Since <span class="math inline">\(\mathit{splitMid}\)</span> requires <span class="math inline">\(O(\lg n)\)</span> work and span in both array and tree sequences, we have <span class="math display">\[\begin{align*}  
  W(n) &amp;= 2 W(n/2) + O(\lg n)\\  
  S(n) &amp;= S(n/2) + O(\lg n).  
\end{align*}\]</span> The <span class="math inline">\(O(\lg{n})\)</span> bound on <span class="math inline">\(\mathit{splitMid}\)</span> is not tight for array sequences, where <span class="math inline">\(\mathit{splitMid}\)</span> requires <span class="math inline">\(O(1)\)</span> work, but this loose upper bound suffices to achieve the bound on the work that we seek. Note that the span is the same as before, so we’ll focus on analyzing the work. Using the tree method, we have</p>
<p><img src="./mcss/media/recurtree2.jpg" alt="image" style="width:5in" /></p>
<p>Therefore, the total work is upper-bounded by <span class="math display">\[\begin{aligned}
  W(n) &amp;\leq&amp; \sum_{i=0}^{\lg n} k_1 2^i \lg (n/2^i)  \end{aligned}\]</span></p>
<p>It is not so obvious to what this sum evaluates, but we can bound it as follows: <span class="math display">\[\begin{align*}  
  W(n) &amp;\leq \sum_{i=0}^{\lg n} k_1 2^i \lg (n/2^i) \\  
  &amp;= \sum_{i=0}^{\lg n} k_1 \left(2^i\lg n - i\cdot 2^i\right) \\  
  &amp;= k_1\left(\sum_{i=0}^{\lg n} 2^i\right)\lg n - k_1\sum_{i=0}^{\lg n} i\cdot 2^i\\  
  &amp;= k_1(2n - 1)\lg n - k_1\sum_{i=0}^{\lg n} i\cdot 2^i.  
\end{align*}\]</span></p>
<p>We’re left with evaluating <span class="math inline">\(s = \sum_{i=0}^{\lg n} i\cdot 2^i\)</span>. Observe that if we multiply <span class="math inline">\(s\)</span> by <span class="math inline">\(2\)</span>, we have <span class="math display">\[2s = \sum_{i=0}^{\lg n} i\cdot 2^{i+1} = \sum_{i=1}^{1 + \lg n} (i-1)2^i,\]</span> so then <span class="math display">\[\begin{align*}  
s &amp;= 2s - s \;=\; \sum_{i=1}^{1 + \lg n} (i-1)2^i - \sum_{i=0}^{\lg n} i\cdot 2^i\\  
&amp;= \left((1 + \lg n)  - 1\right)2^{1 + \lg n} - \sum_{i=1}^{\lg n} 2^i \\  
&amp;= 2n\lg n - (2n -2).  
\end{align*}\]</span> Substituting this back into the expression we derived earlier, we have <span class="math inline">\(W(n)  
\leq k_1(2n - 1)\lg n - 2k_1(n \lg n - n + 1) \in O(n)\)</span> because the <span class="math inline">\(n\lg n\)</span> terms cancel.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Since $\cdvar{splitMid}$ requires $O(\lg n)$ work and
span in both array and tree sequences, we have
\[ \begin{align*}
  W(n) &= 2 W(n/2) + O(\lg n)\\
  S(n) &= S(n/2) + O(\lg n).
\end{align*} \]
The $O(\lg{n})$ bound on $\cdvar{splitMid}$ is not tight for array sequences, where $\cdvar{splitMid}$ requires $O(1)$ work, but this loose upper bound suffices to achieve the bound on the work that we seek.
Note that the
span is the same as before, so we'll focus on analyzing the work.  Using the
tree method, we have
\begin{center}
  \includegraphics[width=5in]{./mcss/media/recurtree2.jpg}
\end{center}

Therefore, the total work is upper-bounded by
\begin{eqnarray*}
  W(n) &\leq& \sum_{i=0}^{\lg n} k_1 2^i \lg (n/2^i)
\end{eqnarray*}

It is not so obvious to what this sum evaluates, but we can bound it
as follows:
\[ \begin{align*}
  W(n) &\leq \sum_{i=0}^{\lg n} k_1 2^i \lg (n/2^i) \\
  &= \sum_{i=0}^{\lg n} k_1 \pparen{2^i\lg n - i\cdot 2^i} \\
  &= k_1\pparen{\sum_{i=0}^{\lg n} 2^i}\lg n - k_1\sum_{i=0}^{\lg n} i\cdot 2^i\\
  &= k_1(2n - 1)\lg n - k_1\sum_{i=0}^{\lg n} i\cdot 2^i.
\end{align*} \]

We're left with evaluating $s = \sum_{i=0}^{\lg n} i\cdot 2^i$.  Observe that
if we multiply $s$ by $2$, we have
\[
2s = \sum_{i=0}^{\lg n} i\cdot 2^{i+1} = \sum_{i=1}^{1 + \lg n} (i-1)2^i,
\]
so then
\[ \begin{align*}
s &= 2s - s \;=\; \sum_{i=1}^{1 + \lg n} (i-1)2^i - \sum_{i=0}^{\lg n} i\cdot 2^i\\
&= \pparen{(1 + \lg n)  - 1}2^{1 + \lg n} - \sum_{i=1}^{\lg n} 2^i \\
&= 2n\lg n - (2n -2).
\end{align*} \]
Substituting this back into the expression we derived earlier, we have $W(n)
\leq k_1(2n - 1)\lg n - 2k_1(n \lg n - n + 1) \in O(n)$ because the $n\lg n$
terms cancel.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::solve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::solve
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can solve the recurrency by using substitution method also. We’ll make a guess that <span class="math inline">\(W(n) \leq \kappa_1 n - \kappa_2 \lg n - k_3\)</span>. More precisely, we prove the following theorem.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can solve the recurrency by using substitution method also.  We'll
make a guess that $W(n) \leq \kappa_1 n - \kappa_2 \lg n - k_3$.
More precisely, we prove the following theorem.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:mcss::given
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:mcss::given
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let <span class="math inline">\(k &gt; 0\)</span> be given. If <span class="math inline">\(W(n) \leq 2 W(n/2) + k \cdot \lg n\)</span> for <span class="math inline">\(n &gt; 1\)</span> and <span class="math inline">\(W(n) \leq k\)</span> for <span class="math inline">\(n \leq 1\)</span>, then we can find constants <span class="math inline">\(\kappa_1\)</span>, <span class="math inline">\(\kappa_2\)</span>, and <span class="math inline">\(\kappa_3\)</span> such that <span class="math display">\[W(n) \;\leq\; \kappa_1 \cdot n -  
  \kappa_2 \cdot \lg n - \kappa_3.\]</span></p>
<p>Let <span class="math inline">\(\kappa_1 = 3k\)</span>, <span class="math inline">\(\kappa_2 = k\)</span>, <span class="math inline">\(\kappa_3 = 2k\)</span>. We begin with the base case. Clearly, <span class="math inline">\(W(1) = k \leq \kappa_1 - \kappa_3 = 3k - 2k = k\)</span>. For the inductive step, we substitute the inductive hypothesis into the recurrence and obtain <span class="math display">\[\begin{align*}  
    W(n) &amp;\leq 2W(n/2) + k \cdot \lg n\\  
    &amp;\leq 2 (\kappa_1 \tfrac{n}2 - \kappa_2 \lg (n/2) - \kappa_3) + k \cdot\lg n\\  
    &amp;= \kappa_1 n - 2 \kappa_2 (\lg n - 1) - 2 \kappa_3 + k \cdot \lg n\\  
    &amp;= (\kappa_1 n - \kappa_2 \lg n - \kappa_3) +  
    (k \lg n - \kappa_2 \lg n + 2 \kappa_2 - \kappa_3) \\  
    &amp;\leq \kappa_1 n - \kappa_2 \lg n - \kappa_3,  
  \end{align*}\]</span> where the final step uses the fact that <span class="math inline">\((k \lg n - \kappa_2 \lg n +  
  2 \kappa_2 - \kappa_3) = (k \lg n - k \lg n + 2 k - 2 k) = 0   
 \leq 0\)</span> by our choice of <span class="math inline">\(\kappa\)</span>’s.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{theorem}
  Let $k > 0$ be given.  If $W(n) \leq 2 W(n/2) + k \cdot \lg n$ for $n > 1$
  and $W(n) \leq k$ for $n \leq 1$, then we can find constants $\kappa_1$,
  $\kappa_2$, and $\kappa_3$ such that \[ W(n) \;\leq\; \kappa_1 \cdot n -
  \kappa_2 \cdot \lg n - \kappa_3.\]
\end{theorem}
\begin{proof}
  Let $\kappa_1 = 3k$, $\kappa_2 = k$, $\kappa_3 = 2k$. We begin with
  the base case. Clearly, $W(1) = k \leq \kappa_1 - \kappa_3 = 3k - 2k = k$.
  For the inductive step, we substitute the inductive hypothesis into
  the recurrence and obtain
  \[ \begin{align*}
    W(n) &\leq 2W(n/2) + k \cdot \lg n\\
    &\leq 2 (\kappa_1 \tfrac{n}2 - \kappa_2 \lg (n/2) - \kappa_3) + k \cdot\lg n\\
    &= \kappa_1 n - 2 \kappa_2 (\lg n - 1) - 2 \kappa_3 + k \cdot \lg n\\
    &= (\kappa_1 n - \kappa_2 \lg n - \kappa_3) +
    (k \lg n - \kappa_2 \lg n + 2 \kappa_2 - \kappa_3) \\
    &\leq \kappa_1 n - \kappa_2 \lg n - \kappa_3,
  \end{align*} \]
  where the final step uses the fact that $(k \lg n - \kappa_2 \lg n +
  2 \kappa_2 - \kappa_3) = (k \lg n - k \lg n + 2 k - 2 k) = 0 
 \leq 0$ by our choice of $\kappa$'s.
\end{proof}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- flex -->


</segment> <!-- subsection -->

</segment> <!-- section -->

</segment> <!-- chapter -->
