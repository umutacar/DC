<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
100.
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Exam II (Practice)
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Exam II (Practice)
]]>
</field> <!-- title_src -->
<field name='label'>
ch:examii-practice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prmbl:examii-practice::minutes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='preamble'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prmbl:examii-practice::minutes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<ul>
<li><p>You have 80 minutes to complete this examination.</p></li>
<li><p>Please answer all questions in the space provided with the question. Clearly indicate your answers.</p></li>
<li><p>You may refer to your one double-sided <span class="math inline">\(8\frac{1}{2} \times 11\)</span>in sheet of paper with notes, but to no other person or source, during the examination.</p></li>
<li><p>Your answers for this exam must be written in blue or black ink.</p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{itemize}
\item You have 80 minutes to complete this examination.
\item Please answer all questions in the space provided with the
  question.  Clearly indicate your answers.
\item You may refer to your one double-sided $8\frac{1}{2} \times 11$in
  sheet of paper with notes, but to no other person or source, during the
  examination.

\item Your answers for this exam must be written in blue or black ink.

\end{itemize}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- preamble -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
10.
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
True or False
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
True or False
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::true-or-false
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Short Answers
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Short Answers
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::short-answers
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::classes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Classes
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Classes
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::classes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
4.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Lets say you are given a table that maps every student to the set of classes they take.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Final}

Lets say you are given a table that maps every student to the set of
classes they take.
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
4.
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::fill
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Fill in the algorithm below that returns all classes, assuming there is at least one student in each class. Your algorithm must run in <span class="math inline">\(O(m \log n)\)</span> work and <span class="math inline">\(O((\log m)(\log n))\)</span> span, where <span class="math inline">\(n\)</span> is the number of students and <span class="math inline">\(m\)</span> is the sum of the number of classes taken across all students. Note, our solution is one line.</p>
<pre data-numbers="none"><code>fun allClasses($T$ : classSet studentTable) : classSet =   
@\vspace{.5in}@  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Fill in the algorithm below that returns all classes,
assuming there is at least one student in each class.  Your algorithm
must run in $O(m \log n)$ work and $O((\log m)(\log n))$ span, where
$n$ is the number of students and $m$ is the sum of the number of
classes taken across all students.    Note, our solution is one line.

\begin{lstlisting}[numbers=none]
fun allClasses($T$ : classSet studentTable) : classSet = 
@\vspace{.5in}@
\end{lstlisting}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::numbers
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<pre data-numbers="none"><code>fun allClasses($T$) = Table.reduce Set.union $\emptyset$ $T$  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{lstlisting}[numbers=none]
fun allClasses($T$) = Table.reduce Set.union $\emptyset$ $T$
\end{lstlisting}
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::shortest-weighted
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Shortest Weighted
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Shortest Weighted
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::shortest-weighted
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
5.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Given a graph with integer edge weights between <span class="math inline">\(1\)</span> and <span class="math inline">\(5\)</span> (inclusive), you want to find the shortest <em>weighted</em> path between a pair of vertices.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Practice Exam II}

Given a graph with integer edge weights between $1$ and $5$
(inclusive), you want to find the shortest \emph{weighted} path
between a pair of vertices.
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::would
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>How would you reduce this problem to the shortest <em>unweighted</em> path problem, which can be solved using BFS?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
How would you reduce this problem to the
shortest \emph{unweighted} path problem, which can be solved using
BFS?
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::replace
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Replace each edge with weight <span class="math inline">\(i\)</span> with a simple path of <span class="math inline">\(i\)</span> edges each with weight <span class="math inline">\(1\)</span>. Then solve with BFS.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Replace each edge with weight $i$ with a simple path of $i$ edges
each with weight $1$. Then solve with BFS.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::enter-and-exit
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Enter and Exit
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Enter and Exit
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::enter-and-exit
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
5.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Recall the implementation of DFS shown in class using the <code>enter</code> and <code>exit</code> functions. Circle the correct answer for each of the following statements, assuming DFS starts at <span class="math inline">\(A\)</span>:</p>
<p><embed src="dfs/dfs-graph1.pdf" /></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>enter D</code> could be called before <code>enter E</code>:</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="sans-serif">True</span></td>
<td style="text-align: center;"><span class="sans-serif">False</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>enter E</code> could be called before <code>enter D</code>:</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="sans-serif">True</span></td>
<td style="text-align: center;"><span class="sans-serif">False</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>enter D</code> could be called before <code>enter C</code>:</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="sans-serif">True</span></td>
<td style="text-align: center;"><span class="sans-serif">False</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>exit A</code> could be called before <code>exit B</code>:</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="sans-serif">True</span></td>
<td style="text-align: center;"><span class="sans-serif">False</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>exit D</code> could be called before <code>enter B</code>:</td>
<td style="text-align: left;"></td>
<td style="text-align: center;"><span class="sans-serif">True</span></td>
<td style="text-align: center;"><span class="sans-serif">False</span></td>
</tr>
</tbody>
</table>
<p>True, True, True, False, True</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Practice Exam II}

Recall the implementation of DFS shown in class using the \sml{enter}
and \sml{exit} functions. Circle the correct answer for each of the
following statements, assuming DFS starts at $A$:

\begin{center}
  \includegraphics[scale=.7]{dfs/dfs-graph1.pdf}
\end{center}

\bigskip
  \begin{tabular}{lp{1.3in}cc}
    \texttt{enter D} could be called before \texttt{enter E}:& &
    \textsf{True} & \textsf{False}\\[1.5 ex]
    \texttt{enter E} could be called before \texttt{enter D}:& & \textsf{True} & \textsf{False}\\[1.5 ex]
    \texttt{enter D} could be called before \texttt{enter C}:& & \textsf{True} & \textsf{False}\\[1.5 ex]
    \texttt{exit A} could be called before \texttt{exit B}: & & \textsf{True} & \textsf{False}\\[1.5 ex]
    \texttt{exit D} could be called before \texttt{enter B}:&  & \textsf{True} & \textsf{False}
  \end{tabular}

\sol
    True, True, True, False, True
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::fall
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::fall
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
5.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A new startup <em>FastRoute</em> wants to route information along a path in a communication network, represented as a graph. Each vertex represents a router and each edge a wire between routers. The wires are weighted by the maximum bandwidth they can support. <em>FastRoute</em> comes to you and asks you to develop an algorithm to find the path with maximum bandwidth from any source <span class="math inline">\(s\)</span> to any destination <span class="math inline">\(t\)</span>. As you would expect, the <em>bandwidth</em> of a path is the minimum of the bandwidths of the edges on that path; the minimum edge is the <em>bottleneck</em>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Practice Exam II}

A new startup \emph{FastRoute} wants to route information along a path
in a communication network, represented as a graph. Each vertex
represents a router and each edge a wire between routers. The wires
are weighted by the maximum bandwidth they can
support. \emph{FastRoute} comes to you and asks you to develop an
algorithm to find the path with maximum bandwidth from any source $s$
to any destination $t$. As you would expect, the \emph{bandwidth} of a
path is the minimum of the bandwidths of the edges on that path; the
minimum edge is the \emph{bottleneck}.
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::explain
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Explain how to modify Dijkstra’s algorithm to do this. In particular, how would you change the priority queue and the following relax step?</p>
<blockquote>
<p><code>fun relax (Q, (u,v,w)) = PQ.insert (d(u) + w, v) Q</code></p>
</blockquote>
<p>Justify your answer.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Explain how to modify Dijkstra's algorithm to do this. In particular, how would
you change the priority queue and the following relax step?

\begin{quote}
\sml{fun relax (Q, (u,v,w)) = PQ.insert (d(u) + w, v) Q}
\end{quote}

Justify your answer.
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::priority
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>We’ll use a max priority queue instead of a min priority queue used in Dijkstra’s. We will also modify the relax step to insert into the priority queue <span class="math inline">\(\min(d(u), w)\)</span> because the quality of a path is the minimum of the edge weights. These changes don’t affect the correctness of Dijkstra’s, so we could explore the vertices like in Dijkstra’s.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We'll use a max priority queue instead of a min priority queue used
  in Dijkstra's. We will also modify the relax step to insert into the
  priority queue $\min(d(u), w)$ because the quality of a path is the
  minimum of the edge weights. These changes don't affect the
  correctness of Dijkstra's, so we could explore the vertices like in
  Dijkstra's.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::parallel-cycle-detection
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Parallel Cycle Detection
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Parallel Cycle Detection
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::parallel-cycle-detection
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
4.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::describe
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Describe in words how you would as part of star contraction efficiently detect that an undirected graph has a cycle. <strong>No more than two sentences.</strong></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Describe in words how you would as part of star contraction 
efficiently detect that an undirected graph has a cycle.  \textbf{No more than two sentences.}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::star
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>If during star contraction we find any self edges not involved in contraction itself then there is a cycle. However, we need to be careful not to remove duplicate edges, and only to contract along a single duplicate edge.</p>
<p>-4 if claim detecting duplicate edges is sufficient. It is not sufficient because you can contract duplicate edges at the same time<br />
-2 if say detect self edge, but do not point out issue with duplicates.<br />
0 for DFS, BFS, etc.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If during star contraction we find any self edges not involved in
contraction itself then there is a cycle.   However,
we need to be careful not to remove duplicate edges, and only to
contract along a single duplicate edge.

-4 if claim detecting duplicate edges is sufficient.  It is not sufficient because you can contract duplicate edges at the same time\\
-2 if say detect self edge, but do not point out issue with duplicates.\\
0 for DFS, BFS, etc.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::star-contraction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
Star Contraction
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Star Contraction
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::star-contraction
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
6.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::circle
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Circle <strong>every</strong> type of graph listed below for which star contraction will reduce the number of <strong>edges</strong> by a constant factor in expectation in every round until fully reduced (and hence imply <span class="math inline">\(O(|E|)\)</span> total work). You can assume redundant edges between vertices are removed.<br />
(a) a graph in which all vertices have degree at most 2<br />
(b) a graph in which all vertices have degree at most 3<br />
(c) a graph in which all vertices have degree <span class="math inline">\(\sqrt{|V|}\)</span><br />
(d) a graph containing a single cycle (i.e. a forest with one additional edge)<br />
(e) the complete graph (i.e. an edge between every pair of vertices)<br />
(f) any graph (still circle others if relevant)<br />
</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Circle \textbf{every} type of graph listed below for which star
contraction will reduce the number of \textbf{edges} by a constant
factor in expectation in every round until fully reduced (and hence
imply $O(|E|)$ total work).  You can assume redundant edges between
vertices are removed.\\

(a) a graph in which all vertices have degree at most 2\\
(b) a graph in which all vertices have degree at most 3\\
(c) a graph in which all vertices have degree $\sqrt{|V|}$\\
(d) a graph containing a single cycle (i.e. a forest with one additional edge)\\
(e) the complete graph (i.e. an edge between every pair of vertices)\\
(f) any graph (still circle others if relevant)\\
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::_1_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>a, d, e</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
a, d, e
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::dfs-edges
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
DFS Edges
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
DFS Edges
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::dfs-edges
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The following questions have to do with the four types of edges in a depth first search (DFS): <strong>tree edges</strong>, <strong>back edges</strong>, <strong>forward edges</strong> and <strong>cross edges</strong>. For each one list <strong>all</strong> types of edges that apply.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The following questions have to do with the four types of edges in
a depth first search (DFS): \textbf{tree edges}, \textbf{back edges},
\textbf{forward edges} and \textbf{cross edges}.  For each one list
\textbf{all} types of edges that apply.
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
3.
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::kind
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>What kind of edges can a <strong>bridge</strong>, as defined in AbridgedLab, be</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
What kind of edges can a \textbf{bridge}, as defined in AbridgedLab, be
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::tree
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>tree edge</p>
<p>Assume we enter <span class="math inline">\(u\)</span> before entering <span class="math inline">\(v\)</span> during the DFS, what kind of edge can the edge <span class="math inline">\((u,v)\)</span> (directed from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>) be?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
tree edge

\ask[3]
Assume we enter $u$ before entering $v$ during the DFS, what kind of
edge can the edge $(u,v)$ (directed from $u$ to $v$) be?
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::forward
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>forward edge, tree edge</p>
<p>What kind of edges can appear in DFS for a directed graph in which every edge appears in both directions (i.e. if <span class="math inline">\((u,v) \in E\)</span> then <span class="math inline">\((v,u)  
\in E\)</span>).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
forward edge, tree edge


\ask[3]
What kind of edges can appear in DFS for a directed graph in which
every edge appears in both directions (i.e. if $(u,v) \in E$ then $(v,u)
\in E$).
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::edges
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>tree edges, forward edges, backward edges</p>
<p>Lets say that in a directed graph <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> are in two different strongly connected components (in a strongly connected component all vertices can reach all others). What kind of edges can be between <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
tree edges, forward edges, backward edges


\ask[3] Lets say that in a directed graph $u$ and $v$ are in two
different strongly connected components (in a strongly connected
component all vertices can reach all others).  What kind of edges can
be between $u$ and $v$.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::cross
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>tree edges, forward edges, cross edges</p>
<p>In the topological sorting algorithm for directed acyclic graph we described in class and the notes, lets say a vertex <span class="math inline">\(u\)</span> appears after a vertex <span class="math inline">\(v\)</span>. What kind of edges can be in a path from <span class="math inline">\(v\)</span> to <span class="math inline">\(u\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
tree edges, forward edges, cross edges

\ask[3]
In the topological sorting algorithm for directed acyclic graph we
described in class and the notes, lets say a vertex $u$ appears
after a vertex $v$.  What kind of edges can be in a path
from $v$ to $u$.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::_2_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>tree edges, forward edges, cross edges</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
tree edges, forward edges, cross edges
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
(Sets and Tables) Bingled
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
(Sets and Tables) Bingled
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::sets-and-tables-bingled
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::forming
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::forming
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>After forming your company Bingle to index the web allowing word searches based on logical combination of terms (e.g. “big” and “small”), you discover that there are already a couple companies out there that do it....and lo-and-behold, they even have similar names. You therefore decide to extend yours with additional features. In particular you want to support phrase queries: e.g. find all documents where “fun algorithms” appears.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
After forming your company Bingle to index the web allowing word
searches based on logical combination of terms (e.g. ``big'' and
``small''), you discover that there are already a couple companies out
there that do it....and lo-and-behold, they even have similar names.
You therefore decide to extend yours with additional features.  In
particular you want to support phrase queries: e.g. find all
documents where ``fun algorithms'' appears.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::decide
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::decide
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You decide the right way to represent the index is as a table of sets where the keys of the table are strings (i.e. the words) and the elements of the sets are pairs of values consisting of a document identifier and an integer location in the document where the string appears. So, for example the following collection of three documents with integer document identifiers:</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You decide the right way to represent the index is as a table of sets
where the keys of the table are strings (i.e. the words) and the
elements of the sets are pairs of values consisting of a document
identifier and an integer location in the document where the string
appears.  So, for example the following collection of three documents
with integer document identifiers:
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:qut:examii-practice::read
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='quote'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
qut:examii-practice::read
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math inline">\(\langle\)</span> (̄1, ),<br />
(2, ),<br />
(3, ) <span class="math inline">\(\rangle\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{tabbing}
 $\langle$
  \=(1, \ctext{``the big dog''}), \\
  \>(2, \ctext{``a big dog ate a hat''}),\\
  \>(3, \ctext{``i read a big book''}) $\rangle$
\end{tabbing}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- quote -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::document
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::document
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>the document index would be represented as <span class="math display">\[\begin{array}{ll}  
\text{idx} = \{ &amp; \mbox{\rm\em ``a&#39;&#39;} \mapsto \left\{ (2,0),(2,4),(3,2) \right\}  
\\  
                &amp;  \mbox{\rm\em ``big&#39;&#39;} \mapsto \left\{ (1,1),(2,1),(3,3) \right\},  
\\  
                &amp; \mbox{\rm\em ``dog&#39;&#39;} \mapsto \left\{ (1,2),(2,2) \right\},  
\\  
                &amp; \ldots  
\\  
             \} &amp;  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
the document index would be represented as
\[
\begin{array}{ll}
\text{idx} = \{ & \ctext{``a''} \mapsto \cset{(2,0),(2,4),(3,2)}
\\
                &  \ctext{``big''} \mapsto \cset{(1,1),(2,1),(3,3)},
\\
                & \ctext{``dog''} \mapsto \cset{(1,2),(2,2)},
\\
                & \ldots
\\
             \} &
\end{array}
\]
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::particular
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::particular
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In particular you want to support the following interface</p>
<pre data-numbers="none"><code>signature INDEX = sig  
  type word = string  
  type docId = int  
  type index = docIdIntSet wordTable  
    
  (* represents all documents and all locations where a phrase appears *)  
  type docList  
  
  val makeIndex : (docId * string) seq -&gt; index      
  val find : index -&gt; word -&gt; docList  
  val adj : docList * docList -&gt; docList  
  val toSeq : docList -&gt; docId seq   
end  </code></pre>
<p>where, given an index <code>I</code>, <code>toSeq (adj (find I "210", find I "rocks"))</code> would return a sequence of identifiers of documents where “210” appears immediately before “rocks”, and<br />
<code>toSeq (adj (find I "Umut", adj (find I "loves", find I "climbing")))</code><br />
would return a sequence of identifiers of documents where the phrase “Umut loves climbing” appears.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In particular you want to support the following interface
\begin{lstlisting}[numbers=none]
signature INDEX = sig
  type word = string
  type docId = int
  type index = docIdIntSet wordTable
  
  (* represents all documents and all locations where a phrase appears *)
  type docList

  val makeIndex : (docId * string) seq -> index    
  val find : index -> word -> docList
  val adj : docList * docList -> docList
  val toSeq : docList -> docId seq 
end
\end{lstlisting}
where, given an index \sml{I},
\texttt{toSeq (adj (find I "210", find I "rocks"))} would return a sequence of
identifiers of documents
where ``210'' appears immediately before ``rocks'', and 
\\
\sml{toSeq (adj (find I "Umut", adj (find I "loves", find I "climbing")))}
\\
would return a sequence of identifiers of documents
where the phrase ``Umut loves climbing'' appears.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::show
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::show
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
8.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::show
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Show SML code to generate the index from the sequence of documents. It should not be more than 8 lines of code and assuming all words have length less than some constant, must run in <span class="math inline">\(O(n \log n)\)</span> work and <span class="math inline">\(O(\log^2 n)\)</span> span, where <span class="math inline">\(n\)</span> is the total number of words across all documents. You can use a function</p>
<pre><code>val toWords~:~string -&gt; string seq  </code></pre>
<p>that breaks a text string into a sequence of words.</p>
<pre data-numbers="none"><code>type index = docIdIntSet wordTable  
  
fun makeIndex (docs : (docId  * string) seq) : index =  
  let  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Show SML code to generate the index from the sequence of documents.
It should not be more than 8 lines of code and assuming all words have
length less than some constant, must run in $O(n \log n)$ work and
$O(\log^2 n)$ span, where $n$ is the total number of words across all
documents.    You can use a function
\begin{lstlisting}
val toWords~:~string -> string seq
\end{lstlisting}
that breaks a text string into a sequence of words.

\begin{lstlisting}[numbers=none]
type index = docIdIntSet wordTable

fun makeIndex (docs : (docId  * string) seq) : index =
  let
\end{lstlisting}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::none
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<pre><code> [numbers=none]  
  fun tagWords (id,doc) =   
      let val words = toWords doc  
      in  Seq.tabulate (fn i = (nth i words, (id, i)) (length words)   
      end  
  
  val allPairs = Seq.flatten (Seq.map tagWords docs)  
  
  val wordTable = Table.collect allPairs  
in  
    Table.map Set.fromSeq wordTable  
end  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{lstlisting} [numbers=none]
  fun tagWords (id,doc) = 
      let val words = toWords doc
      in  Seq.tabulate (fn i = (nth i words, (id, i)) (length words) 
      end

  val allPairs = Seq.flatten (Seq.map tagWords docs)

  val wordTable = Table.collect allPairs
in
    Table.map Set.fromSeq wordTable
end
\end{lstlisting}
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::define
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::define
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
8.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::define
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Define the <code>docList</code> type and implement the function <code>adj</code> as defined above. You might find the function <code>setmap</code> useful. The solution should only be a few lines of code.</p>
<pre data-numbers="none"><code>fun setmap f s = Set.fromSeq (Seq.map f (Set.toSeq s))   </code></pre>
<pre data-numbers="none"><code>  
type docList =   
  
fun adj (                ,               ) : docList =  
  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Define the \sml{docList} type and implement the function \sml{adj} as defined above.
You might find the function \sml{setmap} useful. The solution should
only be a few lines of code.
\begin{lstlisting}[numbers=none]
fun setmap f s = Set.fromSeq (Seq.map f (Set.toSeq s)) 
\end{lstlisting}


\begin{lstlisting}[numbers=none]

type docList = 

fun adj (                ,               ) : docList =

\end{lstlisting}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::type
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<pre data-numbers="none"><code>type docList = (docIdIntSet)*int  
  
fun adj ((d1,l1), (d2,l2)) =   
  let   
      val d2&#39; = setmap (fn (d,i) = (d, i-l1)) d2  
  in    
      (Set.intersection (d1,d2&#39;), l1+l2)  
  end  
  
(* FYI: not part of exam *)  
fun find idx word =   
  case Table.find idx word =&gt;  
    NONE =&gt; (Set.empty(), 1)  
  | SOME d =&gt; (d, 1)  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{lstlisting}[numbers=none]
type docList = (docIdIntSet)*int

fun adj ((d1,l1), (d2,l2)) = 
  let 
      val d2' = setmap (fn (d,i) = (d, i-l1)) d2
  in  
      (Set.intersection (d1,d2'), l1+l2)
  end

(* FYI: not part of exam *)
fun find idx word = 
  case Table.find idx word =>
    NONE => (Set.empty(), 1)
  | SOME d => (d, 1)
\end{lstlisting}
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
(Shortest Paths) Dijkstra and A*
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
(Shortest Paths) Dijkstra and A*
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::shortest-paths-dijkstra-and-a
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::fall
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::fall
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Practice Exam II}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
6.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Consider the graph shown below, where the edge weights appear next to the edges and the heuristic distances to vertex <span class="math inline">\(G\)</span> are in parenthesis next to the vertices.</p>
<p><embed src="shortest-paths/graph.pdf" /></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Consider the graph shown below, where the edge weights appear next to
the edges and the heuristic distances to vertex $G$ are in parenthesis
next to the vertices.
\begin{center}
  \includegraphics[scale=.75]{shortest-paths/graph.pdf}
\end{center}
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::order
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Show the order in which vertices are visited by Dijkstra when the source vertex is <span class="math inline">\(A\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Show the order in which vertices are visited by Dijkstra when the source
vertex is $A$.
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::show
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>A C B E F D G</p>
<p>Show an order in which vertices are visited by <span class="math inline">\(A^*\)</span> when the source vertex is <span class="math inline">\(A\)</span> and the destination vertex is <span class="math inline">\(G\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A C B E F D G


\ask Show an order in which vertices are visited by $A^*$ when
the source vertex is $A$ and the destination vertex is $G$.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::_3_
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>A C F G</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A C F G
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::reason
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::reason
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
4.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::reason
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>What is the key reason you would choose to use <span class="math inline">\(A^*\)</span> instead of Dijkstra’s algorithm?</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
What is the key reason you would choose to use $A^*$ instead of
Dijkstra's algorithm?
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::want
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>You can use <span class="math inline">\(A^*\)</span> if you want the shortest path to only a single goal vertex, and not all shortest paths. <span class="math inline">\(A^*\)</span> can be much more efficient, as it tries to move toward the goal more directly, skipping many more vertices.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You can use $A^*$ if you want the shortest path to only a single goal vertex,
and not all shortest paths. $A^*$ can be much more efficient, as it tries to
move toward the goal more directly, skipping many more vertices.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::-vertex
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::-vertex
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
5.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::-vertex
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Show a <span class="math inline">\(3\)</span>-vertex example of a graph on which Dijkstra’s algorithm always fails. Please clearly identify which vertex is the source.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Show a $3$-vertex example of a graph on which Dijkstra's algorithm always
fails. Please clearly identify which vertex is the source.
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::guarantees
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<pre><code>         A   
        / \  
   x=4 /   \ y=-2   x+y &lt; z &lt; x guarantees failure  
      /     \       x+y &lt; z &lt;= x may fail depending on the input order  
    S ------- B  
        z=3  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{verbatim}
         A 
        / \
   x=4 /   \ y=-2   x+y < z < x guarantees failure
      /     \       x+y < z <= x may fail depending on the input order
    S ------- B
        z=3
\end{verbatim}
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
12.
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
(Shortest Paths) Wormholes
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
(Shortest Paths) Wormholes
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::shortest-paths-wormholes
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::untested
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::untested
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Untested, needs some work}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::secret
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::secret
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>In your new job for a secret Government agency you have been told about the existence of wormholes (also known as Einstein-Rosen bridges) that connect various locations in the country. You have been tasked with designing an algorithm for finding the shortest path using a combination of roads and wormholes between a pair of locations. Traveling through a wormhole is instantaneous, for all practical purposes, but it turns out that on a given trip someone can only go through two wormholes otherwise they risk rearrangement of their atomic structure.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
In your new job for a secret Government agency you have been told
about the existence of wormholes (also known as Einstein-Rosen
bridges) that connect various locations in the country.  You have been
tasked with designing an algorithm for finding the shortest path using
a combination of roads and wormholes between a pair of locations.
Traveling through a wormhole is instantaneous, for all practical
purposes, but it turns out that on a given trip someone can only go
through two wormholes otherwise they risk rearrangement of their
atomic structure.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::wormhole
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::wormhole
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The wormhole problem is therefore the weighted shortest path problem (assuming non-negative edge weights) with the additional constraint that (1) some edges are specially marked, and (2) a path can take at most two of those edges.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The wormhole problem is therefore the weighted shortest path problem
(assuming non-negative edge weights) with the additional constraint
that (1) some edges are specially marked, and (2) a path can take at
most two of those edges.
]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::dijkstra
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>You still have your Dijkstra code from 210. You don’t want to change your code—after all you forgot how ML works—so you just want to preprocess your graph so that a call to your code <code>SP</code><span class="math inline">\((s,t)\)</span> returns the correct solution to the wormhole problem. Explain how to do this. <strong>At most 5 sentences.</strong></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You still have your Dijkstra code from 210.  You don't want to change
your code---after all you forgot how ML works---so you just want to
preprocess your graph so that a call to your code \sml{SP}$(s,t)$
returns the correct solution to the wormhole problem.  Explain how to
do this. \textbf{At most 5 sentences.}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::create
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Create three copies of the graph without the wormhole edges: copy 0, copy 1, and copy 2. Connect copy 0 with copy 1 with the wormhole edges, with weight 0. Likewise connect copy 1 with copy 2 with wormhole edges with weight 0. Now find the shortest path from <code>SP</code><span class="math inline">\((s,d)\)</span> by starting at <span class="math inline">\(s\)</span> in copy 0 and finding the shortest path to <span class="math inline">\(d\)</span> in any of the three copies.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Create three copies of the graph without the wormhole edges: copy 0,
copy 1, and copy 2.  Connect copy 0 with copy 1 with the wormhole
edges, with weight 0.  Likewise connect copy 1 with copy 2 with
wormhole edges with weight 0.  Now find the shortest path from
\sml{SP}$(s,d)$ by starting at $s$ in copy 0 and finding the shortest
path to $d$ in any of the three copies.
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
(Graphs) Strongly Connected Components
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
(Graphs) Strongly Connected Components
]]>
</field> <!-- title_src -->
<field name='label'>
sec:examii-practice::graphs-strongly-connected-components
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::practice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::practice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\used{Fall 14, Practice Exam II}
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:grm:examii-practice::strongly
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:examii-practice::strongly
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>A <em>strongly connected component</em> of a directed graph <span class="math inline">\(G = (V,E)\)</span> is a subset <span class="math inline">\(S\)</span> of <span class="math inline">\(V\)</span> such that every vertex <span class="math inline">\(u \in S\)</span> can reach every other vertex <span class="math inline">\(v \in S\)</span> (i.e., there is a directed path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>), and such that no other vertex in <span class="math inline">\(V\)</span> can be added to <span class="math inline">\(S\)</span> without violating this condition. Every vertex belongs to exactly one strongly connected component in a graph.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
A \emph{strongly connected component} of a directed graph $G = (V,E)$ is a subset $S$ of $V$ such
that every vertex $u \in S$ can reach every other vertex $v \in S$ (i.e.,
there is a directed path from $u$ to $v$), and such that no other vertex in
$V$ can be added to $S$ without violating this condition. Every vertex
belongs to exactly one strongly connected component in a graph.
]]>
</field> <!-- body_src -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:prb:examii-practice::implement
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='problem'>
<field name='pl'>
...NOT.PROVIDED.PL...
</field> <!-- pl -->
<field name='pl_version'>
...NOT.PROVIDED.PL_VERSION...
</field> <!-- pl_version -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
prb:examii-practice::implement
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
10.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[

]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[

]]>
</field> <!-- body_src -->

<segment name='\ask'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
prt-ask:examii-practice::implement
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<p>Implement the function:</p>
<pre><code>val scc~:~graph * vertex -&gt; vertexSet  </code></pre>
<p>such that <code>scc(G,v)</code> returns the strongly connected component containing <span class="math inline">\(v\)</span>. You may assume the existence of a function:</p>
<pre><code>val reachable~:~graph * vertex -&gt; vertexSet  </code></pre>
<p>such that <code>reachable(G,v)</code> returns all the vertices reachable from <span class="math inline">\(v\)</span> in <span class="math inline">\(G\)</span>, and</p>
<pre><code>val transpose~:~graph -&gt; graph  </code></pre>
<p>That takes every edge in a directed graph and reverses its direction. You may assume the following representation of graphs:</p>
<pre><code>type graph = vertexSet vertexTable  </code></pre>
<p>with key comparisons taking <span class="math inline">\(O(1)\)</span> work.</p>
<p>Assuming that <code>reachable</code> and <code>transpose</code> use <span class="math inline">\(O(|E|\log|V|)\)</span> work and <span class="math inline">\(O(\log^2 |V|)\)</span> span, your algorithm must also have <span class="math inline">\(O(|E|\log|V|)\)</span> work and <span class="math inline">\(O(\log^2 |V|)\)</span> span.</p>
<pre data-numbers="none"><code>fun scc ($G$ : graph, v : vertex) : vertexSet = @\vspace{.2in}@  
      @\underline{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}@@\vspace{.2in}@  
      @\underline{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}@  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Implement the function:
\begin{lstlisting}
val scc~:~graph * vertex -> vertexSet
\end{lstlisting}
such that \sml{scc(G,v)} returns the strongly connected component containing $v$. You may assume
the existence of a function:
\begin{lstlisting}
val reachable~:~graph * vertex -> vertexSet
\end{lstlisting}
such that \sml{reachable(G,v)} returns all the vertices reachable from $v$
in $G$, and 
\begin{lstlisting}
val transpose~:~graph -> graph
\end{lstlisting}
That takes every edge in a directed graph and reverses its direction.
You may assume the following representation of graphs:
\begin{lstlisting}
type graph = vertexSet vertexTable
\end{lstlisting}
with key comparisons taking $O(1)$ work.

Assuming that \texttt{reachable} and \texttt{transpose} use
$O(|E|\log|V|)$ work and $O(\log^2 |V|)$ span, your algorithm
must also have $O(|E|\log|V|)$ work and $O(\log^2 |V|)$ span.

\begin{lstlisting}[numbers=none]
fun scc ($G$ : graph, v : vertex) : vertexSet = @\vspace{.2in}@
      @\underline{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}@@\vspace{.2in}@
      @\underline{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}@
\end{lstlisting}
]]>
</field> <!-- body_src -->

<segment name='\sol'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
cki-sol:examii-practice::graph
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='body'>
<![CDATA[
<pre data-numbers="none"><code>fun scc ($G$ : graph, v : vertex) : vertexSet = @\vspace{.2in}@  
    @\underline{vertexSet.intersection(reachable(G,v),~~~~~~~~~~~~~}@@\vspace{.2in}@  
    @\underline{~~~~~~~~~~~~~~~~~~~~~~~reachable(transpose(G,v)))}@  </code></pre>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{lstlisting}[numbers=none]
fun scc ($G$ : graph, v : vertex) : vertexSet = @\vspace{.2in}@
    @\underline{vertexSet.intersection(reachable(G,v),~~~~~~~~~~~~~}@@\vspace{.2in}@
    @\underline{~~~~~~~~~~~~~~~~~~~~~~~reachable(transpose(G,v)))}@
\end{lstlisting}
]]>
</field> <!-- body_src -->
</segment> <!-- \sol -->

</segment> <!-- \ask -->

<field name='caption'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption -->
<field name='caption_src'>
<![CDATA[
...NOT.PROVIDED.CAPTION...
]]>
</field> <!-- caption_src -->
</atom> <!-- problem -->

</segment> <!-- cluster -->


</segment> <!-- section -->

</segment> <!-- chapter -->
