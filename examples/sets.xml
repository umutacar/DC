<?xml version="1.0" encoding="UTF-8"?>
<segment name='chapter'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sets
]]>
</field> <!-- title_src -->
<field name='label'>
ch:sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::download
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::download
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Here is a download:</p>
<a href = '/Users/umut/Desktop/paper.xml' download = '/Users/umut/Desktop/paper.xml'> Download File </a>
<a href = '/Users/umut/Desktop/paper.xml'> Open File </a>
<p>And post downlead.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Here is a download: \begin{verbatim}
%%%% diderot_html
<a href = '/Users/umut/Desktop/paper.xml' download = '/Users/umut/Desktop/paper.xml'> Download File </a>\end{verbatim} \begin{verbatim}
%%%% diderot_html
<a href = '/Users/umut/Desktop/paper.xml'> Open File </a>\end{verbatim}
And post downlead.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='preamble'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
image
</field> <!-- cover -->
<field name='sound'>
sound.mpg
</field> <!-- sound -->
<field name='label'>
prmbl:sets::sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Sets are both a mathematical structure and an abstract datatype supported by many programming languages. This chapter presents an ADT for finite sets of elements taken from a fixed domain and several cost models, including one based on <a href="ch:bst::adt">balanced binary search trees</a>.</p>
<p>Here is a download: <code>%%%%diderot-html&lt;a href = #1 download = #1&gt; Download File &lt;/a&gt;</code> And post downlead.</p>
<ul>
<li><p><code>xyz</code></p></li>
<li><p><code>xyz</code></p></li>
<li><p><code>abc</code></p></li>
</ul>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Sets are both a mathematical structure and an abstract datatype
  supported by many programming languages.  This chapter presents an ADT for
  finite sets of elements taken from a fixed domain and several cost models, including one based on \href{ch:bst::adt}{balanced binary search trees}.

Here is a download: \download{paper.xml} \attach{diderot-attach.jpg}
And post downlead.
 
\begin{itemize}
\item
\lstinline'xyz'
\item
\lstinline`xyz`
\item
\lstinline!abc! 
\end{itemize}
]]>
</field> <!-- body_src -->

</atom> <!-- preamble -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::table-title
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='table'>
<field name='title'>
<![CDATA[
Table title
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Table title
]]>
</field> <!-- title_src -->
<field name='cover'>
coverimage.pdf
</field> <!-- cover -->
<field name='sound'>
playthis.mp3
</field> <!-- sound -->
<field name='label'>
tbl:sets::table-title
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Here</th>
<th style="text-align: left;">there</th>
<th style="text-align: left;">where?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">where</td>
<td style="text-align: left;">there</td>
<td style="text-align: left;">here?</td>
</tr>
</tbody>
</table>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{tabular}{lll}
Here & there & where? 
\\ \hline
where & there & here? 
\\ \hline
\end{tabular}
]]>
</field> <!-- body_src -->

</atom> <!-- table -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::lll
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='table'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tbl:sets::lll
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><span class="math display">\[\begin{array}{lll}  
\mbox{Here} &amp; \mbox{there} &amp; \mbox{where?}   
\\ \hline  
\mbox{where} &amp; \mbox{there} &amp; \mbox{here?}   
\\ \hline  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\[
\begin{array}{lll}
\mbox{Here} & \mbox{there} & \mbox{where?} 
\\ \hline
\mbox{where} & \mbox{there} & \mbox{here?} 
\\ \hline
\end{array}
\]
]]>
</field> <!-- body_src -->

</atom> <!-- table -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::something
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='figure'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
fig:sets::something
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><img src="Something" alt="image" />  <br />
<span>Some image above.</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\includegraphics{Something}
\caption{Some image above.}
]]>
</field> <!-- body_src -->

</atom> <!-- figure -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::image
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='table'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
tbl:sets::something
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p><img src="Something" alt="image" />  <br />
<span>Some image above.</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\includegraphics{Something}
\caption{Some image above.}
]]>
</field> <!-- body_src -->

</atom> <!-- table -->

</segment> <!-- cluster -->


<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Motivation
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Motivation
]]>
</field> <!-- title_src -->
<field name='label'>
sec:sets::math
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::gathering
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::gathering
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<blockquote>
<p>“A <em>set</em> is a gathering together into a whole of definite, distinct objects of our perception or of our thought—which are called <em>elements</em> of the set.”<br />
Georg Cantor, from “Contributions to the founding of the theory of transfinite numbers.”</p>
</blockquote>
<p>Set theory, founded by Georg Cantor in the second half of the nineteenth century, is one of the most important advances in mathematics. From it came the notions of countably vs. uncountably infinite sets, and ultimately the theory of computational undecidability, i.e. that computational mechanisms such as the <span class="math inline">\(\lambda\)</span>-calculus or Turing Machine cannot compute all functions. Set theory has also formed the foundations on which other branches of mathematics can be formalized. Early set theory, sometimes referred to as naı̈ve set theory, allowed anything to be in a set. This led to several paradoxes such Russell’s famous paradox: <span class="math display">\[\mbox{let } R = \left\{ x \;|\; x \not\in x \right\}, \mbox{ then } R \in R \iff R \not\in R  
\;.\]</span> Such paradoxes were resolved by the development of axiomatic set theory. Typically in such a theory, the universe of possible elements of a set needs to be built up from primitive notions, such as the integers or reals, by using various composition rules, such as Cartesian products.</p>
<p>x</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\begin{gram}
\begin{quote}
``A \emph{set} is a gathering together into a whole of definite, distinct
objects of our perception or of our thought---which are called \emph{elements}
of the set.''\\[.1in] Georg Cantor, from ``Contributions to the founding of the theory of transfinite numbers.''
\end{quote}

Set theory, founded by Georg Cantor in the second half of the
nineteenth century, is one of the most important advances in
mathematics.  From it came the notions of countably vs. uncountably
infinite sets, and ultimately the theory of computational
undecidability, i.e. that computational mechanisms such as the
$\lambda$-calculus or Turing Machine cannot compute all functions.
Set theory has also formed the foundations on which other branches of
mathematics can be formalized.  Early set theory, sometimes referred
to as na\"{\i}ve set theory, allowed anything to be in a set.  This
led to several paradoxes such Russell's famous paradox:
  \[\mbox{let } R = \csetf{x}{x \not\in x}, \mbox{ then } R \in R \iff R \not\in R
\;.\] Such paradoxes were resolved by the development of axiomatic set
theory.  Typically in such a theory, the universe of possible elements
of a set needs to be built up from primitive notions, such as the
integers or reals, by using various composition rules, such as
Cartesian products.
\end{gram}
\begin{gram}
x
\end{gram}
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::choices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Choices
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Choices
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::choices
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
10.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Select any one of the following.</p>
<p>a <span class="math inline">\(b = y^2\)</span> c d e</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Select any one of the following.
\begin{anychoice}
\choice a
\choice $b = y^2$
\choice* c
\choice* d
\choice e
\end{anychoice}
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::x
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
x
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
x
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xy
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
20.
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> Our goals in this book are much more modest than trying to understand set theory and its many interesting implications. Here we simply recognize that in algorithm design sets are a very useful data type in their own right, but also in building up more complicated data types, such as graphs. Furthermore particular classes of sets, such as mappings (or tables), are themselves very useful, and hence deserve their own interface. We discuss tables <a href="ch:tables">in the next chapter.</a></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{xy}
Our goals in this book are much more modest than trying to understand set theory and its many interesting implications.  Here we simply recognize that in algorithm design sets are a very useful data type in their own right, but also in building up more complicated data types, such as graphs.  Furthermore particular classes of sets, such as mappings (or tables), are themselves very useful, and hence deserve their own interface. 
We discuss tables \href{ch:tables}{in the next chapter.}
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::cover
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::cover
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Other chapters cover data structures on binary search trees (Chapter [<a href="#ch:bst::adt" data-reference-type="ref" data-reference="ch:bst::adt">[ch:bst::adt]</a>]) and hashing (Chapter [<a href="#ch:hash-tables" data-reference-type="ref" data-reference="ch:hash-tables">[ch:hash-tables]</a>]) that can be used for implementing the sets and tables interfaces. Applications of sets and tables include <a href="ch:graphs::graphs">graphs</a>. We note that <a href="ch:sequences::adt">sequences</a> are a particular type of table—one where the domain of the tables are the integers from <span class="math inline">\(0\)</span> to <span class="math inline">\(n-1\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Other chapters cover data structures on binary search trees
(\chref{bst::adt}) and hashing (\chref{hash-tables}) that can be used for
implementing the sets and tables interfaces. 
Applications of sets and tables include \href{ch:graphs::graphs}{graphs}.
We note that \href{ch:sequences::adt}{sequences} are a particular type of table---one where the domain of the tables are the integers from $0$ to $n-1$.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Sets ADT
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sets ADT
]]>
</field> <!-- title_src -->
<field name='label'>
sec:sets::sets-adt
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::universe
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='datatype'>
<field name='title'>
<![CDATA[
Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sets
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
adt:sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>For a universe of elements <span class="math inline">\({\mathbb{U}}\)</span> that support equality (e.g. the integers or strings), the <span><span class="sans-serif">SET</span></span> abstract data type is a type <span class="math inline">\({\mathbb{S}}\)</span> representing the power set of <span class="math inline">\({\mathbb{U}}\)</span> (i.e., all subsets of <span class="math inline">\({\mathbb{U}}\)</span>) limited to sets of finite size, along with the functions below.</p>
<p><span class="math display">\[\begin{array}{lll}
\mathit{size}
&amp; : &amp;{\mathbb{S}}\rightarrow\mathbb{N}
\\
\mathit{toSeq}~A
&amp; : &amp; u{\mathbb{S}}\rightarrow\mathit{Seq}
\\[2mm]
%
\mathit{empty}
&amp; : &amp; {\mathbb{S}}
\\
%
\mathit{singleton}
&amp; : &amp;{\mathbb{U}}\rightarrow{\mathbb{S}}
\\
\mathit{fromSeq}
&amp; : &amp; \mathit{Seq} \rightarrow{\mathbb{S}}
\\[2mm]
%
\mathit{filter}
&amp; : &amp; (({\mathbb{U}}\rightarrow{\mathbb{B}}) \rightarrow{\mathbb{S}}) \rightarrow{\mathbb{S}}
\\
%
\mathit{intersection}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{S}}\rightarrow{\mathbb{S}}
\\
%
\mathit{difference}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{S}}\rightarrow{\mathbb{S}}
\\
\mathit{union}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{S}}\rightarrow{\mathbb{S}}
\\[2mm]
%
\mathit{find}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{U}}\rightarrow{\mathbb{B}}
\\
\mathit{delete}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{U}}\rightarrow{\mathbb{S}}
\\
%
\mathit{insert}
&amp; : &amp; {\mathbb{S}}\rightarrow{\mathbb{U}}\rightarrow{\mathbb{S}}
\end{array}\]</span></p>
<p>Where <span class="math inline">\(\mathbb{N}\)</span> is the natural numbers (non-negative integers) and <span class="math inline">\({\mathbb{B}}= \{\texttt{true},  
\texttt{false}\}\)</span>.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{adt:sets} 

For a universe of elements $\uuu$ that support equality (e.g. the integers or strings), the 
\adt{SET} abstract data type is a type $\sss$ representing the power 
set of $\uuu$ (i.e., all subsets of $\uuu$) limited to sets of finite 
size, along with the functions below. 
{\normalsize
\input{./sets-and-tables/sig-sets}
}
Where $\tynat$ is 
the natural numbers (non-negative integers) and $\bbb = \{\texttt{true},
\texttt{false}\}$.
]]>
</field> <!-- body_src -->

</atom> <!-- datatype -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::standard
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='syntax'>
<field name='title'>
<![CDATA[
Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Sets
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
syn:sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> In SPARC we use the standard set notation <span class="math inline">\(\left\{ e_o,e_1,\cdots,e_n \right\}\)</span> to indicate a set. The notation <span class="math inline">\(\emptyset\)</span> or <span class="math inline">\(\left\{  \right\}\)</span> refers to an empty set. We also use the conventional mathematical syntax for set functions such as <span class="math inline">\(|S|\)</span> (size), <span class="math inline">\(\cup\)</span> (union), <span class="math inline">\(\cap\)</span> (intersection), and <span class="math inline">\(\setminus\)</span> (difference). In addition, we use set comprehensions for <span class="math inline">\(\mathit{filter}\)</span> and for constructing sets from other sets.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{syn:sets}
In \pml{}  we use the standard set notation $\cset{e_o,e_1,\cdots,e_n}$ to
  indicate a set.  The notation $\emptyset$ or $\cset{}$ refers to an
  empty set. We also use the conventional mathematical syntax for set
  functions such as $|S|$ (size), $\cup$ (union), $\cap$
  (intersection), and $\setminus$ (difference).  In addition, we use
  set comprehensions for $\cdvar{filter}$ and for constructing sets from
  other sets.
]]>
</field> <!-- body_src -->

</atom> <!-- syntax -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::objects
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::objects
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The objects that are contained in a set are called  <strong><em>members</em></strong>  or the  <strong><em>elements</em></strong>  of the set. Recall that a  <strong><em>set</em></strong>  is a collection of distinct objects. This requires that the universe <span class="math inline">\({\mathbb{U}}\)</span> they come from support equality. It might seem that all universes support equality, but consider functions. When are two functions equal? It is not even decidable whether two functions are equal. From a practical matter, there is no way to implement sets without an equality function over potential elements. In fact efficient implementations additionally require either a hash function over the elements of <span class="math inline">\({\mathbb{U}}\)</span> and/or a total ordering.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The objects that are contained in a set are called~\defn{members}~or the~\defn{elements}~of the set.  Recall that a~\defn{set}~is a collection of distinct objects.  This requires that
  the universe $\uuu$ they come from support equality.  It might seem that
  all universes support equality, but consider functions.  When are
  two functions equal?   It is not even decidable whether two
  functions are equal.   From a practical matter, there is no way to
  implement sets without an equality function over potential
  elements.   In fact efficient implementations additionally require
  either a hash function over the elements of $\uuu$ and/or a total ordering.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::consists
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::consists
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The Set ADT consists of basic functions on sets. The function <span class="math inline">\(\mathit{size}\)</span> takes a set and returns the number of elements in the set. The function <span class="math inline">\(\mathit{toSeq}\)</span> converts a set to a sequence by ordering the elements of the set in an unspecified way. Since elements of a set do not necessarily have a total ordering, the resulting order is arbitrary. This means that <span class="math inline">\(\mathit{toSeq}\)</span> is possibly non-deterministic—it could return different orderings in different implementations. We specify <span class="math inline">\(\mathit{toSeq}\)</span> as follows <span class="math display">\[\mathit{toSeq}~(\{x_0,x_1,\ldots,x_n\} : {\mathbb{S}}): seq = \left\langle\, x_0,x_1,\ldots,x_n \,\right\rangle\]</span> where the <span class="math inline">\(x_i\)</span> are an arbitrary ordering.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The Set ADT consists of basic functions on sets.  
The function $\cdvar{size}$ takes a set and returns the number of elements
in the set.
The function $\cdvar{toSeq}$ converts a set to a sequence by ordering the
elements of the set in an unspecified way. 
Since elements of a set do not necessarily have a total ordering, the
resulting order is arbitrary.
This means that $\cdvar{toSeq}$ is possibly non-deterministic---it could
return different orderings in different implementations.
We specify $\cdvar{toSeq}$ as follows
\[
\cdvar{toSeq}~(\{x_0,x_1,\ldots,x_n\} : \sss): seq = \cseq{x_0,x_1,\ldots,x_n}
\]
where the $x_i$ are an arbitrary ordering.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::functions
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::functions
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Several functions enable constructing sets. The function <span class="math inline">\(\mathit{empty}\)</span> returns an empty set: <span class="math display">\[\mathit{empty} : {\mathbb{S}}= \emptyset\]</span> The function <span class="math inline">\(\mathit{singleton}\)</span> constructs a singleton set from a given element. <span class="math display">\[\mathit{singleton} (x : {\mathbb{U}}) : {\mathbb{S}}= \{x \}\]</span> The function <span class="math inline">\(\mathit{fromSeq}\)</span> takes a sequence and returns a set consisting of the distinct elements of the sequence, eliminating duplicate elements. We can specify <span class="math inline">\(\mathit{fromSeq}\)</span> as returning the range of the sequence <span class="math inline">\(A\)</span> (recall that a sequence is a partial function mapping from natural numbers to elements of the sequence). <span class="math display">\[\mathit{fromSeq}~(a : seq) : {\mathbb{S}}= \mathit{range}~a\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Several functions enable constructing sets.
The function $\cdvar{empty}$ returns an empty set:
\[
\cdvar{empty} : \sss = \emptyset
\]
The function $\cdvar{singleton}$ constructs a singleton set from a given
element.
\[
\cdvar{singleton} (x : \uuu) : \sss = \{x \}
\]
The function $\cdvar{fromSeq}$ takes a sequence and returns a set consisting of the
distinct elements of the sequence, eliminating duplicate elements.
We can specify $\cdvar{fromSeq}$ as returning the range of the sequence
$A$ (recall that a sequence is a partial function mapping from natural numbers
to elements of the sequence).
\[
\cdvar{fromSeq}~(a : seq) : \sss = \cdvar{range}~a
\]
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::operate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::operate
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Several functions operate on sets to produce new sets. The function <span class="math inline">\(\mathit{filter}\)</span> selects the elements of a sequence that satisfy a given Boolean function, i.e., <span class="math display">\[\mathit{filter}~(f : {\mathbb{U}}\rightarrow\mathbb{B})~(a : {\mathbb{S}}) : {\mathbb{S}}= \{ x \in a ~\mid~f(x)\} .\]</span> The functions <span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{difference}\)</span>, and <span class="math inline">\(\mathit{union}\)</span> perform the corresponding set operation on their arguments: <span class="math display">\[\begin{array}{l}  
\mathit{intersection}~(a : {\mathbb{S}})~(b : {\mathbb{S}}) : {\mathbb{S}}= a \cap b\\  
\mathit{difference}~(a  : {\mathbb{S}})~(b : {\mathbb{S}}) : {\mathbb{S}}= a \setminus b\\  
\mathit{union}~(a : {\mathbb{S}})~(b : {\mathbb{S}}) : {\mathbb{S}}= a \cup b  
\end{array}\]</span> We refer to the functions <span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{difference}\)</span>, and <span class="math inline">\(\mathit{union}\)</span> as <strong><em>bulk updates</em></strong> , because they allow updating with a large set of elements “in bulk.”</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Several functions operate on sets to produce new sets.
The function $\cdvar{filter}$ selects the elements of a sequence that
satisfy a given Boolean function, i.e., 
\[
\cdvar{filter}~(f : \uuu \ra \tybool)~(a : \sss) : \sss = \{ x \in a \sucht f(x)\} .
\]
The functions $\cdvar{intersection}$, $\cdvar{difference}$, and $\cdvar{union}$
perform the corresponding set operation on their arguments:
\[
\begin{array}{l}
\cdvar{intersection}~(a : \sss)~(b : \sss) : \sss = a \cap b\\
\cdvar{difference}~(a  : \sss)~(b : \sss) : \sss = a \setminus b\\
\cdvar{union}~(a : \sss)~(b : \sss) : \sss = a \cup b
\end{array}
\]
We refer to the functions  $\cdvar{intersection}$, $\cdvar{difference}$, and $\cdvar{union}$
as \defn{bulk updates}, because they allow updating with a large set
of elements ``in bulk.''
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::find
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::find
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The functions <span class="math inline">\(\mathit{find}\)</span>, <span class="math inline">\(\mathit{insert}\)</span>, and <span class="math inline">\(\mathit{delete}\)</span> are singular versions of the bulk functions <span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{union}\)</span>, and <span class="math inline">\(\mathit{difference}\)</span> respectively. The <span class="math inline">\(\mathit{find}\)</span> function checks whether an element is in a set—it is the basic membership test for sets. <span class="math display">\[find~(a  : {\mathbb{S}})~(x : {\mathbb{U}}) : \mathbb{B}= \left\{  
                \begin{array}{ll}  
                \texttt{true} &amp; \texttt{if}~x \in A \\  
                \texttt{false} &amp; \texttt{otherwise}  
                \end{array} \right.\]</span> We can also specify the <span class="math inline">\(\mathit{find}\)</span> function is in terms of set intersection: <span class="math display">\[find~(a : {\mathbb{S}})~(x : {\mathbb{U}}) : \mathbb{B}= |{a \cap \left\{ x \right\}}| = 1.\]</span> The functions <span class="math inline">\(\mathit{delete}\)</span> and <span class="math inline">\(\mathit{insert}\)</span> delete an existing element from a set, and insert a new element into a set, respectively: <span class="math display">\[\begin{array}{l}  
\mathit{delete}~(a  : {\mathbb{S}})~(x  : {\mathbb{U}}) : {\mathbb{S}}= a \setminus \left\{ x \right\}.\\  
\mathit{insert}~(a : {\mathbb{S}})~(x : {\mathbb{U}}) : {\mathbb{S}}= a \cup \left\{ x \right\}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The functions $\cdvar{find}$, $\cdvar{insert}$, and $\cdvar{delete}$ are singular
versions of the bulk functions $\cdvar{intersection}$, $\cdvar{union}$, and
$\cdvar{difference}$ respectively.
The $\cdvar{find}$ function checks whether an element is in a set---it is
the basic membership test for sets.
\[
find~(a  : \sss)~(x : \uuu) : \tybool = \left\{
                \begin{array}{ll}
                \cd{true} & \cd{if}~x \in A \\
                \cd{false} & \cd{otherwise}
                \end{array} \right.
\]
We can also specify the $\cdvar{find}$ function is in terms of set
intersection:
\[
find~(a : \sss)~(x : \uuu) : \tybool = \csetsize{a \cap \cset{x}} = 1.
\]
The functions $\cdvar{delete}$ and $\cdvar{insert}$ 
delete an existing element from a set, and
insert a new element into a set,
respectively:
\[
\begin{array}{l}
\cdvar{delete}~(a  : \sss)~(x  : \uuu) : \sss = a \setminus \cset{x}.\\
\cdvar{insert}~(a : \sss)~(x : \uuu) : \sss = a \cup \cset{x}
\end{array}
\]
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::iteration
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::iteration
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Iteration and reduction over sets can be easily defined by converting them to sequences, as in</p>
<p><span class="math display">\[\begin{array}{l}  
\mathit{iterate}~f~x~a = \mathit{Sequence.iterate}~f~(\mathit{toSeq}~a)\\  
\mathit{reduce}~f~x~a = \mathit{Sequence.reduce}~f~(\mathit{toSeq}~a)  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Iteration and reduction over sets can be easily defined by converting
them to sequences, as in

\[
\begin{array}{l}
\cdvar{iterate}~f~x~a = \cdvar{Sequence.iterate}~f~(\cdvar{toSeq}~a)\\
\cdvar{reduce}~f~x~a = \cdvar{Sequence.reduce}~f~(\cdvar{toSeq}~a)
\end{array}
\]
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::notice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::notice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Notice that in the Set ADT although the universe <span class="math inline">\({\mathbb{U}}\)</span> is potentially infinite (e.g. the integers), <span class="math inline">\({\mathbb{S}}\)</span> only consists of finite sized subsets. Unfortunately this restriction means that the interface is not as powerful as general set theory, but it makes computation on sets feasible. A consequence of this requirement is that the interface does not include a function that takes the complement of a set—such a function would generate an infinite sized set from a finite sized set (assuming the size of <span class="math inline">\(U\)</span> is infinite).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Notice that in the Set ADT although the universe $\uuu$ is potentially
infinite (e.g. the integers), $\sss$ only consists of finite sized
subsets.
Unfortunately this restriction
means that the interface is not as powerful as general set theory, but
it makes computation on sets feasible.  A consequence of this
requirement is that the interface does not include a function that
takes the complement of a set---such a function would generate an
infinite sized set from a finite sized set (assuming the size of $U$
is infinite).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::convince
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='exercise'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xrcs:sets::convince
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Convince yourself that there is no way to create an infinite sized set using the interface and with finite work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Convince yourself that there is no way to create an infinite sized set
using the interface and with finite work.
]]>
</field> <!-- body_src -->

</atom> <!-- exercise -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::toseq
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:sets::functions
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Some functions on sets: <span class="math display">\[\begin{array}{lcl}  
|\left\{ a,b,c \right\}| &amp; = &amp; 3\\  
\left\{ x \in \left\{ 4,11,2,6 \right\} \;|\; x &lt; 7 \right\} &amp; = &amp;  
\left\{ 4,2,6 \right\}\\  
\mathit{find}~\left\{ 6,2,9,11,8 \right\} 4  &amp; = &amp; \texttt{false}\\  
\left\{ 2,7,8,11 \right\} \cup \left\{ 7,9,11,14,17 \right\} &amp; = &amp;  
\left\{ 2,7,8,9,11,14,17 \right\}\\  
\mathit{toSeq}~\left\{ 2,7,8,11 \right\} &amp; = &amp; \left\langle\, 8,11,2,7 \,\right\rangle\\  
\mathit{fromSeq}~\left\langle\, 2,7,2,8,11,2 \,\right\rangle &amp; = &amp; \left\{ 8,2,11,7 \right\}  
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Some functions on sets:
  \[
\begin{array}{lcl}
|\cset{a,b,c}| & = & 3\\
\csetf{x \in \cset{4,11,2,6}}{x < 7} & = &
\cset{4,2,6}\\
\cdvar{find}~\cset{6,2,9,11,8} 4  & = & \cfalse\\
\cset{2,7,8,11} \cup \cset{7,9,11,14,17} & = &
\cset{2,7,8,9,11,14,17}\\
\cdvar{toSeq}~\cset{2,7,8,11} & = & \cseq{8,11,2,7}\\
\cdvar{fromSeq}~\cseq{2,7,2,8,11,2} & = & \cset{8,2,11,7}
\end{array}
\]
]]>
</field> <!-- body_src -->

</atom> <!-- example -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::interface
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='remark'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
rmrk:sets::notice
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>You may notice that the interface does not contain a <span class="math inline">\(\mathit{map}\)</span> function. If we interpret <span class="math inline">\(\mathit{map}\)</span>, as in sequences, to take in a collection, apply some function to each element and return a collection of the same size, then it does not make sense for sets. Consider a function that always returns <span class="math inline">\(0\)</span>. Mapping this over a set would return all zeros, which would then be collapsed into a singleton set, containing exactly <span class="math inline">\(0\)</span>. Therefore, such a <span class="math inline">\(\mathit{map}\)</span> would allow reducing the set of arbitrary size to a singleton.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
You may notice that the interface does not
contain a $\cdvar{map}$ function.  If we interpret $\cdvar{map}$, as in sequences, to take in a collection, apply some
function to each element and return a collection of the same size,
then it does not make sense for sets.
Consider a function that always returns $0$.  Mapping this over a set would
return all zeros, which would then be collapsed into a singleton set, containing
exactly $0$.  Therefore, such a $\cdvar{map}$ would allow reducing the set of
arbitrary size to a singleton.
]]>
</field> <!-- body_src -->

</atom> <!-- remark -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::programming
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='remark'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
rmrk:sets::programming
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Most programming languages either support sets directly (e.g., Python and Ruby) or have libraries that support them (e.g., in the C++ STL library and Java collections framework). They sometimes have more than one implementation of sets. For example, Java has sets based on hash tables and balanced trees. Unsurprisingly, the set interface in different libraries and languages differ in subtle ways. So, when using one of these interfaces you should always read the documentation carefully.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Most programming languages either support sets directly (e.g., Python and Ruby)
or have libraries that support them (e.g., in the C++ STL library and Java
collections framework).  They sometimes have more than one implementation of
sets.  For example, Java has sets based on hash tables and balanced trees.
Unsurprisingly, the set interface in different libraries and languages differ in
subtle ways.  So, when using one of these interfaces you should always read the
documentation carefully.
]]>
</field> <!-- body_src -->

</atom> <!-- remark -->

</segment> <!-- cluster -->


</segment> <!-- section -->

<segment name='section'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
Cost of Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Cost of Sets
]]>
</field> <!-- title_src -->
<field name='label'>
sec:sets::cost-of-sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::implemented
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Sets can be implemented in several ways. If the elements of a set are drawn from natural numbers, it is sometimes possible and effective to represent the set as an array-based sequence. If the elements accept a hash function, then hash-tables can be used to store the elements in a sequence. This approach is commonly used in practice and is quite efficient in terms of work and space. Finally, if the elements don’t accept a hash function but accept a comparison operator that can totally order all elements, then sets can be represented by using binary search trees. All of these approaches assume an equality function on the elements (with natural numbers, the equality coincides with the equality on natural numbers).</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Sets can be implemented in several ways. 
If the elements of a set are drawn from natural numbers, it is sometimes possible and effective to represent the set as an array-based sequence.
If the elements accept a hash function, then hash-tables can be used to store the elements in a sequence.  This approach is commonly used in practice and is quite efficient in terms of work and space.
Finally, if the elements don't accept a hash function but accept a comparison operator that can totally order all elements, then sets can be represented by using binary search trees.
All of these approaches assume an equality function on the elements (with natural numbers, the equality coincides with the equality on natural numbers).
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='flex'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
sets:cluster:arraysets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='costspec'>
<field name='title'>
<![CDATA[
Array Sets for Enumerable Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Array Sets for Enumerable Sets
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
cost:sets::arrayseqs
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let the universe <span class="math inline">\(U\)</span> be defined as the set <span class="math inline">\(\{ 0, 1, \ldots, u-1 \}\)</span> for some <span class="math inline">\(u \in \mathbb{N}\)</span>. We can represent <strong><em>enumerable sets</em></strong> of the form <span class="math inline">\(S \subseteq U\)</span> by using a sequence that indicates for each <span class="math inline">\(i \in U\)</span> whether <span class="math inline">\(i \in S\)</span> or not. Using array sequences, operations on enumerable sets can be implemented according to the following cost specification.</p>
<p><span class="math display">\[\begin{array}{lcc}
  \mbox{Operation} &amp; \mbox{Work} &amp; \mbox{Span}
  \\
\mathit{size}~a
&amp; 1
&amp; 1
\\
\mathit{singleton}~x
&amp; 1
&amp; 1
\\
\mathit{toSeq}~a
&amp; 1
&amp; 1
\\
\mathit{filter}~f~a
&amp; u + \displaystyle\sum_{x \in a} W(f(x))
&amp; 1 + \displaystyle\max_{x \in a} S(f(x)) \\ 
\\
\mathit{intersection}~a_1~a_2
&amp; u
&amp; 1
\\
\mathit{union}~a_1~a_2
&amp; u
&amp; 1
\\
\mathit{difference}~a_1~a_2
&amp; u
&amp; 1
\\[.1in]
\mathit{find}~a~e
&amp; 1
&amp; 1
\\
\mathit{insert}~a~x
&amp; u
&amp; 1
\\
\mathit{delete}~a~x
&amp; u
&amp; 1
\end{array}\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{cost:sets::arrayseqs}

Let the universe $U$ be defined as the set 
$\{ 0, 1, \ldots, u-1 \}$
for some $u \in \nats$.
We can represent \defn{enumerable sets} of the form $S \subseteq U$ by using a sequence that indicates for each $i \in U$ whether $i \in S$ or not.
Using array sequences, operations on enumerable sets can be implemented according to the following cost specification.
 
\input{./sets-and-tables/cost-sets-arrayseqs}
]]>
</field> <!-- body_src -->

</atom> <!-- costspec -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
xmpl:sets::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Consider a graph whose vertices are labeled by natural numbers up to <span class="math inline">\(8\)</span>. We can a graph whose vertices are <span class="math inline">\(\{ 0, 2, 4, 6 \}\)</span> with the sequence: <span class="math inline">\(\left\langle\,  1, 0, 1, 0, 1, 0, 1, 0  \,\right\rangle.\)</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Consider a graph whose vertices are labeled by natural numbers up to $8$.  We can a graph whose vertices are
$\{ 0, 2, 4, 6 \}$ 
with the sequence:
$\cseq{ 1, 0, 1, 0, 1, 0, 1, 0 }.$
]]>
</field> <!-- body_src -->

</atom> <!-- example -->

</segment> <!-- flex -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::tree-representation-for-sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
Tree Representation for Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Tree Representation for Sets
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::tree-representation-for-sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>If the elements in the universe <span class="math inline">\({\mathbb{U}}\)</span> accept a comparison function that defines a total order over <span class="math inline">\({\mathbb{U}}\)</span>, then we can use a balanced binary search tree to represent sets. This representation allows us to implement the Sets ADT reasonably efficiently. For the specification <a href="cost:sets::trees">specified below</a>, we assume that the comparison function requires constant work and span.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
If the elements in the universe $\uuu$ accept a comparison function 
that defines a total order over $\uuu$, then we can use a balanced binary search tree to represent sets.
This representation allows us to implement the Sets ADT reasonably efficiently.
For the specification \href{cost:sets::trees}{specified below}, we assume that the comparison function requires constant work and span.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::tree-sets
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='costspec'>
<field name='title'>
<![CDATA[
Tree Sets
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
Tree Sets
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
cost:sets::trees
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> The cost specification for tree-based implementation of sets follow.</p>
<p><span class="math display">\[\begin{array}{lcc}
  \mbox{Operation} &amp; \mbox{Work} &amp; \mbox{Span}
  \\
\mathit{size}~a
&amp; 1
&amp; 1
\\
\mathit{singleton}~x
&amp; 1
&amp; 1
\\
\mathit{toSeq}~a
&amp; |{a}|
&amp; \lg{|a|}
\\
\mathit{filter}~f~a
&amp; \displaystyle\sum_{x \in a} W(f(x))
&amp; \lg |a| + \displaystyle\max_{x \in a} S(f(x)) \\ 
\\
\mathit{intersection}~a~b
&amp; m \cdot \lg (1 + \frac{n}{m})
&amp; \lg (n)
\\
\mathit{union}~a~b
&amp; &#39;&#39;
&amp; &#39;&#39;
\\
\mathit{difference}~a~b
&amp; &#39;&#39;
&amp; &#39;&#39;
\\[.1in]
\mathit{find}~a~e
&amp; \lg |a|
&amp; \lg |a|
\\
\mathit{insert}~a~x
&amp; &#39;&#39;
&amp; &#39;&#39;
\\
\mathit{delete}~a~x
&amp; &#39;&#39;
&amp; &#39;&#39;
\end{array}\]</span> where <span class="math inline">\(n = \max(|a|,|b|)\)</span> and <span class="math inline">\(m = \min(|a|,|b|)\)</span>, and assuming comparison of elements takes constant work.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{cost:sets::trees}
\input{./sets-and-tables/cost-sets-tree}
]]>
</field> <!-- body_src -->

</atom> <!-- costspec -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::consider
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>Let’s consider these cost specifications in some more detail. The cost for <span class="math inline">\(\mathit{filter}\)</span> is effectively the same as for sequences, and therefore should not be surprising. It assumes the function <span class="math inline">\(f\)</span> is applied to the elements of the set in parallel. The cost for the functions <span class="math inline">\(\mathit{find}\)</span>, <span class="math inline">\(\mathit{insert}\)</span>, and <span class="math inline">\(\mathit{delete}\)</span> are what one might expect from a balanced binary tree implementation. Basically the tree will have <span class="math inline">\(O(\lg n)\)</span> depth and each function will require searching the tree from the root to some node. We cover such an implementation in Chapter [<a href="#ch:bst::parametric" data-reference-type="ref" data-reference="ch:bst::parametric">[ch:bst::parametric]</a>].</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
Let's consider these cost specifications in some more detail.  The
cost for $\cdvar{filter}$ is effectively the same as for sequences, and
therefore should not be surprising.  It assumes the function $f$ is
applied to the elements of the set in parallel.  The cost for the
functions $\cdvar{find}$, $\cdvar{insert}$, and $\cdvar{delete}$ are
what one might expect from a balanced binary tree implementation.
Basically the tree will have $O(\lg n)$ depth and each function will
require searching the tree from the root to some node.  We cover
such an implementation in \chref{bst::parametric}.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::work
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::work
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>The work bounds for the bulk functions (<span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{difference}\)</span>, and <span class="math inline">\(\mathit{union}\)</span>) may seem confusing, especially because of the expression inside the logarithm. To shed some light on the cost, it is helpful to consider two cases, the first is when one of the sets is a single element and the other when both sets are equal length. In the first case the bulk functions are doing the same thing as the single element functions <span class="math inline">\(\mathit{find}\)</span>, <span class="math inline">\(\mathit{insert}\)</span>, and <span class="math inline">\(\mathit{delete}\)</span>. Indeed if we implement the single element functions on a set <span class="math inline">\(A\)</span> using the bulk ones, then we would like it to be the case that we get the same asymptotic performance. This is indeed the case since we have that <span class="math inline">\(m = 1\)</span> and <span class="math inline">\(n = |A|\)</span>, giving:</p>
<p><span class="math display">\[W(n) \in O\left(\lg \left(1 + \frac{n}{1}\right)\right)   
= O(\lg n)~.\]</span></p>
<p>Now let’s consider the second case when both sets have equal length, say <span class="math inline">\(n\)</span>. In this case we have <span class="math inline">\(m = n\)</span> giving <span class="math display">\[W(n) \in O\left(n \cdot \lg \left(1+\frac{n}{n}\right)\right) = O(n).\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
The work bounds for the bulk functions ($\cdvar{intersection}$,
  $\cdvar{difference}$, and $\cdvar{union}$) may seem confusing,
  especially because of the expression inside the logarithm.  To shed
  some light on the cost, it is helpful to consider two cases, the
  first is when one of the sets is a single element and the other when
  both sets are equal length.  In the first case the bulk functions
  are doing the same thing as the single element functions
  $\cdvar{find}$, $\cdvar{insert}$, and $\cdvar{delete}$.  Indeed if
  we implement the single element functions on a set $A$ using the
  bulk ones, then we would like it to be
  the case that we get the same asymptotic performance.  This is
  indeed the case since we have that $m = 1$ and $n = |A|$, giving:

\[W(n) \in O\left(\lg \left(1 + \frac{n}{1}\right)\right) 
= O(\lg n)~.\]

Now let's consider the second case when both sets have equal length,
say $n$.   In this case we have $m = n$ giving
\[
W(n) \in O\left(n \cdot \lg \left(1+\frac{n}{n}\right)\right) = O(n).
\]
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::implement
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='gram'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
grm:sets::implement
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p>We can implement <span class="math inline">\(\mathit{find}\)</span>, <span class="math inline">\(\mathit{delete}\)</span>, and <span class="math inline">\(\mathit{insert}\)</span> in terms of the functions <span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{difference}\)</span>, and <span class="math inline">\(\mathit{union}\)</span> (respectively) by making a singleton set out of the element that we are interested in. Such an implementation would be asymptotically efficient, giving us the work and span as the direct implementations.</p>
<p>Conversely, we can also implement the bulk functions in terms of the singleton ones by iteration. Because it uses iteration the resulting algorithms are sequential and also work inefficient. For example, if we implement <span class="math inline">\(\mathit{union}\)</span> by inserting <span class="math inline">\(n\)</span> elements into a second set of <span class="math inline">\(n\)</span> elements, the cost would be <span class="math inline">\(O(n  
\lg n)\)</span>. We would obtain a similar bound when implementing <span class="math inline">\(\mathit{difference}\)</span> with <span class="math inline">\(\mathit{delete}\)</span>, and <span class="math inline">\(\mathit{intersection}\)</span> with <span class="math inline">\(\mathit{find}\)</span> and <span class="math inline">\(\mathit{insert}\)</span>. For this reason, we prefer to use the bulk functions <span class="math inline">\(\mathit{intersection}\)</span>, <span class="math inline">\(\mathit{difference}\)</span>, and <span class="math inline">\(\mathit{union}\)</span> instead of <span class="math inline">\(\mathit{find}\)</span>, <span class="math inline">\(\mathit{delete}\)</span>, and <span class="math inline">\(\mathit{insert}\)</span> when possible.</p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
We can implement $\cdvar{find}$, $\cdvar{delete}$, and $\cdvar{insert}$ in terms of
the functions $\cdvar{intersection}$, $\cdvar{difference}$, and $\cdvar{union}$
(respectively) by making a singleton set out of the element that we
are interested in.
Such an implementation would be asymptotically efficient, giving us
the work and span as the direct implementations.

Conversely, we can also implement the bulk functions in terms of the
singleton ones by iteration.
Because it uses iteration the resulting algorithms are
sequential and also work inefficient.
For example, if we implement $\cdvar{union}$ by inserting
$n$ elements into a second set of $n$ elements, the cost would be $O(n
\lg n)$.  
We would obtain a similar bound when implementing
$\cdvar{difference}$ with $\cdvar{delete}$, and $\cdvar{intersection}$ with
$\cdvar{find}$ and $\cdvar{insert}$.
For this reason, we prefer to use the bulk functions $\cdvar{intersection}$, $\cdvar{difference}$, and $\cdvar{union}$ instead
of $\cdvar{find}$, $\cdvar{delete}$, and $\cdvar{insert}$ when possible.
]]>
</field> <!-- body_src -->

</atom> <!-- gram -->

</segment> <!-- cluster -->

<segment name='cluster'>
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='label'>
grp:sets::convert
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->

<atom name='example'>
<field name='title'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title -->
<field name='title_src'>
<![CDATA[
...NOT.PROVIDED.TITLE...
]]>
</field> <!-- title_src -->
<field name='cover'>
...NOT.PROVIDED.COVER...
</field> <!-- cover -->
<field name='sound'>
...NOT.PROVIDED.SOUND...
</field> <!-- sound -->
<field name='label'>
ex:st::fromseq-imp
</field> <!-- label -->
<field name='depend'>
...NOT.PROVIDED.DEPEND...
</field> <!-- depend -->
<field name='point_value'>
0.0
</field> <!-- point_value -->
<field name='body'>
<![CDATA[
<p> We can convert a sequence to a set by inserting the elements one by one as follows <span class="math display">\[\mathit{fromseq}~a = \mathit{Seq.iterate}~\mathit{Set.insert}~~\emptyset~a.\]</span></p>
<p>This implementation is sequential and work inefficient. We can write a parallel and work-efficient function as follows <span class="math display">\[\mathit{fromSeq}~a = \mathit{Seq.reduce}~\mathit{Set.union}~~\emptyset~~\left\langle\, \left\{ x \right\} : x \in a \,\right\rangle.\]</span></p>
]]>
</field> <!-- body -->
<field name='body_src'>
<![CDATA[
\label{ex:st::fromseq-imp}
We can  convert a sequence to a set by inserting the elements
one by one as follows
\[
\cdvar{fromseq}~a = \cdvar{Seq.iterate}~\cdvar{Set.insert}~~\emptyset~a.
\]

This implementation is sequential and work inefficient. 
We can write a parallel and work-efficient function as follows
\[
\cdvar{fromSeq}~a = \cdvar{Seq.reduce}~\cdvar{Set.union}~~\emptyset~~\cseq{\cset{x} : x \in a}.
\]
]]>
</field> <!-- body_src -->

</atom> <!-- example -->

</segment> <!-- cluster -->


</segment> <!-- section -->

</segment> <!-- chapter -->
