%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilCourse}
\begin{dilFieldTitle}
Parallel and Sequential Algorithms
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parallel and Sequential Algorithms
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210
\end{dilFieldUnique}
\begin{dilLabel}
15210
\end{dilLabel}
\begin{dilNo}
15210
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldCourseNumber}
15210
\end{dilFieldCourseNumber}
\begin{dilFieldPicture}
/210/course/air-pavilion.jpg
\end{dilFieldPicture}
\begin{dilFieldSemester}
Spring 2018
\end{dilFieldSemester}
\begin{dilFieldWebsite}
http://www.cs.cmu.edu/~15210
\end{dilFieldWebsite}
\begin{dilFieldProvidesBook}
S18
\end{dilFieldProvidesBook}
\begin{dilFieldProvidesChapter}
8
\end{dilFieldProvidesChapter}
\begin{dilFieldProvidesSection}
1
\end{dilFieldProvidesSection}
\begin{dilFieldProvidesUnit}
1
\end{dilFieldProvidesUnit}
\begin{dilFieldProvidesAssignment}
1
\end{dilFieldProvidesAssignment}
\begin{dilIntro}
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues. Concepts covered in this class include:</p>

\end{dilIntro}
\begin{dilIntroDex}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues. Concepts
covered in this class include:
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilBook}
\begin{dilFieldTitle}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18
\end{dilFieldUnique}
\begin{dilLabel}
book:15210:S18
\end{dilLabel}
\begin{dilNo}
0
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldAuthors}
Umut A. Acar and Guy Blelloch
\end{dilFieldAuthors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilChapter}
\begin{dilFieldTitle}
Sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8
\end{dilFieldUnique}
\begin{dilLabel}
chapter:15210:S18:CH8:ch:sequences
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldPicture}
/210/sequences/water-town-suzhou-embroidery.jpg
\end{dilFieldPicture}
\begin{dilIntro}
<p>A sequence is an ordered set, i.e., is a collection of elements that are totally ordered. Computer scientists use sequence data grams such as arrays and lists to represent many different sorts of data.</p>
<p>This chapter defines the syntax and the semantics of sequences and presents cost specifications and implementation strategies for matching them.</p>

\end{dilIntro}
\begin{dilIntroDex}




A sequence is an ordered set, i.e., is a collection of elements that
are totally ordered. 
%
Computer scientists use sequence data grams such as arrays and
lists to represent many different sorts of data.
%


This chapter defines the syntax and the semantics of sequences and
presents cost specifications and implementation strategies for
matching them.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Semantics
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Semantics
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH8:SEC1:sec:sequences
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>Thi section specifies the syntax and the semantics for a sequence abstract data type.</p>

\end{dilIntro}
\begin{dilIntroDex}


Thi section specifies the syntax and the semantics for a
sequence abstract data type.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Defining Sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Defining Sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH8:SEC1:UN1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN1:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Mathematically, a sequence is an enumerated collection. As with a set, a sequence has  <span style="color: black"><span><strong><em>elements</em></strong></span></span>. The  <span style="color: black"><span><strong><em>length</em></strong></span></span> of the sequence is the number of elements in the sequence. A sequence can be finite or infinite; we only consider finite ones.</p>
<p>Sequences allow for repetition: an element can appear at multiple positions. The position of an element is called its  <span style="color: black"><span><strong><em>rank</em></strong></span></span> or its  <span style="color: black"><span><strong><em>index</em></strong></span></span>. Traditionally, the first element of the sequence is given rank <span class="math inline">\(1\)</span>, but, being computer scientists, we start at <span class="math inline">\(0\)</span>. Mathematically, we can define a sequence as a function whose domain is a contiguous set of natural numbers starting at zero.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Mathematically, a sequence is an enumerated collection.  As with a
set, a sequence has~\defn{elements}.  The~\defn{length} of the
sequence is the number of elements in the sequence.  A sequence can be
finite or infinite; we only consider finite ones.
%

Sequences allow for repetition: an element can appear at multiple
positions.
%
The position of an element is called its~\defn{rank} or its~\defn{index}.
%
Traditionally, the first element of the sequence is given rank $1$,
but, being computer scientists, we start at $0$.
% 
Mathematically, we can define a sequence as a function whose domain is
a contiguous set of natural numbers starting at zero.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN1:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR2:AT1:def:seq::sequences
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An  <span style="color: black"><span><strong><em><span class="math inline">\(\alpha\)</span> sequence</em></strong></span></span> is a mapping (function) from <span class="math inline">\(\mathbb{N}\)</span> to <span class="math inline">\(\alpha\)</span> with domain <span class="math inline">\(\left\{ 0, \ldots, n-1 \right\}\)</span> for some <span class="math inline">\(n \in \mathbb{N}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An~\defn{$\alpha$ sequence} is a mapping (function) from $\nats$ to
$\alpha$ with domain $\cset{0, \ldots, n-1}$ for some $n \in \nats$.
%

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR2:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR2:AT2:ex:seq::sequencesdef
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
def:seq::bayesian-inference
\end{dilParents}
\begin{dilFieldBody}
<p>Let <span class="math inline">\(A = \left\{ 0,1,2,3 \right\}\)</span> and <span class="math inline">\(B = \left\{ \text{&#39;}\,{\texttt{a}}\,\text{&#39;},\text{&#39;}\,{\texttt{b}}\,\text{&#39;},\text{&#39;}\,{\texttt{c}}\,\text{&#39;} \right\}\)</span>. The relation <span class="math display">\[R = \left\{ (0,\text{&#39;}\,{\texttt{a}}\,\text{&#39;}),(1,\text{&#39;}\,{\texttt{b}}\,\text{&#39;}),(3,\text{&#39;}\,{\texttt{a}}\,\text{&#39;}) \right\}\]</span> is a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> with domain <span class="math inline">\(\{0,1,3\}\)</span> since each element only appears once on the left. It is, however, not a sequence since there is a gap in the domain.</p>
<p>The relation <span class="math display">\[Z = \{(1,\text{&#39;}\,{\texttt{b}}\,\text{&#39;}), (3,\text{&#39;}\,{\texttt{a}}\,\text{&#39;}), (2,\text{&#39;}\,{\texttt{a}}\,\text{&#39;}), (0,\text{&#39;}\,{\texttt{a}}\,\text{&#39;})\}\]</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span> is a sequence. The first element of the sequence is <span class="math inline">\(\text{&#39;}\,{\texttt{a}}\,\text{&#39;}\)</span> and thus has rank <span class="math inline">\(0\)</span>. The second element is <span class="math inline">\(\text{&#39;}\,{\texttt{b}}\,\text{&#39;}\)</span> and has rank <span class="math inline">\(1\)</span>. The length of the sequence is <span class="math inline">\(4\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Let $A = \cset{0,1,2,3}$ and $B = \cset{\cstr{a},\cstr{b},\cstr{c}}$.
The relation
\[R = \cset{(0,\cstr{a}),(1,\cstr{b}),(3,\cstr{a})}\]
is a function from $A$ to $B$ with domain $\{0,1,3\}$ since each
element only appears once on the left. It is, however, not a sequence
since there is a gap in the domain.

The relation
\[Z = \{(1,\cstr{b}), (3,\cstr{a}), (2,\cstr{a}), (0,\cstr{a})\}\]
from~$A$ to $B$ is a sequence.
%
The first element of the sequence is $\cstr{a}$ and thus has rank $0$.
The second element is $\cstr{b}$ and has rank $1$.  
%
The length of the sequence is $4$.
%

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN1:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>This mathematical definition might seem pedantic but it is useful for at least a couple reasons: it allows for a concise but yet precise definition of the semantics of the functions on sequences, and we will see, relating sequences to mappings creates a symmetry with the abstract data types such as tables or dictionaries for representing mappings. An important point to notice in the definition is that sequences are parametrized by the type (i.e., set of possible values) of their elements.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
This mathematical definition might seem pedantic but it is useful for
at least a couple reasons: it allows for a concise but yet precise
definition of the semantics of the functions on sequences, and we will
see, relating sequences to mappings creates a symmetry with the
abstract data types such as tables or dictionaries for representing
mappings.
%
An important point to notice in the definition is that sequences are
parametrized by the type (i.e., set of possible values) of their
elements.

\end{dilFieldBodyDex}
\end{dilAtomNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN1:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSyntax}
\begin{dilFieldTitle}
Sequences and Indexing
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Sequences and Indexing
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As in mathematics, we use a special notation for writing sequences. The notation <span class="math inline">\(\left\langle\, a_0,a_1,\ldots,a_{n-1} \,\right\rangle\)</span> is shorthand for the sequence <span class="math inline">\(\left\{ (0,a_0),(1,a_1),\ldots,((n-1),a_{n-1}) \right\}\)</span>.</p>
<p>For a sequence <span class="math inline">\(a\)</span></p>
<ul>
<li><p><span class="math inline">\(a[i]\)</span> refers to the element of <span class="math inline">\(a\)</span> at position <span class="math inline">\(i\)</span>,</p></li>
<li><p><span class="math inline">\(a[l \cdots h]\)</span> refers to the subsequence of <span class="math inline">\(a\)</span> restricted to the position between <span class="math inline">\(l\)</span> and <span class="math inline">\(h\)</span>.</p></li>
</ul>
<p>Since they occur frequently, we use special notation and terminology for sequences with two elements and sequences of characters.</p>
<ul>
<li><p>An  <span style="color: black"><span><strong><em>ordered pair <span class="math inline">\((x,y)\)</span></em></strong></span></span> is a pair of elements in which the element on the left, <span class="math inline">\(x\)</span>, is identified as the  <span style="color: black"><span><strong><em>first</em></strong></span></span> entry, and the one on the right, <span class="math inline">\(y\)</span>, as the  <span style="color: black"><span><strong><em>second</em></strong></span></span> entry.</p></li>
<li><p>We refer to a sequence of characters as a  <span style="color: black"><span><strong><em>string</em></strong></span></span>, and use the standard syntax for them, e.g., <span class="math inline">\(\text{&#39;}\,{{c_0c_1c_2 \ldots c_{n-1}}}\,\text{&#39;}\)</span> is a string consisting of the <span class="math inline">\(n\)</span> characters <span class="math inline">\(c_0, \ldots, c_{n-1}\)</span>.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As in mathematics, we use a special notation for writing sequences.
%
The notation
%
$\cseq{a_0,a_1,\ldots,a_{n-1}}$
%
is shorthand for the sequence
$\cset{(0,a_0),(1,a_1),\ldots,((n-1),a_{n-1})}$.
%

For a sequence $a$
\begin{itemize}
\item  $a[i]$ refers to the element of $a$ at
position $i$,

\item $a\cirange{l}{h}$ refers to the subsequence of $a$ restricted to
  the position between $l$ and $h$.
\end{itemize}

Since they occur frequently, we use special notation and terminology
for sequences with two elements and sequences of characters.
%
\begin{itemize}
\item
An~\defn{ordered pair $(x,y)$} is a pair of elements in which the
element on the left, $x$, is identified as the~\defn{first} entry, and
the one on the right, $y$, as the~\defn{second} entry.
\item
We refer to a sequence of characters as a~\defn{string}, and use the
standard syntax for them, e.g., $\mstr{c_0c_1c_2 \ldots c_{n-1}}$ is a
string consisting of the $n$ characters $c_0, \ldots, c_{n-1}$.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomSyntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Example sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Example sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN1:GR4:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN1:GR4:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Some example sequences follow.</p>
<ul>
<li><p>For the sequence <span class="math inline">\(a =  \left\langle\, 2,3,5,7,11,13,17,19,23,29 \,\right\rangle\)</span>, we have</p>
<ul>
<li><p><span class="math inline">\(a[0] = 2\)</span>,</p></li>
<li><p><span class="math inline">\(a[2] = 5\)</span>, and</p></li>
<li><p><span class="math inline">\(a[1 \cdots 4] = \left\langle\, 3,5,7,11 \,\right\rangle\)</span>.</p></li>
</ul></li>
<li><p>A character sequence, or a string: <span class="math inline">\(\left\langle\, \text{&#39;}\,{s}\,\text{&#39;},\text{&#39;}\,{e}\,\text{&#39;},\text{&#39;}\,{q}\,\text{&#39;} \,\right\rangle \equiv \text{&#39;}\,{seq}\,\text{&#39;}~.\)</span></p></li>
<li><p>An integer-and-string sequence: <span class="math inline">\(\left\langle\, (10,\text{&#39;}\,{ten}\,\text{&#39;}),(1,\text{&#39;}\,{one}\,\text{&#39;}),(2,\text{&#39;}\,{two}\,\text{&#39;}) \,\right\rangle.\)</span></p></li>
<li><p>A string-and-string-sequence sequence: <span class="math inline">\(\left\langle\, \left\langle\, \text{&#39;}\,{a}\,\text{&#39;} \,\right\rangle,\left\langle\, \text{&#39;}\,{nested}\,\text{&#39;}, \text{&#39;}\,{sequence}\,\text{&#39;} \,\right\rangle \,\right\rangle.\)</span></p></li>
<li><p>A <span class="math inline">\(\mathbb{Z}\rightarrow \mathbb{Z}\)</span> function sequence: <span class="math display">\[\begin{array}{ll} 
\left\langle\right.&amp; \texttt{lambda}~{x}\,.\,x^2, 
\\ 
&amp; \texttt{lambda}~{y}\,.\,y+2, 
\\ 
&amp; \texttt{lambda}~{x}\,.\,x-4 
\\ 
\left.\right\rangle. 
\end{array}\]</span></p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Some example sequences follow.


\begin{itemize}
\item For the sequence $a =  \cseq{2,3,5,7,11,13,17,19,23,29}$, we have


\begin{itemize}

\item $a[0] = 2$, 
\item $a[2] = 5$, and 
\item
$a\cirange{1}{4} = \cseq{3,5,7,11}$.
\end{itemize}
%
\item 
A character sequence, or a string:
$\cseq{\chr{s},\chr{e},\chr{q}} \equiv \str{seq}~.$
%
\item

An integer-and-string sequence:
$\cseq{(10,\str{ten}),(1,\str{one}),(2,\str{two})}.$
%
\item 
A string-and-string-sequence sequence: $\cseq{\cseq{\str{a}},\cseq{\str{nested}, \str{sequence}}}.$
%
\item
A $\tyint \rightarrow \tyint$ function sequence:
\[
\begin{array}{ll}
\cseqb & \cfn{x}{x^2},
\\
& \cfn{y}{y+2},
\\
& \cfn{x}{x-4}
\\
\cseqe.
\end{array}
\]
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
The Sequence Abstract Data Type
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The Sequence Abstract Data Type
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH8:SEC1:UN2:sec:seq::adt
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Sequences are one of the most prevalent ADT’s used in this book, and more generally in computing. In this section, we present the interface of an abstract data type for sequences, describe the semantics of the operations in the interface, and define a notation for sequences, called  <span style="color: black"><span><strong><em>sequence comprehensions</em></strong></span></span>. Throughout, we use <span class="math inline">\(e\)</span> and its variants to for SPARC expression. When specifying the semantics of operation, we rely on the mathematical definition of a sequence as a partial function whose domain is natural numbers.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Sequences are one of the most prevalent ADT's used in this book, and
more generally in computing.  
%
In this section, we present the interface of an abstract data type for
sequences, describe the semantics of the operations in the interface,
and define a notation for sequences, called~\defn{sequence
  comprehensions}.
%
Throughout, we use $e$ and its variants to for \PML expression.
%
When specifying the semantics of operation, we rely on the
mathematical definition of a sequence as a partial function whose
domain is natural numbers.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The sequence ADT, shown below, can be broadly divided into several categories.</p>
<ul>
<li><p>Operations such as <span class="math inline">\(\texttt{nth}\)</span> and <span class="math inline">\(\texttt{length}\)</span> that return an element of the sequence or a particular property of it.</p></li>
<li><p>Constructors such as <span class="math inline">\(\texttt{empty}\)</span>, <span class="math inline">\(\texttt{singleton}\)</span>, and <span class="math inline">\(\texttt{tabulate}\)</span> that create sequences.</p></li>
<li><p>Operations such as <span class="math inline">\(\texttt{map}\)</span>, <span class="math inline">\(\texttt{filter}\)</span> that operate on each element of a sequence independently in parallel.</p></li>
<li><p>Operations such as <span class="math inline">\(\texttt{append}\)</span> and <span class="math inline">\(\texttt{flatten}\)</span> that operate on sequences as a whole.</p></li>
<li><p>Operations such as <span class="math inline">\(\texttt{update}\)</span> and <span class="math inline">\(\texttt{inject}\)</span> that updates the elements of a sequence.</p></li>
<li><p>Operations such as <span class="math inline">\(\texttt{iterate}\)</span>, <span class="math inline">\(\texttt{reduce}\)</span>, and <span class="math inline">\(\texttt{scan}\)</span> that  <span style="color: black"><span><strong><em>aggregate</em></strong></span></span> information over the elements of the sequence.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The sequence ADT, shown below, can be broadly divided into several
categories.
\begin{itemize}
\item 
Operations such as  $\cd{nth}$ and  $\cd{length}$  that return an
element of the sequence or a particular property of it.
%
\item Constructors such as $\cd{empty}$, $\cd{singleton}$, and $\cd{tabulate}$ that create
sequences.
%
\item 
Operations such as $\cd{map}$, $\cd{filter}$ that operate on each
element of a sequence independently in parallel.
%
\item 
Operations such as $\cd{append}$ and $\cd{flatten}$ that operate on
sequences as a whole.
%
\item 
Operations such as $\cd{update}$ and $\cd{inject}$ that updates the
elements of a sequence.
%
\item 
Operations such as $\cd{iterate}$, $\cd{reduce}$, and $\cd{scan}$ that~\defn{aggregate} information over the elements of the sequence.
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDatatype}
\begin{dilFieldTitle}
Sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR3:AT1:adt:seq::sequences
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>For a value type <span class="math inline">\(\alpha\)</span>, the  <span style="color: black"><span><strong><em>sequence data type</em></strong></span></span> is the type <span class="math inline">\(\mathbb{S}_{\alpha}\)</span> consisting of the set of all <span class="math inline">\(\alpha\)</span> sequences, and the following values and functions on <span class="math inline">\(\mathbb{S}_{\alpha}\)</span>. In the specifiction, we define booleans as <span class="math inline">\(\mathbb{B}= \{\texttt{true}{}, 
\texttt{false}{}\}\)</span> and orders as <span class="math inline">\(\mathcal{O} = \{\texttt{less}, \texttt{greater}, 
\texttt{equal}\}\)</span>. <span class="math display">\[\begin{array}{lcl} 
\texttt{length} 
&amp; : &amp; 
\mathbb{S}_{\alpha} \rightarrow \mathbb{N}
\\ 
\texttt{nth} 
&amp; : &amp;  
\mathbb{S}_{\alpha} \rightarrow \mathbb{N}\rightarrow \alpha  
\\ 
\texttt{empty} 
&amp; : &amp;  
\mathbb{S}_{\alpha}  
\\ 
\texttt{singleton} 
&amp; : &amp;  
\alpha \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{tabulate} 
&amp; : &amp; (\mathbb{N}\rightarrow \alpha) \rightarrow \mathbb{N}\rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{map} 
&amp; : &amp; (\alpha \rightarrow \beta) \rightarrow \mathbb{S}_{\alpha} \rightarrow \mathbb{S}_{\beta} 
\\ 
\texttt{subseq} 
&amp; : &amp;  
\mathbb{S}_{\alpha} \rightarrow \mathbb{N}\rightarrow \mathbb{N}\rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{append} 
&amp; : &amp;  
\mathbb{S}_{\alpha} \rightarrow \mathbb{S}_{\alpha} \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{filter} 
&amp; : &amp; (\alpha \rightarrow \mathbb{B}) \rightarrow \mathbb{S}_{\alpha} \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{flatten} 
&amp; : &amp; \mathbb{S}_{\mathbb{S}_{\alpha}} \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{update} 
&amp; : &amp;  \mathbb{S}_{\alpha} \rightarrow (\mathbb{N}\times \alpha) \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{inject} 
&amp; : &amp;  \mathbb{S}_{\alpha} \rightarrow \mathbb{S}_{\mathbb{N}\times \alpha} \rightarrow \mathbb{S}_{\alpha} 
\\ 
\texttt{isEmpty} 
&amp; : &amp; \mathbb{S}_{\alpha} \rightarrow \mathbb{B}
\\ 
\texttt{isSingleton} 
&amp; : &amp; \mathbb{S}_{\alpha} \rightarrow \mathbb{B}
\\ 
\texttt{iterate} 
&amp; : &amp;   
(\alpha \times \beta \rightarrow \alpha) 
\rightarrow 
\alpha 
\rightarrow 
\mathbb{S}_{\beta} 
\rightarrow 
\alpha 
\\ 
\texttt{reduce} 
&amp; : &amp;   
(\alpha \times \alpha \rightarrow \alpha) 
\rightarrow 
\alpha 
\rightarrow 
\mathbb{S}_{\alpha} 
\rightarrow 
\alpha 
\\ 
\texttt{scan} 
&amp; : &amp;   
(\alpha \times \alpha \rightarrow \alpha) 
\rightarrow 
\alpha 
\rightarrow 
\mathbb{S}_{\alpha} 
\rightarrow 
(\mathbb{S}_{\alpha} \times \alpha) 
\\ 
\texttt{collect} 
&amp; : &amp;   
(\alpha \times \alpha \rightarrow \mathcal{O}) 
\rightarrow 
\mathbb{S}_{\alpha \times \beta} 
\rightarrow 
\mathbb{S}_{\alpha \times \mathbb{S}_{\beta}} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
For a value type $\alpha$, the~\defn{sequence data type} is the type
$\sseq{\alpha}$ consisting of the set of all $\alpha$ sequences, and
the following values and functions on $\sseq{\alpha}$.
%
In the specifiction, we define booleans as $\tybool = \{\ctrue{},
\cfalse{}\}$ and orders as $\mathcal{O} = \{\cd{less}, \cd{greater},
\cd{equal}\}$.
%
\[
\begin{array}{lcl}
\cd{length}
& : &
\sseq{\alpha} \rightarrow \tynat
\\
\cd{nth}
& : & 
\sseq{\alpha} \rightarrow \tynat \rightarrow \alpha 
\\
\cd{empty}
& : & 
\sseq{\alpha} 
\\
\cd{singleton}
& : & 
\alpha \rightarrow \sseq{\alpha}
\\
\cd{tabulate}
& : & (\tynat \rightarrow \alpha) \rightarrow \tynat \rightarrow \sseq{\alpha}
\\
\cd{map}
& : & (\alpha \rightarrow \beta) \rightarrow \sseq{\alpha} \rightarrow \sseq{\beta}
\\
\cd{subseq}
& : & 
\sseq{\alpha} \rightarrow \tynat \rightarrow \tynat \rightarrow \sseq{\alpha}
\\
\cd{append}
& : & 
\sseq{\alpha} \rightarrow \sseq{\alpha} \rightarrow \sseq{\alpha}
\\
\cd{filter}
& : & (\alpha \rightarrow \tybool) \rightarrow \sseq{\alpha} \rightarrow \sseq{\alpha}
\\
\cd{flatten}
& : & \sseq{\sseq{\alpha}} \rightarrow \sseq{\alpha}
\\
\cd{update}
& : &  \sseq{\alpha} \rightarrow (\tynat \times \alpha) \rightarrow \sseq{\alpha}
\\
\cd{inject}
& : &  \sseq{\alpha} \rightarrow \sseq{\tynat \times \alpha} \rightarrow \sseq{\alpha}
\\
\cd{isEmpty}
& : & \sseq{\alpha} \rightarrow \tybool
\\
\cd{isSingleton}
& : & \sseq{\alpha} \rightarrow \tybool
\\
\cd{iterate}
& : &  
(\alpha \times \beta \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\beta}
\rightarrow
\alpha
\\
\cd{reduce}
& : &  
(\alpha \times \alpha \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\alpha}
\rightarrow
\alpha
\\
\cd{scan}
& : &  
(\alpha \times \alpha \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\alpha}
\rightarrow
(\sseq{\alpha} \times \alpha)
\\
\cd{collect}
& : &  
(\alpha \times \alpha \rightarrow \mathcal{O})
\rightarrow
\sseq{\alpha \times \beta}
\rightarrow
\sseq{\alpha \times \sseq{\beta}}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomDatatype}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Inspired by mathematical notation for sequences, we use a “sequence comprehensions” notation, which we define below.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Inspired by mathematical notation for sequences, we use a
``sequence comprehensions'' notation, which we  define below.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSyntax}
\begin{dilFieldTitle}
Syntax for Sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Syntax for Sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR5:AT1:syn:seq::seq
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The table below defines the syntax for the sequence ADT. In the definition <span class="math inline">\(i\)</span> is a variable ranging over natural numbers, <span class="math inline">\(x\)</span> is a variable ranging over the elements of a sequence,  <span class="math inline">\(e\)</span> is a SPARC expression, <span class="math inline">\(e_n\)</span> and <span class="math inline">\(e_n&#39;\)</span> are SPARC expressions whose values are natural numbers, <span class="math inline">\(e_s\)</span> is a SPARC expression whose value is a sequence, <span class="math inline">\(p\)</span> is a SPARC pattern that binds one or more variables.</p>

<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(|e_s|\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{length}\)</span> <span class="math inline">\(e_s\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(e_s[i]\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{nth}\)</span> <span class="math inline">\(e_s\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\left\langle\,  \,\right\rangle\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{empty}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\left\langle\, e \,\right\rangle\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{singleton}\)</span> <span class="math inline">\(e\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\left\langle\, e : 0 \leq i &lt; e_n \,\right\rangle\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{tabulate}\)</span> <span class="math inline">\((\texttt{lambda}~{i}\,.\,e)\)</span> <span class="math inline">\({e_n}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\left\langle\, e : p \in e_s \,\right\rangle\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{map}\)</span> <span class="math inline">\((\texttt{lambda}~{p}\,.\,e)\)</span> <span class="math inline">\(e_s\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\left\langle\, x \in e_s \;|\; e \,\right\rangle\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{filter}\)</span> <span class="math inline">\((\texttt{lambda}~{x}\,.\,e)\)</span> <span class="math inline">\(e_s\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(e_s[e_l,\cdots,e_n&#39;]\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{subseq}\)</span> <span class="math inline">\((e_s, e_l, e_n&#39;-e_l+1)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\({e_s}~{\mathop{++}}~{e_s&#39;}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\equiv\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\texttt{append}~e_s~e_s&#39;\)</span></td>
</tr>
</tbody>
</table>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The table below defines the syntax for the sequence ADT.
%
In the definition
%
$i$~is a variable ranging over natural numbers,
%
$x$~is a variable ranging over the elements of a sequence,
%
~$e$~is a \PML expression, 
%
$e_n$ and $e_n'$ are \PML expressions whose values are natural numbers, 
%
$e_s$~is a \PML expression whose value is a sequence, 
%
$p$ is a \PML pattern that binds one or more variables.

\medskip

\begin{tabular}{lcl}
$|e_s|$ & $\equiv$ & $\cd{length}$ $e_s$
\\
$e_s[i]$ & $\equiv$ & $\cd{nth}$ $e_s$
\\
$\cseq{}$ & $\equiv$ & $\cd{empty}$
\\
$\cseq{e}$ & $\equiv$ & $\cd{singleton}$ $e$
\\
 $\cseq{e : 0 \leq i < e_n}$  & $\equiv$ & $\cd{tabulate}$ $(\cfn{i}{e})$ ${e_n}$
\\
$\cseq{e : p \in e_s}$ & $\equiv$ & $\cd{map}$ $(\cfn{p}{e})$ $e_s$
\\

$\cseqf{x \in e_s}{e}$ & $\equiv$ & $\cd{filter}$ $(\cfn{x}{e})$ $e_s$

\\
$e_s[e_l,\cdots,e_n']$ & $\equiv$ & $\cd{subseq}$ $(e_s, e_l, e_n'-e_l+1)$
\\
%
$\kwappend{e_s}{e_s'}$ & $\equiv$ & $\cd{append}~e_s~e_s'$
\end{tabular}

\end{dilFieldBodyDex}
\end{dilAtomSyntax}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Length and indexing
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Length and indexing
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Given a sequence <span class="math inline">\(a\)</span>, <span class="math inline">\(\texttt{length}~a\)</span>, also written <span class="math inline">\(\lvert a \rvert\)</span>, returns the length of <span class="math inline">\(a\)</span>. The function <span class="math inline">\(\texttt{nth}\)</span> returns the element of a sequence at a specified index, e.g. <span class="math inline">\(\texttt{nth}~a~2\)</span>, written <span class="math inline">\(a[2]\)</span>, returns the element of <span class="math inline">\(a\)</span> with rank <span class="math inline">\(2\)</span>. If the element demanded is out of range, the behavior is undefined and leads to an error.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given a sequence $a$, $\cd{length}~a$, also written $\cseqlen{a}$,
returns the length of $a$.
%
The function $\cd{nth}$ returns the element of a sequence at a specified
index, e.g. $\cd{nth}~a~2$, written $a[2]$, returns the element of $a$
with rank $2$.
%
If the element demanded is out of range, the behavior is undefined and
leads to an error.
%
% if for example the index is
% less than $0$ or greater than the rank of the last element, then the
% function returns the special value $\bot$ (bottom), which indicates an
% error or an exception.
%
%% More precisely, we can specify the function \cd{nth} as follows
%% \begin{code}
%% \[
%% \cd{nth}~a~i =
%% \left\{
%% \begin{array}{lc}
%% a[i] & 0 \le i < \cseqlen{a} 
%% \\
%% \bot & \mbox{otherwise.}
%% \end{array} \right.
%% %% 
%% \]
%% \medskip
%% \end{code}

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Empty and singleton
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Empty and singleton
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The value <span class="math inline">\(\texttt{empty}\)</span> is the empty sequence, <span class="math inline">\(\left\langle\,  \,\right\rangle\)</span>. The function <span class="math inline">\(\texttt{singleton}\)</span> takes an element and returns a sequence containing that element, e.g., <span class="math inline">\(\texttt{singleton}~1\)</span> evaluates to <span class="math inline">\(\left\langle\, 1 \,\right\rangle\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The value $\cd{empty}$ is the empty sequence, $\cseq{}$.  The function
$\cd{singleton}$ takes an element and returns a sequence containing that
element, e.g., $\cd{singleton}~1$ evaluates to $\cseq{1}$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Tabulate
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Tabulate
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{tabulate}\)</span> takes a function <span class="math inline">\(f\)</span> and an natural number <span class="math inline">\(n\)</span> and produces a sequence of length <span class="math inline">\(n\)</span> by applying <span class="math inline">\(f\)</span> at each position. The function <span class="math inline">\(f\)</span> can be applied to each element in parallel. We specify <span class="math inline">\(\texttt{tabulate}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{tabulate}&amp;~(f: \mathbb{N}\rightarrow \alpha)~(n: \mathbb{N}) : \mathbb{S}_{\alpha} 
\\ 
&amp;= \left\langle\, f(0), f(1), \ldots, f(n-1) \,\right\rangle. 
\end{alignat}\]</span> We use the following syntax for <span class="math inline">\(\texttt{tabulate}\)</span> operation <span class="math display">\[\left\langle\, e : 0 \leq i &lt; e_n \,\right\rangle \equiv \texttt{tabulate}~(\texttt{lambda}~{i}\,.\,e)~{e_n},\]</span> where <span class="math inline">\(e\)</span> and <span class="math inline">\(e_n\)</span> are expressions, the second evaluating to an integer, and <span class="math inline">\(i\)</span> is a variable. More generally, we can also start at any other, as in: <span class="math display">\[\left\langle\, e : e_j \leq i &lt; e_n \,\right\rangle.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{tabulate}$ takes a function $f$ and an natural number
$n$ and produces a sequence of length $n$ by applying $f$ at each
position.
%
The function $f$ can be applied to each element in parallel.
%
We specify $\cd{tabulate}$ as follows
%
\[
\begin{alignat}{1}
\cd{tabulate}&~(f: \tynat \rightarrow \alpha)~(n: \tynat) : \sseq{\alpha}
\\
&= \cseq{f(0), f(1), \ldots, f(n-1)}.
\end{alignat}
\]
%
We use the following syntax for $\cd{tabulate}$ operation
%
\[
\equivs
{\cseq{e : 0 \leq i < e_n}}
{\cd{tabulate}~(\cfn{i}{e})~{e_n},}
\]
%
where $e$ and $e_n$ are expressions, the second evaluating
to an integer,  and $i$ is a variable.
%
More generally, we can also start at any other, as in:
\[\cseq{e : e_j \leq i < e_n}. \]

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Map
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Map
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A common operation on sequences is to apply some computation to each element of a sequence. For example we might want to add five to each element of a sequence. For this purpose, we can use the operation <span class="math inline">\(\texttt{map}\)</span>, which takes a function <span class="math inline">\(f\)</span> and a sequence <span class="math inline">\(a\)</span> and applies the function <span class="math inline">\(f\)</span> to each element of <span class="math inline">\(a\)</span> returning a sequence of equal length with the results. As with <span class="math inline">\(\texttt{tabulate}\)</span>, in <span class="math inline">\(\texttt{map}\)</span>, the function <span class="math inline">\(f\)</span> can be applied to all the elements of the sequence in parallel. We specify the behavior of <span class="math inline">\(\texttt{map}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{map} &amp;~(f: \alpha  \rightarrow \beta)~(a: \mathbb{S}_{\alpha}) : \mathbb{S}_{\beta} 
\\ 
&amp;~= \left\{ (i,f(x)) : (i,x) \in a \right\} 
\end{alignat}\]</span> or equivalently as <span class="math display">\[\texttt{map}~(f: \alpha  \rightarrow \beta)~\left\langle\, a_1, \ldots, a_{n-1} \,\right\rangle: \mathbb{S}_{\alpha}) : \mathbb{S}_{\beta} 
 =  
\left\langle\, f(a_1), \ldots, f(a_{n-1}) \,\right\rangle.\]</span></p>
<p>We use the following syntax for the <span class="math inline">\(\texttt{map}\)</span> function <span class="math display">\[\left\langle\, e : p \in e_s \,\right\rangle \equiv \texttt{map}~(\texttt{lambda}~{p}\,.\,e)~e_s,\]</span> where <span class="math inline">\(e\)</span> and <span class="math inline">\(e_s\)</span> are expressions, the second evaluating to a sequence, and <span class="math inline">\(p\)</span> is a a pattern of variables (e.g., <span class="math inline">\(x\)</span> or <span class="math inline">\((x,y)\)</span>).</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A common operation on sequences is to apply some computation to each
element of a sequence.  
%
For example we might want to add five to each
element of a sequence.  
%
For this purpose, we can use the operation $\cd{map}$, which takes a
function $f$ and a sequence $a$ and applies the function $f$ to each
element of $a$ returning a sequence of equal length with the results.
%
As with $\cd{tabulate}$, in $\cd{map}$, the function~$f$ can be
applied to all the elements of the sequence in parallel.  
%
We specify the behavior of $\cd{map}$ as follows
\[
\begin{alignat}{1}
\cd{map} &~(f: \alpha  \rightarrow \beta)~(a: \sseq{\alpha}) : \sseq{\beta}
\\
&~= \cset{(i,f(x)) : (i,x) \in a}
\end{alignat}
\]
\smallskip
or equivalently as
\smallskip
\[
\cd{map}~(f: \alpha  \rightarrow \beta)~\cseq{a_1, \ldots, a_{n-1}}: \sseq{\alpha}) : \sseq{\beta}
 = 
\cseq{f(a_1), \ldots, f(a_{n-1})}.
\]

We use the following syntax for the $\cd{map}$ function
%
\[
\equivs
{\cseq{e : p \in e_s}}
{\cd{map}~(\cfn{p}{e})~e_s,}
\]
%
where $e$ and $e_s$ are expressions, the second evaluating to a sequence, and $p$ is a a pattern of
variables (e.g., $x$ or $(x,y)$).

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Filter
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Filter
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To filter out elements from a given sequence, we can use the function <span class="math inline">\(\texttt{filter}\)</span>. The function takes a Boolean function <span class="math inline">\(f\)</span> and a sequence <span class="math inline">\(a\)</span> as arguments and applies <span class="math inline">\(f\)</span> to each element of <span class="math inline">\(a\)</span>, returning the sequence consisting exactly of those elements of <span class="math inline">\(s \in a\)</span> for which <span class="math inline">\(f(s)\)</span> returns true, and maintaining the order of the elements returned. We can specify the behavior of <span class="math inline">\(\texttt{filter}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{filter} &amp; ~(f: \alpha \rightarrow \mathbb{B})~(a: \mathbb{S}_{\alpha}) : \mathbb{S}_{\alpha} 
= 
\\ 
 &amp; ~\left\{\left(\lvert \left\{ (j,y) \in a \;|\; j &lt; i \land f(y) \right\} \rvert, x\right): (i,x) \in a \mid f(x)\right\}. 
\end{alignat}\]</span> As with <span class="math inline">\(\texttt{map}\)</span> and <span class="math inline">\(\texttt{tabulate}\)</span>, the function <span class="math inline">\(f\)</span> in <span class="math inline">\(\texttt{filter}\)</span> can be applied to the elements in parallel.</p>
<p>We use the following syntax for the <span class="math inline">\(\texttt{filter}\)</span> function <span class="math display">\[\left\langle\, x \in e_s \;|\; e \,\right\rangle \equiv \texttt{filter}~(\texttt{lambda}~{x}\,.\,e)~e_s,\]</span> where <span class="math inline">\(e\)</span> and <span class="math inline">\(e_s\)</span> are expressions. In the syntax, note the distinction between the colon (<span class="math inline">\(:\)</span>) and the bar (<span class="math inline">\(\mid\)</span>). We use the colon to draw elements from a sequence for mapping and we use the bar to select the elements that we wish to filter. We can use them together, as in: <span class="math display">\[\begin{alignat}{2} 
  \left\langle\, e : x \in  e_s \;|\; e_f \,\right\rangle &amp; \quad \equiv \quad 
   &amp; \texttt{map} &amp;~(\texttt{lambda}~{x}\,.\,e) 
\\ 
   &amp; &amp; &amp;~(\texttt{filter}~(\texttt{lambda}~{x}\,.\,e_f)~e_s). 
\\ 
\end{alignat}\]</span> What appears before the colon (if any) is an expression to apply each element of the sequence to generate the result; what appears after the bar (if there is any) is an expression to apply to each element to decide whether to keep it.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To filter out elements from a given sequence, we can use the function
$\cd{filter}$.  The function takes a Boolean function~$f$ and a
sequence~$a$ as arguments and applies~$f$ to each element of~$a$,
returning the sequence consisting exactly of those elements of 
$s \in a$ for which $f(s)$ returns true, and maintaining the order of the
elements returned. 
%
We can specify the behavior of $\cd{filter}$ as follows
%
\[
\begin{alignat}{1}
\cd{filter} & ~(f: \alpha \rightarrow \tybool)~(a: \sseq{\alpha}) : \sseq{\alpha}
=
\\
 & ~\left\{\left(\cseqlen{\csetf{(j,y) \in a}{j < i \land f(y)}}, x\right): (i,x) \in a \mid f(x)\right\}.
\end{alignat}
\]
%
As with $\cd{map}$ and $\cd{tabulate}$, the function $f$ in
$\cd{filter}$ can be applied to the elements in parallel.
%

We use the following syntax for the $\cd{filter}$ function
%
\[
\equivs
{\cseqf{x \in e_s}{e}}
{\cd{filter}~(\cfn{x}{e})~e_s,}
\]
%
where $e$ and $e_s$ are expressions.
%
In the syntax, note the distinction between the colon ($:$) and the
bar ($\mid$).
%
We use the colon to draw elements from a sequence for mapping and we
use the bar to select the elements that we wish to filter.
%
We can use them together, as in: 
%
\[
\begin{alignat}{2}
  \cseqf{e : x \in  e_s}{e_f} & \quad \equiv \quad
   & \cd{map} &~(\cfn{x}{e})
\\
   & & &~(\cd{filter}~(\cfn{x}{e_f})~e_s).
\\
\end{alignat}
\]
%
What appears before the colon (if any) is an expression to apply each
element of the sequence to generate the result; what appears after the
bar (if there is any) is an expression to apply to each element to
decide whether to keep it.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Fibonacci
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Fibonacci
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Given the function <span class="math inline">\(\texttt{fib}~i\)</span>, which returns the <span class="math inline">\(i^{th}\)</span> Fibonacci number, the expression: <span class="math display">\[a = \left\langle\, \texttt{fib}~i :  0 \leq i &lt; 9 \,\right\rangle\]</span> is equivalent to <span class="math display">\[a = \texttt{tabulate}~~\texttt{fib}~~9.\]</span> When evaluated, it returns the sequence <span class="math display">\[a = \left\langle\, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 \,\right\rangle.\]</span> The expression <span class="math display">\[\left\langle\, x^2 : x \in a \,\right\rangle\]</span> is equivalent to <span class="math display">\[\texttt{map}~(\texttt{lambda}~{x}\,.\,x^2)~a.\]</span> When evaluated it returns the sequence: <span class="math display">\[\left\langle\, 0, 1, 1, 4, 25, 64, 169, 441, 1156 \,\right\rangle.\]</span> Given the function <span class="math inline">\(\texttt{isPrime}~x\)</span> which checks if <span class="math inline">\(x\)</span> is prime, the expression <span class="math display">\[\left\langle\, x : x \in a ~\mid~\texttt{isPrime}~x \,\right\rangle\]</span> is equivalent to <span class="math display">\[\texttt{filter}~\texttt{isPrime}~a.\]</span> When evaluated, it returns the sequence <span class="math inline">\(\left\langle\, 2,5,13 \,\right\rangle.\)</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given the function $\cd{fib}~i$, which returns the $i^{th}$ Fibonacci
number, the expression:
\[ 
a = \cseq{\cd{fib}~i :  0 \leq i < 9}
\]
%
is equivalent to
%
\[
a = \cd{tabulate}~~\cd{fib}~~9.
\]
%
When evaluated, it returns the sequence
\[
a = \cseq{0, 1, 1, 2, 3, 5, 8, 13, 21, 34}.
\]
%
The expression
\[
\cseq{x^2 : x \in a}
\]
%
is equivalent to
\[
\cd{map}~(\cfn{x}{x^2})~a.
\]
%
When evaluated it returns the sequence:
\[
\cseq{0, 1, 1, 4, 25, 64, 169, 441, 1156}.
\]
%
Given the function $\cd{isPrime}~x$
which checks if $x$ is prime, the expression
\[
\cseq{x : x \in a \sucht \cd{isPrime}~x}
\]
%
is equivalent to
%
\[
\cd{filter}~\cd{isPrime}~a.
\]
When evaluated, it returns the sequence
$
\cseq{2,5,13}.
$

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR12
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Subsequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Subsequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR12:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR12:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The <span class="math inline">\(\texttt{subseq}(a,i,j)\)</span> function extracts a contiguous subsequence of <span class="math inline">\(a\)</span> starting at location <span class="math inline">\(i\)</span> and with length <span class="math inline">\(j\)</span>. If the subsequence is out of bounds of <span class="math inline">\(a\)</span>, only the part within <span class="math inline">\(a\)</span> is returned. We can specify <span class="math inline">\(\texttt{subseq}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{subseq} &amp;~(a:\mathbb{S}_{\alpha})~(i:\mathbb{N})~(j:\mathbb{N}): \mathbb{S}_{\alpha} 
\\ 
&amp;~= \left\{ (k-i,x) : (k,x) \in a \mid i \leq k &lt; i + j \right\}. 
\end{alignat}\]</span></p>
<p>We use the following syntax for denoting subsequences <span class="math display">\[a[e_i \cdots e_j] \equiv \texttt{subseq}~(a,e_i,e_j-e_i+1)
.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The 
%
$\cd{subseq}(a,i,j)$ 
%
function extracts a contiguous subsequence of $a$
starting at location~$i$ and with length~$j$.  If the subsequence is
out of bounds of~$a$, only the part within~$a$ is returned.
%
We can specify $\cd{subseq}$ as follows
\[
\begin{alignat}{1}
\cd{subseq} &~(a:\sseq{\alpha})~(i:\tynat)~(j:\tynat): \sseq{\alpha}
\\
&~= \cset{(k-i,x) : (k,x) \in a \mid i \leq k < i + j}.
\end{alignat}
\]

%
We use the following  syntax for denoting subsequences
%
\[
\equivs
{a\cirange{e_i}{e_j}}
{\cd{subseq}~(a,e_i,e_j-e_i+1)}.
\]

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR13
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR13
\end{dilLabel}
\begin{dilNo}
13
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Splitting sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Splitting sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR13:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR13:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As we shall see in the rest of this book, many algorithms operate inductively on a sequence by splitting the sequence into parts, consisting for example, of the first element and the rest, a.k.a., the  <span style="color: black"><span><strong><em>head</em></strong></span></span> and the  <span style="color: black"><span><strong><em>tail</em></strong></span></span>, or the first half or the second half. We could define functions such as <span class="math inline">\(\texttt{splitHead}\)</span>, <span class="math inline">\(\texttt{splitMid}\)</span>, <span class="math inline">\(\texttt{take}\)</span>, and <span class="math inline">\(\texttt{drop}\)</span> for these purposes. Since all of these are trivially expressible in terms of subsequences, we omit their discussion for simplicity.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As we shall see in the rest of this book, many algorithms operate
inductively on a sequence by splitting the sequence into parts,
consisting for example, of the first element and the rest, a.k.a., the~\defn{head} and the~\defn{tail}, or the first half or the second half.
%
We could define functions such as $\cd{splitHead}$, $\cd{splitMid}$,
$\cd{take}$, and $\cd{drop}$ for these purposes. Since all of these are
trivially expressible in terms of subsequences, we omit their
discussion for simplicity.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR14
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR14
\end{dilLabel}
\begin{dilNo}
14
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Append and flatten
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Append and flatten
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR14:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR14:AT1:gr:seq::append
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>For constructing large sequences from smaller ones, the sequence ADT provides the functions <span class="math inline">\(\texttt{append}\)</span> and <span class="math inline">\(\texttt{flatten}\)</span>. The function <span class="math inline">\(\texttt{append}~(a,b)\)</span> appends the sequence <span class="math inline">\(b\)</span> after the sequence <span class="math inline">\(a\)</span>. More precisely, we can specify <span class="math inline">\(\texttt{append}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{append} &amp; ~(a: \mathbb{S}_{\alpha})~(b: \mathbb{S}_{\alpha}) : \mathbb{S}_{\alpha} 
\\ 
&amp; ~= a \cup \left\{ (i+\lvert a \rvert, x) : (i,x) \in b \right\} 
\end{alignat}\]</span> We write <span class="math inline">\({a}~{\mathop{++}}~{b}\)</span> as a short form for <span class="math inline">\(\texttt{append}~a~b\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
For constructing large sequences from smaller ones, the sequence ADT
provides the  functions $\cd{append}$ and $\cd{flatten}$.
%
The function $\cd{append}~(a,b)$ appends the sequence~$b$
after the sequence~$a$.
%
More precisely, we can specify $\cd{append}$ as follows
\[
\begin{alignat}{1}
\cd{append} & ~(a: \sseq{\alpha})~(b: \sseq{\alpha}) : \sseq{\alpha}
\\
& ~= a \cup \cset{(i+\cseqlen{a}, x) : (i,x) \in b}
\end{alignat}
\]
%
We write $\kwappend{a}{b}$ as a short form for $\cd{append}~a~b$.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR15
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR15
\end{dilLabel}
\begin{dilNo}
15
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Flatten
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Flatten
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR15:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR15:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To append more than two sequences the <span class="math inline">\(\texttt{flatten}~a\)</span> function takes a sequence of sequences and flattens them. If the input is a sequence <span class="math inline">\(a = \left\langle\, a_1,a_2,\ldots,a_n \,\right\rangle\)</span> it appends all the <span class="math inline">\(a_i\)</span>’s. We can specify <span class="math inline">\(\texttt{flatten}\)</span> more precisely as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{flatten} &amp; ~(a: \mathbb{S}_{\mathbb{S}_{\alpha}}) : \mathbb{S}_{\alpha} 
\\ 
&amp; ~= \left\{\left(i +\sum_{(k,c) \in a, k &lt; j}\lvert c \rvert, x\right)  
% 
~:~ (i,x) \in b, (j,b) \in a \right\}. 
\end{alignat}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To append more than two sequences the $\cd{flatten}~a$ function
takes a sequence of sequences and flattens them. If the input is
a sequence $a = \cseq{a_1,a_2,\ldots,a_n}$ it appends all the $a_i$'s.
%
We can specify $\cd{flatten}$ more precisely as follows
\[
\begin{alignat}{1}
\cd{flatten} & ~(a: \sseq{\sseq{\alpha}}) : \sseq{\alpha}
\\
& ~= \left\{\left(i +\sum_{(k,c) \in a, k < j}\cseqlen{c}, x\right) 
%
~:~ (i,x) \in b, (j,b) \in a \right\}.
\end{alignat}
\]

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR16
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR16
\end{dilLabel}
\begin{dilNo}
16
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Append and flatten
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Append and flatten
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR16:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR16:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN2:GR14:AT1:gr:seq::append
\end{dilParents}
\begin{dilFieldBody}
<p>The <span class="math inline">\(\texttt{append}\)</span> operation <span class="math inline">\({\left\langle\, 1,2,3 \,\right\rangle}~{\mathop{++}}~{\left\langle\, 4,5 \,\right\rangle}\)</span> yields the sequence <span class="math inline">\(\left\langle\, 1,2,3,4,5 \,\right\rangle.\)</span></p>
<p>The <span class="math inline">\(\texttt{flatten}\)</span> operation <span class="math display">\[\texttt{flatten}~\left\langle\, \left\langle\, 1,2,3 \,\right\rangle,\left\langle\, 4 \,\right\rangle,\left\langle\, 5,6 \,\right\rangle \,\right\rangle\]</span> yields the sequence <span class="math inline">\(\left\langle\, 1,2,3,4,5,6 \,\right\rangle\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The $\cd{append}$ operation $\kwappend{\cseq{1,2,3}}{\cseq{4,5}}$ yields the sequence $\cseq{1,2,3,4,5}.$

The $\cd{flatten}$ operation 
\[
\cd{flatten}~\cseq{\cseq{1,2,3},\cseq{4},\cseq{5,6}}
\]
 yields the sequence $\cseq{1,2,3,4,5,6}$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR17
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR17
\end{dilLabel}
\begin{dilNo}
17
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Updates and injections
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Updates and injections
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR17:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR17:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{update}~(a,(i,x))\)</span>, updates location <span class="math inline">\(i\)</span> of sequence <span class="math inline">\(a\)</span> to contain the value <span class="math inline">\(x\)</span>. If the location is out of range for the sequence, the function returns the input sequence unchanged. We can specify <span class="math inline">\(\texttt{update}\)</span> as follows <span class="math display">\[\begin{alignat}{1} 
\texttt{update} &amp; ~(a:\mathbb{S}_{\alpha})~(i:\mathbb{N},x:\alpha): \mathbb{S}_{\alpha} 
\\[1mm] 
&amp; ~=   
\left\{ 
\begin{array}{ll} 
\left\{(j, y) : (j, y) \in a \mid j \not= i\right\} \cup \left\{(i, x)\right\} &amp; \mbox{if}~0 
\le i &lt; |{a}| 
\\ 
a &amp; \mbox{otherwise}. 
\end{array} 
\right. 
\end{alignat}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{update}~(a,(i,x))$, updates location $i$ of
sequence $a$ to contain the value $x$.  If the location is out of
range for the sequence, the function returns the input sequence
unchanged.  
%
We can specify $\cd{update}$ as follows
\[
\begin{alignat}{1}
\cd{update} & ~(a:\sseq{\alpha})~(i:\tynat,x:\alpha): \sseq{\alpha}
\\[1mm]
& ~=  
\left\{
\begin{array}{ll}
\left\{(j, y) : (j, y) \in a \mid j \not= i\right\} \cup \left\{(i, x)\right\} & \mbox{if}~0
\le i < \csetsize{a}
\\
a & \mbox{otherwise}.
\end{array}
\right.
\end{alignat}
\]
\medskip

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR18
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR18
\end{dilLabel}
\begin{dilNo}
18
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Inject
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Inject
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR18:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR18:AT1:gr:seq::inject
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To update multiple positions at once, we can use <span class="math inline">\(\texttt{inject}\)</span>. The function <span class="math inline">\(\texttt{inject}~(a,b)\)</span> takes a sequence <span class="math inline">\(b\)</span> of location-value pairs and updates each location with its associated value. If any locations are out of range, that pair does nothing. If multiple locations are the same, one of the updates take effect.</p>
<p>In the case of duplicates in the update sequence <span class="math inline">\(b\)</span>, i.e., multiple updates to the same position, we leave it unspecified which update takes effect. The operation <span class="math inline">\(\texttt{inject}\)</span> may thus treat duplicate updates non-deterministically.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To update multiple positions at once, we can use $\cd{inject}$.
%
The function $\cd{inject}~(a,b)$ takes a sequence $b$ of
location-value pairs and updates each location with its associated
value.  
%
If any locations are out of range, that pair does nothing.  If
multiple locations are the same,  one of the updates take effect.
%

In the case of duplicates in the update sequence $b$, i.e., multiple
updates to the same position, we leave it unspecified which update
takes effect.
%
The operation $\cd{inject}$ may thus treat duplicate updates
non-deterministically.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR19
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR19
\end{dilLabel}
\begin{dilNo}
19
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Inject
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Inject
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR19:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR19:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN2:GR18:AT1:gr:seq::inject
\end{dilParents}
\begin{dilFieldBody}
<p>Given the string sequence <span class="math display">\[a = \left\langle\, \text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{cat}}\,\text{&#39;},\text{&#39;}\,{\texttt{in}}\,\text{&#39;},\text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{hat}}\,\text{&#39;} \,\right\rangle,\]</span> <span class="math display">\[\texttt{update}~a~(1,\text{&#39;}\,{\texttt{rabbit}}\,\text{&#39;})\]</span> magically yields <span class="math display">\[\left\langle\, \text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{rabbit}}\,\text{&#39;},\text{&#39;}\,{\texttt{in}}\,\text{&#39;},\text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{hat}}\,\text{&#39;} \,\right\rangle\]</span> since location <span class="math inline">\(1\)</span> is updated with <span class="math inline">\(\text{&#39;}\,{\texttt{rabbit}}\,\text{&#39;}\)</span>. The expression <span class="math display">\[\texttt{inject}~a~\left\langle\, (4,\text{&#39;}\,{\texttt{log}}\,\text{&#39;}),(1,\text{&#39;}\,{\texttt{dog}}\,\text{&#39;}),(6,\text{&#39;}\,{\texttt{hog}}\,\text{&#39;}),(4,\text{&#39;}\,{\texttt{bog}}\,\text{&#39;}),(0,\text{&#39;}\,{\texttt{a}}\,\text{&#39;}) \,\right\rangle\]</span> could yield <span class="math display">\[\left\langle\, \text{&#39;}\,{\texttt{a}}\,\text{&#39;},\text{&#39;}\,{\texttt{dog}}\,\text{&#39;},\text{&#39;}\,{\texttt{in}}\,\text{&#39;},\text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{bog}}\,\text{&#39;} \,\right\rangle\]</span> since location <span class="math inline">\(0\)</span> is updated with <span class="math inline">\(\text{&#39;}\,{\texttt{a}}\,\text{&#39;}\)</span>, location <span class="math inline">\(1\)</span> with <span class="math inline">\(\text{&#39;}\,{\texttt{dog}}\,\text{&#39;}\)</span>, and location <span class="math inline">\(4\)</span> with <span class="math inline">\(\text{&#39;}\,{\texttt{bog}}\,\text{&#39;}\)</span>. It could also yield <span class="math display">\[\left\langle\, \text{&#39;}\,{\texttt{a}}\,\text{&#39;},\text{&#39;}\,{\texttt{dog}}\,\text{&#39;},\text{&#39;}\,{\texttt{in}}\,\text{&#39;},\text{&#39;}\,{\texttt{the}}\,\text{&#39;},\text{&#39;}\,{\texttt{log}}\,\text{&#39;} \,\right\rangle\]</span> The entry with location <span class="math inline">\(6\)</span> is ignored since it is out of range for <span class="math inline">\(a\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given the string sequence 
\[ 
a = \cseq{\cstr{the},\cstr{cat},\cstr{in},\cstr{the},\cstr{hat}},\]
\[
\cd{update}~a~(1,\cstr{rabbit})
\]
magically yields
\[
\cseq{\cstr{the},\cstr{rabbit},\cstr{in},\cstr{the},\cstr{hat}}
\]
since location $1$ is updated with $\cstr{rabbit}$.  The expression
\[
\cd{inject}~a~\cseq{(4,\cstr{log}),(1,\cstr{dog}),(6,\cstr{hog}),(4,\cstr{bog}),(0,\cstr{a})}
\]
could yield
\[ 
\cseq{\cstr{a},\cstr{dog},\cstr{in},\cstr{the},\cstr{bog}}
\]
since location $0$ is updated with $\cstr{a}$, location $1$ with
$\cstr{dog}$, and location $4$ with $\cstr{bog}$.
%
It could also yield
\[ 
\cseq{\cstr{a},\cstr{dog},\cstr{in},\cstr{the},\cstr{log}}
\]
%
The entry with location $6$ is ignored
since it is out of range for $a$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR20
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR20
\end{dilLabel}
\begin{dilNo}
20
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Collect
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Collect
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR20:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR20:AT1:gr:seq::collect
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The primitive <span class="math inline">\(\texttt{collect}\)</span> is useful when elements of a sequence are “keyed”, making it possible to associate data with some key. Such pairs consisting of a key and a value are sometimes called  <span style="color: black"><span><strong><em>key-value</em></strong></span></span> pairs. Given a sequence of key-value pairs, we might want to  <span style="color: black"><span><strong><em>collect</em></strong></span></span> together all the values for a given key. Collecting values together based on a key is very common in processing databases. In relational database languages such as SQL it is referred to as “Group by”. More generally it has many applications.</p>
<p>We will use the function <span class="math inline">\(\texttt{collect}\)</span> for this purpose, and it is part of the sequence library. Its type signature is <span class="math display">\[\texttt{collect} 
:  
(\texttt{cmp}: \alpha \times \alpha \rightarrow \mathcal{O}) 
\rightarrow 
(a: \mathbb{S}_{\alpha \times \beta}) 
\rightarrow 
\mathbb{S}_{\alpha \times \mathbb{S}_{\beta}}.\]</span> Here the &quot;order set&quot; <span class="math inline">\(\mathcal{O} = \{\texttt{less}, \texttt{equal}, \texttt{greater}\}\)</span>.</p>
<p>The first argument <span class="math inline">\(cmp\)</span> is a function for comparing keys of type <span class="math inline">\(\alpha\)</span>, and must define a total order over the keys. The second argument <span class="math inline">\(a\)</span> is a sequence of key-value pairs. The <span class="math inline">\(\texttt{collect}\)</span> function collects all values in <span class="math inline">\(a\)</span> that share the same key together into a sequence, ordering the values in the same order as their appearance in the original sequence.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The primitive $\cd{collect}$ is useful when elements of a sequence
are ``keyed'', making it possible to associate data with some key.
Such pairs consisting of a key and a value are sometimes called~\defn{key-value} pairs.
%
Given a sequence of key-value pairs, we might want to~\defn{collect}
together all the values for a given key.
%
Collecting values together based on a key is very common in processing
databases.  In relational database languages such as SQL it is
referred to as ``Group by''.  More generally it has many applications.


We will use the function $\cd{collect}$ for this purpose, and it is part
of the sequence library.   Its type signature is
\[
\cd{collect}
: 
(\cd{cmp}: \alpha \times \alpha \rightarrow \mathcal{O})
\rightarrow
(a: \sseq{\alpha \times \beta})
\rightarrow
\sseq{\alpha \times \sseq{\beta}}.
\]
%
Here the "order set" $\mathcal{O} = \{\cd{less}, \cd{equal}, \cd{greater}\}$. 

The first argument $cmp$ is a function for comparing keys of type $\alpha$,
and must define a total order over the keys.  
%
The second argument $a$ is a sequence of key-value pairs.  
%
The $\cd{collect}$ function collects all values in $a$ that share the
same key together into a sequence, ordering the values in the same
order as their appearance in the original sequence.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR21
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR21
\end{dilLabel}
\begin{dilNo}
21
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Collect
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Collect
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR21:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR21:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN2:GR20:AT1:gr:seq::collect
\end{dilParents}
\begin{dilFieldBody}
<p>The following sequence shows a sequence of key-value pairs consisting of our students from last semester and the classes they take. <span class="math display">\[\begin{alignat}{1} 
kv  = \langle  
&amp; (\text{&#39;}\,{\texttt{jack}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15210}}\,\text{&#39;}), (\text{&#39;}\,{\texttt{jack}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15213}}\,\text{&#39;}) 
\\ 
&amp; (\text{&#39;}\,{\texttt{mary}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15210}}\,\text{&#39;}), (\text{&#39;}\,{\texttt{mary}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15213}}\,\text{&#39;}), (\text{&#39;}\,{\texttt{mary}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15251}}\,\text{&#39;}), 
\\ 
&amp; (\text{&#39;}\,{\texttt{peter}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15150}}\,\text{&#39;}), (\text{&#39;}\,{\texttt{peter}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15251}}\,\text{&#39;}),  
\\ 
&amp; \ldots 
\\ 
\rangle &amp; .            
\end{alignat}\]</span> We can determine the classes taken by each student by using <span class="math inline">\(\texttt{collect}~\texttt{cmp}\)</span>, where <span class="math inline">\(\texttt{cmp}\)</span> is a comparison function for strings <span class="math display">\[\begin{alignat}{1} 
\texttt{collect}~\texttt{cmp}~kv = \langle 
~&amp;~ (\text{&#39;}\,{\texttt{jack}}\,\text{&#39;}, \left\langle\, \text{&#39;}\,{\texttt{15210}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15213}}\,\text{&#39;}, \ldots \,\right\rangle) 
\\ 
~&amp;~ (\text{&#39;}\,{\texttt{mary}}\,\text{&#39;}, \left\langle\, \text{&#39;}\,{\texttt{15210}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15213}}\,\text{&#39;},  \text{&#39;}\,{\texttt{15251}}\,\text{&#39;}, \ldots \,\right\rangle), 
\\ 
~&amp;~ (\text{&#39;}\,{\texttt{peter}}\,\text{&#39;}, \left\langle\, \text{&#39;}\,{\texttt{15150}}\,\text{&#39;}, \text{&#39;}\,{\texttt{15251}}\,\text{&#39;}, \ldots \,\right\rangle),  
\\ 
~&amp;~ \ldots 
\\ 
\rangle ~&amp;~ .            
\end{alignat}\]</span> Note that the output sequence is ordered based on the first instance of their key in the input sequences. Similarly, the order of the classes taken by each student are the same as in the input sequence.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following sequence shows a sequence of key-value pairs consisting
of our students from last semester and the classes they take.
%
\[
\begin{alignat}{1}
kv  = \langle 
& (\cstr{jack}, \cstr{15210}), (\cstr{jack}, \cstr{15213})
\\
& (\cstr{mary}, \cstr{15210}), (\cstr{mary}, \cstr{15213}), (\cstr{mary}, \cstr{15251}),
\\
& (\cstr{peter}, \cstr{15150}), (\cstr{peter}, \cstr{15251}), 
\\
& \ldots
\\
\rangle & .           
\end{alignat}
\]
%
We can determine the classes taken by each student by using
$\cd{collect}~\cd{cmp}$, where $\cd{cmp}$ is a comparison function for
strings
\[
\begin{alignat}{1}
\cd{collect}~\cd{cmp}~kv = \langle
~&~ (\cstr{jack}, \cseq{\cstr{15210}, \cstr{15213}, \ldots})
\\
~&~ (\cstr{mary}, \cseq{\cstr{15210}, \cstr{15213},  \cstr{15251}, \ldots}),
\\
~&~ (\cstr{peter}, \cseq{\cstr{15150}, \cstr{15251}, \ldots}), 
\\
~&~ \ldots
\\
\rangle ~&~ .           
\end{alignat}
\]
%
Note that the output sequence is ordered based on the first instance
of their key in the input sequences.  
%
Similarly, the order of the classes taken by each student are the same
as in the input sequence.
%

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR22
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN2:GR22
\end{dilLabel}
\begin{dilNo}
22
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Checking for empty and singularity sequences
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Checking for empty and singularity sequences
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN2:GR22:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN2:GR22:AT1:gr:seq::check-small
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To identify trivial sequences such as empty sequences and singular sequences, which contain only one element, the interface provides the functions <span class="math inline">\(\texttt{isEmpty}\)</span> and <span class="math inline">\(\texttt{isSingular}\)</span>, which return respectively return <span class="math inline">\(\texttt{true}\)</span> if the sequence is empty or singular and return <span class="math inline">\(\texttt{false}\)</span> otherwise.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To identify trivial sequences such as empty sequences and singular
sequences, which contain only one element, the interface provides the
functions $\cd{isEmpty}$ and $\cd{isSingular}$, which return
respectively return $\cd{true}$ if the sequence is empty or singular
and return $\cd{false}$ otherwise.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Aggregation by Iteration
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Aggregation by Iteration
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH8:SEC1:UN3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
The <span class="math inline">\(\texttt{iterate}\)</span> function
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The $\cd{iterate}$ function
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR1:AT1:gr:seq::iterate
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Iteration is a key concept in computing, and specifically in algorithm design. Iteration involves a sequence of steps, taken one after another, where each step transforms the state from the previous step. Iteration is therefore an inherently sequential process. The function <span class="math inline">\(\texttt{iterate}\)</span> can be used to create a computation that iterates over a sequence while accumulating information. It starts with an initial state and a sequence, and on each step updates the state based on the next element of the sequence.</p>
<p>The function <span class="math inline">\(\texttt{iterate}\)</span> has the type signature <span class="math display">\[\texttt{iterate}~(f: \alpha \times \beta \rightarrow\alpha)~(x: \alpha)~(a: 
\mathbb{S}_{\beta}) : \alpha\]</span></p>
<p>where <span class="math inline">\(f\)</span> is a function mapping a state and an element of <span class="math inline">\(a\)</span> to a new state, <span class="math inline">\(x\)</span> is the initial state, <span class="math inline">\(a\)</span> is a sequence.</p>
<p>The semantics of <span class="math inline">\(\texttt{iterate}\)</span> is defined as follows. <span class="math display">\[\texttt{iterate}~f~x~a 
=   
\left\{ 
\begin{array}{ll} 
x &amp; \mbox{if}~ \lvert a \rvert= 0\\ 
f(x, a[0]) &amp; \mbox{if}~\lvert a \rvert= 1\\ 
\texttt{iterate}~f~(f(x, a[0])) (a[1 \cdots \lvert a \rvert-1]) &amp; \mbox{otherwise.} 
\end{array} 
\right.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Iteration is a key concept in computing, and specifically in algorithm
design.  
%
Iteration involves a sequence of steps, taken one after another, where
each step transforms the state from the previous step.  
%
Iteration is therefore an inherently sequential process.
%
The function $\cd{iterate}$ can be used to create a computation that
iterates over a sequence while accumulating information.
%
It starts with an initial state and a sequence, and on each step
updates the state based on the next element of the sequence.
%


The function $\cd{iterate}$ has the type signature
\[
\cd{iterate}~(f: \alpha \times \beta \ra \alpha)~(x: \alpha)~(a:
\sseq{\beta}) : \alpha
\]

where $f$ is a function mapping a state and an element of $a$ to a new
state, $x$ is the initial state,  $a$ is a sequence.
%
%

The semantics of $\cd{iterate}$ is defined as follows.
\[
\cd{iterate}~f~x~a
=  
\left\{
\begin{array}{ll}
x & \mbox{if}~ \cseqlen{a}= 0\\
f(x, a[0]) & \mbox{if}~\cseqlen{a}= 1\\
\cd{iterate}~f~(f(x, a[0])) (a\cirange{1}{\cseqlen{a}-1}) & \mbox{otherwise.}
\end{array}
\right.
\]

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Iteration with prefixes
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Iteration with prefixes
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As a variant of iteration, we define <span class="math inline">\(\texttt{iteratePrefixes}\)</span>, which takes the same arguments but returns all the intermediate values computed as a sequence.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As a variant of iteration, we define $\cd{iteratePrefixes}$, which
takes the same arguments but returns all the intermediate values
computed as a sequence.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{iterate}\)</span> computes its final result by computing a result for each element of the sequence. Concretely, <span class="math inline">\(\texttt{iterate}~f~x~a\)</span> computes the results <span class="math inline">\(x_i\)</span>, <span class="math inline">\(0 \le i \le n 
= \lvert a \rvert\)</span>. <span class="math display">\[\begin{array}{lcl} 
x_0 &amp; = &amp; x 
\\ 
x_1 &amp; = &amp; f(x_0,a[0]) 
\\ 
x_2 &amp; = &amp; f(x_1, a[1]) 
\\ 
&amp; \vdots &amp; 
\\ 
x_{n} &amp; = &amp; f(x_{n-1},a[n-1]). 
\end{array}\]</span> As the result <span class="math display">\[\texttt{iterate}~f~x~a\]</span> returns <span class="math inline">\(x_n\)</span>.</p>
<p>The expression <span class="math display">\[\texttt{iteratePrefixes}~f~x~a\]</span> performs the same computation and returns <span class="math inline">\(\left\langle\, x_0, \ldots, x_n \,\right\rangle\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{iterate}$ computes its final result by computing a
result for each element of the sequence.
%
Concretely, $\cd{iterate}~f~x~a$ computes the results $x_i$, $0 \le i \le n
= \cseqlen{a}$.
\[
\begin{array}{lcl}
x_0 & = & x
\\
x_1 & = & f(x_0,a[0])
\\
x_2 & = & f(x_1, a[1])
\\
& \vdots &
\\
x_{n} & = & f(x_{n-1},a[n-1]).
\end{array}
\]
%
As the result
%
\[
\cd{iterate}~f~x~a
\]
%
returns  $x_n$.
%

The expression
%
\[
\cd{iteratePrefixes}~f~x~a
\]
%
performs the same computation and
returns  $\cseq{x_0, \ldots, x_n}$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Iteration
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Iteration
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN3:GR1:AT1:gr:seq::iterate
\end{dilParents}
\begin{dilFieldBody}
<p>For a sequence of length <span class="math inline">\(5\)</span>, iteration computes its final result as <span class="math display">\[\texttt{iterate}~f~x~a  = f(f(f(f(f(v,a[0]),a[1]),a[2]),a[3]),a[4]).\]</span></p>
<p>For example, <span class="math display">\[\texttt{iterate}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~\left\langle\, 2, 5, 1, 6 \,\right\rangle\]</span> returns <span class="math inline">\(14\)</span> since it starts with the integer state <span class="math inline">\(0\)</span> and then one by one adds the integer elements <span class="math inline">\(2\)</span>, <span class="math inline">\(5\)</span>, <span class="math inline">\(1\)</span> and <span class="math inline">\(6\)</span> of the sequence to the state.</p>
<p>Similarly <span class="math display">\[\texttt{iterate}~\text{&#39;}\,{\texttt{-}}\,\text{&#39;}~0~\left\langle\, 2, 5, 1, 6 \,\right\rangle\]</span> returns <span class="math inline">\((((0 - 2) - 5) - 1) - 6 = -14\)</span>.</p>
<p>The function <span class="math display">\[\texttt{iterate}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}~0~(\texttt{map}~\texttt{zeroWhenEven}~a),\]</span> which uses the function <span class="math inline">\(\texttt{zeroWhenEven}\)</span> to map even numbers to zero, sums up only the odd numbers in sequence <span class="math inline">\(a,\)</span> returning <span class="math inline">\(6\)</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
For a sequence of length $5$, iteration computes its final result  as
\[
\cd{iterate}~f~x~a  = f(f(f(f(f(v,a[0]),a[1]),a[2]),a[3]),a[4]).
\]
%

For example,
\[
\cd{iterate}~\cstr{+}~0~\cseq{2, 5, 1, 6}
\]
returns $14$ since it starts with the integer state $0$ and then one
by one adds the integer elements $2$, $5$, $1$ and $6$ of the sequence
to the state. 

Similarly
\[
\cd{iterate}~\cstr{-}~0~\cseq{2, 5, 1, 6}
\]
returns $(((0 - 2) - 5) - 1) - 6 = -14$.
%

The function 
\[
\cd{iterate}~\cstr{+}~0~(\cd{map}~\cd{zeroWhenEven}~a),
\]
which uses the function $\cd{zeroWhenEven}$ to map even numbers to zero,
sums up only the odd numbers in sequence $a,$~returning $6$

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>You are likely familiar with what a properly matched strings are but how can we define such strings?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
You are likely familiar with what a properly matched strings are but
how can we define such strings?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
Parantheses matching
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parantheses matching
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Parantheses matching
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parantheses matching
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
def:seq::iterate
\end{dilParents}
\begin{dilFieldBody}
<p>We say a string is matched if it can be described recursively as <span class="math display">\[p = \left\langle\,  \,\right\rangle \mid p~p \mid \text{&#39;}\,{(}\,\text{&#39;}~p~\text{&#39;}\,{)}\,\text{&#39;},\]</span> where <span class="math inline">\(\left\langle\,  \,\right\rangle\)</span> is the empty sequence, <span class="math inline">\(p~p\)</span> indicates appending two strings of matched parentheses (recursively defined), and <span class="math inline">\(\text{&#39;}\,{(}\,\text{&#39;}~p~\text{&#39;}\,{)}\,\text{&#39;}\)</span> indicates the string starting with <span class="math inline">\(\text{&#39;}\,{(}\,\text{&#39;}\)</span> followed by a matched string <span class="math inline">\(p\)</span> followed by <span class="math inline">\(\text{&#39;}\,{)}\,\text{&#39;}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We say a string is matched if it can be described recursively
as
\[
p = \cseq{} \mid p~p \mid \chr{(}~p~\chr{)}, 
\]
where $\cseq{}$ is the empty sequence, $p~p$ indicates appending two
strings of matched parentheses (recursively defined), and
$\chr{(}~p~\chr{)}$ indicates the string starting with $\chr{(}$
followed by a matched string $p$ followed by $\chr{)}$.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Parenthesis matching
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parenthesis matching
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR6:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR6:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The string <span class="math inline">\(\text{&#39;}\,{\texttt{(())()}}\,\text{&#39;}\)</span> is matched. The <span class="math inline">\(\text{&#39;}\,{\texttt{())(()}}\,\text{&#39;}\)</span> is not matched.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The string $\cstr{(())()}$ is matched.
%
The $\cstr{())(()}$ is not matched.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomProblem}
\begin{dilFieldTitle}
Parentheses matching
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parentheses matching
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR7:AT1:pr:seq::matching
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The <em>parentheses matching</em> problem requires determining whether a given a string of parentheses is matched.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The \emph{parentheses matching} problem requires determining whether a
given a string of parentheses is matched.

\end{dilFieldBodyDex}
\end{dilAtomProblem}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
Parethesis matching via iteration
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parethesis matching via iteration
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN3:GR1:AT1:gr:seq::iterate, atom:15210:S18:CH8:SEC1:UN3:GR7:AT1:pr:seq::matching
\end{dilParents}
\begin{dilFieldBody}
<p>Can you solve this problem using <span class="math inline">\(\texttt{iterate}\)</span>?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Can you solve this problem  using $\cd{iterate}$?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Parethesis matching via iteration
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parethesis matching via iteration
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As an application of iteration, let’s try to solve the parenthesis matching problem. We can solve this problem by starting at the beginning of the sequence with a counter set to zero and iterating through the elements one by one. If we ever see a left parenthesis we increment the counter and whenever we see a right parenthesis we decrement the counter. A sequence of parentheses can only be matched if the count ends at <span class="math inline">\(0\)</span> since being matched requires that there are an equal number of right and left parentheses. However ending with a count of <span class="math inline">\(0\)</span> is not adequate since the string <span class="math inline">\(\text{&#39;}\,{\texttt{))((}}\,\text{&#39;}\)</span> has count <span class="math inline">\(0\)</span> but is obviously not matched. It also has to be the case that the count can never go below <span class="math inline">\(0\)</span> during the iterations.</p>
<p>This observation leads to the algorithm shown below. The algorithm starts with the state <span class="math inline">\(\texttt{Some}~{0}\)</span> and increments or decrements the counter on a left and right parenthesis, respectively. If the iterations ever encounter a right parenthesis when the count is zero, this indicates the count will go below zero, and at this point the state is changed to <span class="math inline">\(\texttt{None}\)</span>, which is propagated through the rest of the iterations to the result. Therefore at the end if the state is <span class="math inline">\(\texttt{Some}~{0}\)</span> then the counter never went below zero and ended up at zero so the parentheses must be matched.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As an application of iteration, let's try to solve the parenthesis
matching problem.
%
%% There are a several algorithms for solving this problem.  Here we
%% consider a linear-work sequential algorithm based on $\cd{iterate}$.  In
%% Chapter~\ref{ch:divide-and-conquer}, we present a divide-and-conquer
%% algorithm that requires no more work asymptotically, but has a low
%% span.
%
We can solve this problem by starting at the beginning of the sequence
with a counter set to zero and iterating through the elements one by
one.  If we ever see a left parenthesis we increment the counter and
whenever we see a right parenthesis we decrement the counter.
%
A sequence of parentheses can only be matched if the count ends at~$0$
since being matched requires that there are an equal number of right
and left parentheses.  However ending with a count of~$0$ is not
adequate since the string~$\cstr{))((}$ has count~$0$ but is obviously
not matched.  It also has to be the case that the count can never go
below~$0$ during the iterations.  

This observation leads to the algorithm shown below.
%
The algorithm starts with the state  $\csome{0}$ and
increments or decrements the counter on a left and right parenthesis,
respectively.  If the iterations ever encounter a right parenthesis
when the count is zero, this indicates the count will go below zero,
and at this point the state is changed to $\cd{None}$, which is
propagated through the rest of the iterations to the result.
Therefore at the end if the state is $\csome{0}$ then the counter
never went below zero and ended up at zero so the parentheses must be matched.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Parenthesis matching via iterate
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parenthesis matching via iterate
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR10:AT1:alg:seq::iterate::pmatch
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN3:GR1:AT1:gr:seq::iterate
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[\begin{array}{l} 
\texttt{matchParens}~a = \\  
~~\texttt{let} \\ 
~~~~\texttt{count}~(s, x) = \\ 
~~~~~~\texttt{case}~(s, x) \\  
~~~~~~~~|~(\texttt{None}, \texttt{_}) \Rightarrow\texttt{None}\\ 
~~~~~~~~|~(\texttt{Some}~n, \texttt{&#39;)&#39;}) \Rightarrow\texttt{if}~(n = 0)~\texttt{then}~\texttt{None}~\texttt{else}~\texttt{Some}~(n - 1)\\ 
~~~~~~~~|~(\texttt{Some}~n, \texttt{&#39;(&#39;}) \Rightarrow\texttt{Some}~(n + 1)\\ 
~~\texttt{in}\\ 
~~~~(\texttt{iterate}~\texttt{count}~(\texttt{Some}~0)~a) = \texttt{Some}~0 \\ 
~~\texttt{end} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
\begin{array}{l}
\cd{matchParens}~a = \\ 
~~\cd{let} \\
~~~~\cd{count}~(s, x) = \\
~~~~~~\cd{case}~(s, x) \\ 
~~~~~~~~|~(\cd{None}, \cignore) \dra \cd{None}\\
~~~~~~~~|~(\cd{Some}~n, \cd{')'}) \dra \cd{if}~(n = 0)~\cd{then}~\cd{None}~\cd{else}~\cd{Some}~(n - 1)\\
~~~~~~~~|~(\cd{Some}~n, \cd{'('}) \dra \cd{Some}~(n + 1)\\
~~\cd{in}\\
~~~~(\cd{iterate}~\cd{count}~(\cd{Some}~0)~a) = \cd{Some}~0 \\
~~\cd{end}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
Order of additions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Order of additions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider the algorithm for summing the numbers in a sequence of natural numbers <span class="math inline">\(a\)</span> using <span class="math inline">\(\texttt{iterate}\)</span>: <span class="math display">\[\texttt{iterate}~\text{&#39;}\,{\texttt{+}}\,\text{&#39;}  0 a\]</span></p>
<p>This algorithm performs the plus operations in a particular order. Is this necessary?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider the algorithm for summing the numbers in a sequence of
natural numbers $a$ using $\cd{iterate}$:
%
\[
\cd{iterate}~\cstr{+}  0 a
\]

This algorithm performs the plus operations in a particular order.  Is
this necessary?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR12
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN3:GR12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Iteration and order of operations
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Iteration and order of operations
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN3:GR12:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN3:GR12:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Iteration is a powerful technique but can be too big of a hammer, especially when used unnecessarily. For example, when summing the elements in a sequence, we don’t need to perform the addition operations in a particular order because addition operations are associative and thus they can be performed in any order desired. The iteration-based algorithm for computing the sum does not take advantage of this property, computing instead the sum in a left-to-right order. As we will see next, we can use the associativity of the addition operations to sum up the elements of a sequence in parallel.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Iteration is a powerful technique but can be too big of a hammer,
especially when used unnecessarily.  
%
For example, when summing the elements in a sequence, we don't need to
perform the addition operations in a particular order because addition
operations are associative and thus they can be performed in any order
desired.  
%
The iteration-based algorithm for computing the sum does not take
advantage of this property, computing instead the sum in a
left-to-right order.
%
As we will see next, we can use the associativity of the addition
operations to sum up the elements of a sequence in parallel.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Aggregation by Reduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Aggregation by Reduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH8:SEC1:UN4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Reduction
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Reduction
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR1:AT1:gr:seq::reduce-intro
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The term  <span style="color: black"><span><strong><em>reduction</em></strong></span></span> refers to a computation that repeatedly applies an associative binary operation to a collection of elements until the result is reduced to a single value. Recall that associative operations are defined as operations that allow commuting the order of operations.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The term~\defn{reduction} refers to a computation that repeatedly
applies an associative binary operation to a collection of elements
until the result is reduced to a single value.
%
Recall that  associative operations are defined as operations that
allow commuting the order of operations.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
Associativity
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Associativity
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Assocative Function
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Assocative Function
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR2:AT1:def:seq::assoc
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A function <span class="math inline">\(f: \alpha \times \alpha \rightarrow \alpha\)</span> is associative if <span class="math inline">\(f(f(x,y),z) = f(x,f(y,z))\)</span> for all <span class="math inline">\(x,y\)</span> and <span class="math inline">\(z\)</span> of type <span class="math inline">\(\alpha\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A function~$f: \alpha \times \alpha \rightarrow \alpha$ is associative
if $f(f(x,y),z) = f(x,f(y,z))$ for all $x,y$ and $z$ of type $\alpha$.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR2:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR2:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Associativity implies that when applying <span class="math inline">\(f\)</span> to some values, the order in which the applications are performed does not matter. Associativity does not mean that you can reorder the arguments to a function (that would be commutativity).</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Associativity implies that when applying $f$ to some values, the order
in which the applications are performed does not matter.
%
Associativity does not mean that you can reorder the arguments to a
function (that would be commutativity).

\end{dilFieldBodyDex}
\end{dilAtomNote}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR2:AT3
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR2:AT3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Many functions are associative.</p>
<ul>
<li><p>Addition and multiplication on natural numbers are associative, with 0 and 1 as their identities, respectively.</p></li>
<li><p>Minimum and maximum are also associative with identities <span class="math inline">\(\infty\)</span> and <span class="math inline">\(-\infty\)</span> respectively.</p></li>
<li><p>The <span class="math inline">\(\texttt{append}\)</span> function on sequences is associative, with identity being the empty sequence.</p></li>
<li><p>The union operation on sets is associative, with the empty set as the identity.</p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Many functions are associative. 

\begin{itemize}
\item Addition and
multiplication on natural numbers are associative, with 0 and 1 as
their identities, respectively.  

\item Minimum and maximum are also
associative with identities $\infty$ and $-\infty$ respectively.
%


\item The $\cd{append}$ function on sequences is associative, with
identity being the empty sequence.


\item The union operation on sets is associative, with the empty set as the
identity.
%

\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomImportant}
\begin{dilFieldTitle}
Associativity of Floating Point Operations
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Associativity of Floating Point Operations
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR2:AT4
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR2:AT4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An important class of operations that are not associative is floating-point operations. These operations are typically not associative because performing a set of operations in different orders can lead to different results because of loss of precision.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An important class of operations that are not associative is
  floating-point operations.
%
These operations are typically not associative because performing a
set of operations in different orders can lead to different results
because of loss of precision.

\end{dilFieldBodyDex}
\end{dilAtomImportant}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
The <span class="math inline">\(\texttt{reduce}\)</span> operation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The $\cd{reduce}$ operation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR3:AT1:gr:seq::reduce
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In the sequence ADT, we use the function <span class="math inline">\(\texttt{reduce}\)</span> to perform a reduction over a sequence by applying an associative binary operation to the elements of the sequence until the result is reduced to a single value. The operation function has the type signature <span class="math display">\[\texttt{reduce}~(f: \alpha \times \alpha \rightarrow\alpha)~(id: \alpha)~(a: \mathbb{S}_{\alpha}) : \alpha\]</span> where <span class="math inline">\(f\)</span> is an associative function, <span class="math inline">\(a\)</span> is the sequence, and <span class="math inline">\(id\)</span> is the  <span style="color: black"><span><strong><em>left identity</em></strong></span></span> of <span class="math inline">\(f\)</span>, i.e., <span class="math inline">\(f(id,x) = x\)</span> for all <span class="math inline">\(x \in 
\alpha\)</span>.</p>
<p>When applied to an input sequence with a function <span class="math inline">\(f\)</span>, <span class="math inline">\(\texttt{reduce}\)</span> returns the “sum” with respect to <span class="math inline">\(f\)</span> of the input sequence. In fact if <span class="math inline">\(f\)</span> is associative this sum in equal to iteration. We can define the behavior of <span class="math inline">\(\texttt{reduce}\)</span> inductively as follows <span class="math display">\[\texttt{reduce}~f~id~a 
=  
\left\{ 
\begin{array}{ll} 
id &amp; \mbox{if}~\lvert a \rvert= 0 
\\ 
a[0] &amp; \mbox{if}~\lvert a \rvert= 1 
\\[2ex] 
f\left(\texttt{reduce}~f~id~(a[0 \cdots \lfloor \frac{\lvert a \rvert}{2} 
    \rfloor - 1]), 
\right. 
\\ 
~~~~\left.\texttt{reduce}~f~id~(a[\lfloor \frac{\lvert a \rvert}{2} \rfloor \cdots \lvert a \rvert-1]\right) &amp; \mbox{otherwise.} 
\end{array} 
\right.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In the sequence ADT, we use the function $\cd{reduce}$ to perform a
reduction over a sequence by applying an associative binary operation
to the elements of the sequence until the result is reduced to a
single value.
%
The operation function has the type signature
\[
\cd{reduce}~(f: \alpha \times \alpha \ra \alpha)~(id: \alpha)~(a: \sseq{\alpha}) : \alpha
\]
where $f$ is an associative function, $a$ is the sequence, and $id$ is
the~\defn{left identity} of $f$, i.e., $f(id,x) = x$ for all $x \in
\alpha$.
%

When applied to an input sequence with a function $f$, $\cd{reduce}$
returns the ``sum'' with respect to~$f$ of the input sequence.  In
fact if~$f$ is associative this sum in equal to iteration.
%
We can define the behavior of $\cd{reduce}$ inductively as follows
%
\[
\cd{reduce}~f~id~a
= 
\left\{
\begin{array}{ll}
id & \mbox{if}~\cseqlen{a}= 0
\\
a[0] & \mbox{if}~\cseqlen{a}= 1
\\[2ex]
f\left(\cd{reduce}~f~id~(a\cirange{0}{\lfloor \frac{\cseqlen{a}}{2}
    \rfloor - 1}),
\right.
\\
~~~~\left.\cd{reduce}~f~id~(a\cirange{\lfloor \frac{\cseqlen{a}}{2} \rfloor}{\cseqlen{a}-1}\right) & \mbox{otherwise.}
\end{array}
\right.
\]

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomImportant}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{reduce}\)</span> is more restrictive than <span class="math inline">\(\texttt{iterate}\)</span> because it is the same function but with extra restrictions on its input (i.e. that <span class="math inline">\(f\)</span> be associative, and <span class="math inline">\(id\)</span> is a left identity). If the function <span class="math inline">\(f\)</span> is associative, then we have <span class="math display">\[\texttt{reduce}~f~id~a = \texttt{iterate}~f~id~a.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{reduce}$ is more restrictive than $\cd{iterate}$ because
it is the same function but with extra restrictions on its input
(i.e. that~$f$ be associative, and $id$ is a left identity).
%
If the function $f$ is associative, then we have
\[
\cd{reduce}~f~id~a = \cd{iterate}~f~id~a.
\]

\end{dilFieldBodyDex}
\end{dilAtomImportant}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Reduce and append
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Reduce and append
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
atom:15210:S18:CH8:SEC1:UN4:GR3:AT1:gr:seq::reduce
\end{dilParents}
\begin{dilFieldBody}
<p>The expression <span class="math display">\[\texttt{reduce}~\texttt{append}~\left\langle\,  \,\right\rangle~\left\langle\, \text{&#39;}\,{\texttt{another}}\,\text{&#39;},\text{&#39;}\,{\texttt{way}}\,\text{&#39;},\text{&#39;}\,{\texttt{to}}\,\text{&#39;},\text{&#39;}\,{\texttt{flatten}}\,\text{&#39;} \,\right\rangle\]</span> evaluates to<br />
<span class="math display">\[\text{&#39;}\,{\texttt{anotherwaytoflatten}}\,\text{&#39;}.\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The expression 
\[
\cd{reduce}~\cd{append}~\cseq{}~\cseq{\cstr{another},\cstr{way},\cstr{to},\cstr{flatten}}
\] 
evaluates to
\\
\[
\cstr{anotherwaytoflatten}.
\]

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Give an example function <span class="math inline">\(f\)</span>, a left identity <span class="math inline">\(x\)</span>, and an input sequence <span class="math inline">\(a\)</span> such that <span class="math inline">\(\texttt{iterate}~f~x~a\)</span> and <span class="math inline">\(\texttt{reduce}~f~x~a\)</span> return different results.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Give an example function $f$, a left identity $x$, and an input
sequence $a$ such that
$\cd{iterate}~f~x~a$ and $\cd{reduce}~f~x~a$ return different results.

\end{dilFieldBodyDex}
\end{dilAtomExercise}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomImportant}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Although we will use <span class="math inline">\(\texttt{reduce}\)</span> only with associative functions, we define it for all well-typed functions. To deal properly with functions that are non-associative, the specification of <span class="math inline">\(\texttt{reduce}\)</span> makes precise the order in which the argument function <span class="math inline">\(\texttt{f}\)</span> is applied. For instance, when reducing with floating point addition or multiplication, we will need to take the order of operations into account. Because the specification defines the order in which the operations are applied, every (correct) implementation of <span class="math inline">\(\texttt{reduce}\)</span> must return the same result: the result is deterministic regardless of the specifics of the algorithm used in the implementation.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Although we will use $\cd{reduce}$ only with associative functions, we
define it for all well-typed functions.
%
To deal properly with functions that are non-associative, the
specification of $\cd{reduce}$ makes precise the order in which the
argument function~$\cd{f}$ is applied.
%
For instance, when reducing with floating point addition or
multiplication, we will need to take the order of operations into
account.
%
Because the specification defines the order in which the operations
are applied, every (correct) implementation of $\cd{reduce}$ must
return the same result: the result is deterministic regardless of the
specifics of the algorithm used in the implementation.

\end{dilFieldBodyDex}
\end{dilAtomImportant}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN4:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Given that <span class="math inline">\(\texttt{reduce}\)</span> and <span class="math inline">\(\texttt{iterate}\)</span> are equivalent for assocative functions, why would we use <span class="math inline">\(\texttt{reduce}\)</span>?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given that $\cd{reduce}$ and $\cd{iterate}$ are equivalent for
assocative functions, why would we use $\cd{reduce}$?

\end{dilFieldBodyDex}
\end{dilAtomExercise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomSolution}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN4:GR8:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN4:GR8:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Even though the input-output behavior of <span class="math inline">\(\texttt{reduce}\)</span> and <span class="math inline">\(\texttt{iterate}\)</span> may match, their cost specifications differ: unlike <span class="math inline">\(\texttt{iterate}\)</span>, which is strictly sequential, <span class="math inline">\(\texttt{reduce}\)</span> is parallel. In fact, as we will see later, the span of <span class="math inline">\(\texttt{iterate}\)</span> is linear in the size of the input, whereas the span of <span class="math inline">\(\texttt{reduce}\)</span> is logarithmic.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Even though the input-output behavior of $\cd{reduce}$ and $\cd{iterate}$
may match, their cost specifications differ: unlike $\cd{iterate}$,
which is strictly sequential, $\cd{reduce}$ is parallel. 
%
In fact, as we will see later,
% in Section~\ref{sec:seq::cost} , 
the span of $\cd{iterate}$ is linear in the size of the input, whereas
the span of $\cd{reduce}$ is logarithmic.

\end{dilFieldBodyDex}
\end{dilAtomSolution}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Aggregation with Scan
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Aggregation with Scan
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH8:SEC1:UN5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
The <span class="math inline">\(\texttt{scan}\)</span> operation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The $\cd{scan}$ operation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR1:AT1:gr:seq::scan-intro
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>When we restrict ourselves to associative functions, the input-output behavior of the function <span class="math inline">\(\texttt{reduce}\)</span> can be defined in terms of the <span class="math inline">\(\texttt{iterate}\)</span>. But the reverse is not true: <span class="math inline">\(\texttt{iterate}\)</span> cannot always be defined in terms of <span class="math inline">\(\texttt{reduce}\)</span>, because <span class="math inline">\(\texttt{iterate}\)</span> can use the results of intermediate states computed on the prefixes of the sequence, whereas <span class="math inline">\(\texttt{reduce}\)</span> cannot because such intermediate states are not available. For example, in our parenthesis matching algorithm we used this property by defining our function to propagate</p>
<p>a mismatched parenthesis forward in the computation. We now describe a function called <span class="math inline">\(\texttt{scan}\)</span> that allows using the results of intermediate computations and also does so in parallel.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
When we restrict ourselves to associative functions, the input-output
behavior of the function $\cd{reduce}$ can be defined in terms of the
$\cd{iterate}$. 
%
But the reverse is not true: $\cd{iterate}$ cannot always be defined
in terms of $\cd{reduce}$, because $\cd{iterate}$ can use the results
of intermediate states computed on the prefixes of the sequence,
whereas $\cd{reduce}$ cannot because such intermediate states are not
available.  
%
For example, in our parenthesis matching algorithm
%(Algorithm~\ref{atom:15210:S18:CH8:SEC1:UN3:GR10:AT1:alg:seq::iterate::pmatch}),
we used this property by defining our function to propagate

a mismatched parenthesis forward in the computation.
%
We now describe a function called $\cd{scan}$ that
allows using the results of intermediate computations and also does so
in parallel.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
Operations in scan and iteration
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Operations in scan and iteration
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Note that scan still requires the function to be a binary operation returning the same type as its argument, whereas iteration does not. For example, the function for computing parenthesis matching does not work as a scan operator.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Note that scan still requires the function to be a binary operation
returning the same type as its argument, whereas iteration does not.
For example, the function for computing parenthesis matching does not
work as a scan operator.

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
The function <span class="math inline">\(\texttt{scan}\)</span>
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The function $\cd{scan}$
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR3:AT1:gr:seq::scan-intro
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The term “scan” refers to a computation that reduces every prefix of a given sequence by repeatedly applying an associative binary operation. The <span class="math inline">\(\texttt{scan}\)</span> function has the type signature <span class="math display">\[\texttt{scan}~(f: \alpha * \alpha \rightarrow\alpha)~(id: \alpha)~(a: \mathbb{S}_{\alpha})~:~(\mathbb{S}_{\alpha} * \alpha),\]</span> where <span class="math inline">\(f\)</span> is an associative function, <span class="math inline">\(a\)</span> is the sequence, and <span class="math inline">\(id\)</span> is the left identity element of <span class="math inline">\(f\)</span>. The expression <span class="math inline">\(\texttt{scan}~f~a\)</span> returns the “sum” with respect to <span class="math inline">\(f\)</span> of all prefixes of the input sequence <span class="math inline">\(a\)</span>. For this reason, the <span class="math inline">\(\texttt{scan}\)</span> operation is sometimes called the  <span style="color: black"><span><strong><em>prefix sums</em></strong></span></span> operation.</p>
<p>We define the semantics of <span class="math inline">\(\texttt{scan}\)</span> in terms of <span class="math inline">\(\texttt{reduce}\)</span> as follows. <span class="math display">\[\begin{alignat}{2} 
\texttt{scan}~f~id~a 
&amp; ~=~ &amp; 
(&amp;\left\langle\, \texttt{reduce}~f~id~a[0 \cdots (i-1)] : 0 \le i &lt; \lvert a \rvert \,\right\rangle, 
\\ 
&amp; &amp; &amp;~\texttt{reduce}~f~id~a) 
\end{alignat}\]</span></p>
<p>For the definition, we assume that <span class="math inline">\(a[0 \cdots -1] = \left\langle\,  \,\right\rangle\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The term ``scan'' refers to a computation that reduces every prefix of
a given sequence by repeatedly applying an associative binary
operation.  
%
The $\cd{scan}$ function has the type signature
\[
\cd{scan}~(f: \alpha * \alpha \ra \alpha)~(id: \alpha)~(a: \sseq{\alpha})~:~(\sseq{\alpha} * \alpha),
\]
where $f$ is an associative function, $a$ is the sequence, and $id$ is
the left identity element of $f$.
%
The expression $\cd{scan}~f~a$ returns the ``sum'' with respect
to~$f$ of all prefixes of the input sequence~$a$.
%
For this reason, the $\cd{scan}$ operation is sometimes called the~\defn{prefix sums} operation.
%


We define the semantics of $\cd{scan}$ in terms of $\cd{reduce}$ as follows.
\[
\begin{alignat}{2}
\cd{scan}~f~id~a
& ~=~ &
(&\cseq{\cd{reduce}~f~id~a\cirange{0}{(i-1)} : 0 \le i < \cseqlen{a}},
\\
& & &~\cd{reduce}~f~id~a)
\end{alignat}
\]

For the definition, we assume that $a\cirange{0}{-1} = \cseq{}$.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Inclusive Scan
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Inclusive Scan
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>When computing the result for position <span class="math inline">\(i\)</span>, <span class="math inline">\(\texttt{scan}\)</span> does not include the element of the input sequence at that position. It is sometimes useful to do so. To this end, we define <span class="math inline">\(\texttt{scanI}\)</span> (“I” stands for “inclusive”).</p>
<p>We define the semantics of <span class="math inline">\(\texttt{scanI}\)</span> in terms of <span class="math inline">\(\texttt{reduce}\)</span> as follows. <span class="math display">\[\begin{alignat}{1} 
\texttt{scanI}~f~id~a 
&amp; ~=~  
\left\langle\, \texttt{reduce}~f~id~a[0 \cdots i] : 0 \le i &lt; \lvert a \rvert \,\right\rangle 
\\ 
\end{alignat}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
When computing the result for position~$i$, $\cd{scan}$ does not
include the element of the input sequence at that position.  It is
sometimes useful to do so.  To this end, we define $\cd{scanI}$ (``I''
stands for ``inclusive'').

We define the semantics of $\cd{scanI}$ in terms of $\cd{reduce}$ as follows.
\[
\begin{alignat}{1}
\cd{scanI}~f~id~a
& ~=~ 
\cseq{\cd{reduce}~f~id~a\cirange{0}{i} : 0 \le i < \cseqlen{a}}
\\
\end{alignat}
\]

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Scan
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Scan
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
gr:seq::scan
\end{dilParents}
\begin{dilFieldBody}
<p>Consider the sequence <span class="math inline">\(a = \left\langle\, 0,1,2 \,\right\rangle\)</span>. The prefixes of <span class="math inline">\(a\)</span> are</p>
<ul>
<li><p><span class="math inline">\(\left\langle\,  \,\right\rangle\)</span></p></li>
<li><p><span class="math inline">\(\left\langle\, 0 \,\right\rangle\)</span></p></li>
<li><p><span class="math inline">\(\left\langle\, 0,1 \,\right\rangle\)</span></p></li>
<li><p><span class="math inline">\(\left\langle\, 0,1,2 \,\right\rangle.\)</span></p></li>
</ul>
<p>The prefixes of a sequence are all the subsequences of the sequence that starts at its beginning. Empty sequence is a prefix of any sequence. The computation <span class="math inline">\(\texttt{scan}~\texttt{+}~0~\left\langle\, 0,1,2 \,\right\rangle\)</span> can be written as <span class="math display">\[\begin{alignat}{2} 
\texttt{scan}~\texttt{+}~0~\left\langle\, 0,1,2 \,\right\rangle 
&amp; = 
&amp;  
\left( \right.  
&amp; \left\langle\right.~\texttt{reduce}~\texttt{+}~0~\left\langle\,  \,\right\rangle,  
\\ 
&amp; &amp; &amp; ~~\texttt{reduce}~\texttt{+}~0~\left\langle\, 0 \,\right\rangle,  
\\ 
&amp; &amp; &amp; ~~\texttt{reduce}~\texttt{+}~0~\left\langle\, 0, 1 \,\right\rangle  
\\  
&amp; &amp; &amp; \left.\right\rangle~,  
\\ 
&amp; &amp; &amp; \texttt{reduce}~\texttt{+}~0~\left\langle\, 0, 1, 2 \,\right\rangle  
\\ 
&amp;  &amp; \left.\right) &amp; 
\\ 
&amp; = &amp; \left(\right. &amp; \left\langle\, 0, 0, 1 \,\right\rangle, 3 \left.\right). 
\end{alignat}\]</span></p>
<p>The computation <span class="math inline">\(\texttt{scanI}~\texttt{+}~0~\left\langle\, 0,1,2 \,\right\rangle\)</span> can be written as <span class="math display">\[\begin{alignat}{2} 
\texttt{scanI}~\texttt{+}~0~\left\langle\, 0,1,2 \,\right\rangle 
&amp; ~=~ &amp;  
\left\langle\right.~&amp;~ \texttt{reduce}~\texttt{+}~0~\left\langle\, 0 \,\right\rangle,  
\\ 
&amp; &amp; ~&amp;~ \texttt{reduce}~\texttt{+}~0~\left\langle\, 0, 1 \,\right\rangle,  
\\ 
&amp; &amp; ~&amp;~ \texttt{reduce}~\texttt{+}~0~\left\langle\, 0, 1, 2, \,\right\rangle  
\\ 
&amp; &amp; \left.\right\rangle
\\ 
&amp; ~=~ &amp; &amp; \!\!\!\left\langle\, 0, 1, 3 \,\right\rangle. 
\end{alignat}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider the sequence $a = \cseq{0,1,2}$.
%
The prefixes of $a$ are  
\begin{itemize}
\item $\cseq{}$
\item $\cseq{0}$
\item $\cseq{0,1}$
\item $\cseq{0,1,2}.$
\end{itemize}
%
The prefixes of a sequence are all the subsequences of the sequence
that starts at its beginning. Empty sequence is a prefix of any
sequence.
%
The computation $\cd{scan}~\cd{+}~0~\cseq{0,1,2}$ can be written as
%
\[
\begin{alignat}{2}
\cd{scan}~\cd{+}~0~\cseq{0,1,2}
& =
& 
\left( \right. 
& \cseqb ~\cd{reduce}~\cd{+}~0~\cseq{}, 
\\
& & & ~~\cd{reduce}~\cd{+}~0~\cseq{0}, 
\\
& & & ~~\cd{reduce}~\cd{+}~0~\cseq{0, 1} 
\\ 
& & & \cseqe~, 
\\
& & & \cd{reduce}~\cd{+}~0~\cseq{0, 1, 2} 
\\
&  & \left.\right) &
\\
& = & \left(\right. & \cseq{0, 0, 1}, 3 \left.\right).
\end{alignat}
\]


%
The computation $\cd{scanI}~\cd{+}~0~\cseq{0,1,2}$ can be written as
\[
\begin{alignat}{2}
\cd{scanI}~\cd{+}~0~\cseq{0,1,2}
& ~=~ & 
\cseqb ~&~ \cd{reduce}~\cd{+}~0~\cseq{0}, 
\\
& & ~&~ \cd{reduce}~\cd{+}~0~\cseq{0, 1}, 
\\
& & ~&~ \cd{reduce}~\cd{+}~0~\cseq{0, 1, 2,} 
\\
& & \cseqe 
\\
& ~=~ & & \!\!\!\cseq{0, 1, 3}.
\end{alignat}
\]

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Given that scan can be expressed just in terms of the operations that we have already seen, why do we need it?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Given that scan can be expressed just in terms of the operations that
we have already seen, why do we need it?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Scan versus reduce
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Scan versus reduce
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Since <span class="math inline">\(\texttt{scan}\)</span> can be specified in terms of reduce, one might be tempted to argue that it is redundant. In fact, it is not: as we shall see, performing <span class="math inline">\(\texttt{reduce}\)</span> repeatedly on every prefix is not work efficient. Remarkably <span class="math inline">\(\texttt{scan}\)</span> can be implemented by performing essentially the same work and span of <span class="math inline">\(\texttt{reduce}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Since $\cd{scan}$ can be specified in terms of reduce, one might be
tempted to argue that it is redundant.
%
In fact, it is not: as we shall see, performing $\cd{reduce}$ repeatedly
on every prefix is not work efficient.  
%
Remarkably $\cd{scan}$ can be implemented by performing essentially the
same work and span of $\cd{reduce}$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Copy scan
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Copy scan
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
gr:seq::scan
\end{dilParents}
\begin{dilFieldBody}
<p>Scan is useful when we want pass information along the sequence. For example, suppose you have some “marked” elements that you would like to copy across to their right until they reach another marked element. For example, suppose that we are given a sequence of type <span class="math inline">\(\mathbb{S}_{\mathbb{N}}\)</span> consisting only of natural numbers and asked to return a sequence of the same length where each element receives the previous positive value. For the example, for input <span class="math inline">\(\left\langle\, 0,~7,~0,~0,~3,~0 \,\right\rangle,\)</span> the result should be <span class="math inline">\(\left\langle\, 0,~0,~7,~7,~7,~3 \,\right\rangle\)</span>.</p>
<p>Using a sequential loop or <span class="math inline">\(\texttt{iterate}\)</span> would be easy. To solve this problem using <span class="math inline">\(\texttt{scan}\)</span> we need a combining function <span class="math inline">\(f\)</span>. Consider the function <span class="math display">\[\texttt{skipZero}~(x,y) = \texttt{if}~y &gt; 0~\texttt{then}~y~\texttt{else}~x.\]</span> The function returns its right (second) argument if it is positive, otherwise it returns its the left (first) argument.</p>
<p>To be used in a scan, <span class="math inline">\(\texttt{skipZero}\)</span> must be associative. In particular we need to show that for all <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>, we have <span class="math display">\[\texttt{skipZero}(x,\texttt{skipZero}(y,z)) = 
\texttt{skipZero}(\texttt{skipZero}(x,y),z).\]</span> There are eight possibilities corresponding to each of <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> being either positive or not. For the cases where <span class="math inline">\(z\)</span> is positive, it is easy to verify that either ordering returns <span class="math inline">\(z\)</span>. For the cases that <span class="math inline">\(z = 0\)</span> and <span class="math inline">\(y\)</span> is positive, it is likewise easy to verify that both orderings give <span class="math inline">\(y\)</span>. Finally, for the cases that both <span class="math inline">\(y = z = 0\)</span> and <span class="math inline">\(x\)</span> is positive they both return <span class="math inline">\(x\)</span>, and for all being zero, the ordering returns zero.</p>
<p>To use <span class="math inline">\(\texttt{skipZero}\)</span> as part of the scan operation, we need to find its left identity. We can see that for any natural number <span class="math inline">\(y\)</span> <span class="math display">\[\texttt{skipZero}~(0, y) =  y,\]</span> and that for any natural number <span class="math inline">\(x\)</span> <span class="math display">\[\texttt{skipZero}~(x, 0) = x.\]</span> Thus <span class="math inline">\(0\)</span> is the left identity for <span class="math inline">\(\texttt{skipZero}.\)</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Scan is useful when we want pass information along the
  sequence. For example, suppose you have some ``marked'' elements
  that you would like to copy across to their right until they reach
  another marked element.
%
For example, suppose that we are given a sequence of type $\sseq{\tynat}$
consisting only of natural numbers and asked to return a sequence
of the same length where each element receives the previous positive
value.  For the example, for input $\cseq{0,~7,~0,~0,~3,~0},$ the
result should be $\cseq{0,~0,~7,~7,~7,~3}$.

Using a sequential loop or $\cd{iterate}$ would be easy.  To solve
this problem using $\cd{scan}$ we need a combining function $f$.  
%
Consider the function
%
\[
\cd{skipZero}~(x,y) = \cd{if}~y > 0~\cd{then}~y~\cd{else}~x.
\]
%
%
The function returns its right (second) argument if it is positive,
otherwise it returns its the left (first) argument.
%

To be used in a scan, $\cd{skipZero}$ must be associative.  In
particular we need to show that for all $x$, $y$ and $z$, we have
\[
\cd{skipZero}(x,\cd{skipZero}(y,z)) =
\cd{skipZero}(\cd{skipZero}(x,y),z).
\]
%
There are eight possibilities corresponding to each of $x$, $y$ and
$z$ being either positive or not.  
%
For the cases where $z$ is
positive, it is easy to verify that either ordering returns $z$.
%
For the cases that $z = 0$ and $y$ is positive, it is likewise easy to
verify that both orderings give $y$.
%
Finally, for the cases that both $y = z = 0$ and $x$ is positive they
both return $x$, and for all being zero, the ordering returns zero.

To use $\cd{skipZero}$ as part of the scan operation, we need to find
its left identity.  We can see that for any natural number $y$
\[
\cd{skipZero}~(0, y) =  y, 
\]
and that for any natural number $x$
\[
\cd{skipZero}~(x, 0) = x.
\]
%
Thus $0$ is the left identity for $\cd{skipZero}.$

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH8:SEC1:UN5:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}
Reduce and scan
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Reduce and scan
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH8:SEC1:UN5:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH8:SEC1:UN5:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Experience in parallel computing shows that <span class="math inline">\(\texttt{reduce}\)</span> and <span class="math inline">\(\texttt{scan}\)</span> are powerful primitives that suffice to express many parallel algorithms on sequences. In some ways this is not surprising, because the operations allow using two important algorithm-design techniques: <span class="math inline">\(\texttt{reduce}\)</span> operation allows expressing divide-and-conquer algorithms and the <span class="math inline">\(\texttt{scan}\)</span> operation allows expressing an iterative algorithms.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Experience in parallel computing shows that $\cd{reduce}$ and $\cd{scan}$
are powerful primitives that suffice to express many parallel
algorithms on sequences. 
%
In some ways this is not surprising, because the operations allow
using two important algorithm-design techniques: $\cd{reduce}$ operation
allows expressing divide-and-conquer algorithms and
%
the $\cd{scan}$ operation allows expressing an iterative algorithms.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
\end{dilChapter}
\end{dilBook}
\end{dilCourse}
