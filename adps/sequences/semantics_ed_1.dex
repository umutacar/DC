%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{course}
\title{Parallel and Sequential Algorithms}
\label{15210}
\no{15210}
\unique{15210}
\parent{...NO.PARENTS...}

\coursenumber{15210}
\picture{/210/course/air-pavilion.jpg}
\providesbook{S18}
\provideschapter{8}
\providessection{1}
\providesunit{1}
\providesassignment{1}
\semester{Spring 2018}
\website{http://www.cs.cmu.edu/~15210}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking â€” i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues. Concepts
covered in this class include:
\begin{book}
\title{Algorithm Design: Parallel and Sequential}
\label{book:15210:S18}
\no{0}
\unique{15210:S18}
\parent{...NO.PARENTS...}
\authors{Umut A. Acar and Guy Blelloch}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{chapter}[Sequences]
\label{chapter:15210:S18:CH8:ch:sequences}
\no{8}
\unique{15210:S18:CH8}
\parent{...NO.PARENTS...}

\picture{/210/sequences/water-town-suzhou-embroidery.jpg}



A sequence is an ordered set, i.e., is a collection of elements that
are totally ordered. 
%
Computer scientists use sequence data grams such as arrays and
lists to represent many different sorts of data.
%


This chapter defines the syntax and the semantics of sequences and
presents cost specifications and implementation strategies for
matching them.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{section}[Semantics]
\label{section:15210:S18:CH8:SEC1:sec:sequences}
\no{1}
\unique{15210:S18:CH8:SEC1}
\parent{...NO.PARENTS...}

Thi section specifies the syntax and the semantics for a
sequence abstract data type.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{unit}[Defining Sequences]
\label{unit:15210:S18:CH8:SEC1:UN1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN1:GR1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1:GR1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN1:GR1:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1:GR1:AT1}
\parent{...NO.PARENTS...}

Mathematically, a sequence is an enumerated collection.  As with a
set, a sequence has~\defn{elements}.  The~\defn{length} of the
sequence is the number of elements in the sequence.  A sequence can be
finite or infinite; we only consider finite ones.
%

Sequences allow for repetition: an element can appear at multiple
positions.
%
The position of an element is called its~\defn{rank} or its~\defn{index}.
%
Traditionally, the first element of the sequence is given rank $1$,
but, being computer scientists, we start at $0$.
% 
Mathematically, we can define a sequence as a function whose domain is
a contiguous set of natural numbers starting at zero.
%
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN1:GR2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN1:GR2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Sequences]
\label{atom:15210:S18:CH8:SEC1:UN1:GR2:AT1:def:seq::sequences}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1:GR2:AT1}
\parent{...NO.PARENTS...}

An~\defn{$\alpha$ sequence} is a mapping (function) from $\nats$ to
$\alpha$ with domain $\cset{0, \ldots, n-1}$ for some $n \in \nats$.
%
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN1:GR2:AT2:ex:seq::sequencesdef}
\no{2}
\unique{15210:S18:CH8:SEC1:UN1:GR2:AT2}
\parent{def:seq::bayesian-inference}

Let $A = \cset{0,1,2,3}$ and $B = \cset{\cstr{a},\cstr{b},\cstr{c}}$.
The relation
\[R = \cset{(0,\cstr{a}),(1,\cstr{b}),(3,\cstr{a})}\]
is a function from $A$ to $B$ with domain $\{0,1,3\}$ since each
element only appears once on the left. It is, however, not a sequence
since there is a gap in the domain.

The relation
\[Z = \{(1,\cstr{b}), (3,\cstr{a}), (2,\cstr{a}), (0,\cstr{a})\}\]
from~$A$ to $B$ is a sequence.
%
The first element of the sequence is $\cstr{a}$ and thus has rank $0$.
The second element is $\cstr{b}$ and has rank $1$.  
%
The length of the sequence is $4$.
%
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN1:GR3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN1:GR3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{note}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN1:GR3:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1:GR3:AT1}
\parent{...NO.PARENTS...}

This mathematical definition might seem pedantic but it is useful for
at least a couple reasons: it allows for a concise but yet precise
definition of the semantics of the functions on sequences, and we will
see, relating sequences to mappings creates a symmetry with the
abstract data types such as tables or dictionaries for representing
mappings.
%
An important point to notice in the definition is that sequences are
parametrized by the type (i.e., set of possible values) of their
elements.
\end{note}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN1:GR4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN1:GR4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{syntax}[Sequences and Indexing]
\label{atom:15210:S18:CH8:SEC1:UN1:GR4:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN1:GR4:AT1}
\parent{...NO.PARENTS...}

As in mathematics, we use a special notation for writing sequences.
%
The notation
%
$\cseq{a_0,a_1,\ldots,a_{n-1}}$
%
is shorthand for the sequence
$\cset{(0,a_0),(1,a_1),\ldots,((n-1),a_{n-1})}$.
%

For a sequence $a$
\begin{itemize}
\item  $a[i]$ refers to the element of $a$ at
position $i$,

\item $a\cirange{l}{h}$ refers to the subsequence of $a$ restricted to
  the position between $l$ and $h$.
\end{itemize}

Since they occur frequently, we use special notation and terminology
for sequences with two elements and sequences of characters.
%
\begin{itemize}
\item
An~\defn{ordered pair $(x,y)$} is a pair of elements in which the
element on the left, $x$, is identified as the~\defn{first} entry, and
the one on the right, $y$, as the~\defn{second} entry.
\item
We refer to a sequence of characters as a~\defn{string}, and use the
standard syntax for them, e.g., $\mstr{c_0c_1c_2 \ldots c_{n-1}}$ is a
string consisting of the $n$ characters $c_0, \ldots, c_{n-1}$.
\end{itemize}
\end{syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Example sequences]
\label{atom:15210:S18:CH8:SEC1:UN1:GR4:AT2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN1:GR4:AT2}
\parent{...NO.PARENTS...}

Some example sequences follow.


\begin{itemize}
\item For the sequence $a =  \cseq{2,3,5,7,11,13,17,19,23,29}$, we have


\begin{itemize}

\item $a[0] = 2$, 
\item $a[2] = 5$, and 
\item
$a\cirange{1}{4} = \cseq{3,5,7,11}$.
\end{itemize}
%
\item 
A character sequence, or a string:
$\cseq{\chr{s},\chr{e},\chr{q}} \equiv \str{seq}~.$
%
\item

An integer-and-string sequence:
$\cseq{(10,\str{ten}),(1,\str{one}),(2,\str{two})}.$
%
\item 
A string-and-string-sequence sequence: $\cseq{\cseq{\str{a}},\cseq{\str{nested}, \str{sequence}}}.$
%
\item
A $\tyint \rightarrow \tyint$ function sequence:
\[
\begin{array}{ll}
\cseqb & \cfn{x}{x^2},
\\
& \cfn{y}{y+2},
\\
& \cfn{x}{x-4}
\\
\cseqe.
\end{array}
\]
\end{itemize}
\end{example}
\end{group}
\end{unit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{unit}[The Sequence Abstract Data Type]
\label{unit:15210:S18:CH8:SEC1:UN2:sec:seq::adt}
\no{2}
\unique{15210:S18:CH8:SEC1:UN2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN2:GR1:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR1:AT1}
\parent{...NO.PARENTS...}

Sequences are one of the most prevalent ADT's used in this book, and
more generally in computing.  
%
In this section, we present the interface of an abstract data type for
sequences, describe the semantics of the operations in the interface,
and define a notation for sequences, called~\defn{sequence
  comprehensions}.
%
Throughout, we use $e$ and its variants to for \PML expression.
%
When specifying the semantics of operation, we rely on the
mathematical definition of a sequence as a partial function whose
domain is natural numbers.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN2:GR2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN2:GR2:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR2:AT1}
\parent{...NO.PARENTS...}

The sequence ADT, shown below, can be broadly divided into several
categories.
\begin{itemize}
\item 
Operations such as  $\cd{nth}$ and  $\cd{length}$  that return an
element of the sequence or a particular property of it.
%
\item Constructors such as $\cd{empty}$, $\cd{singleton}$, and $\cd{tabulate}$ that create
sequences.
%
\item 
Operations such as $\cd{map}$, $\cd{filter}$ that operate on each
element of a sequence independently in parallel.
%
\item 
Operations such as $\cd{append}$ and $\cd{flatten}$ that operate on
sequences as a whole.
%
\item 
Operations such as $\cd{update}$ and $\cd{inject}$ that updates the
elements of a sequence.
%
\item 
Operations such as $\cd{iterate}$, $\cd{reduce}$, and $\cd{scan}$ that~\defn{aggregate} information over the elements of the sequence.
\end{itemize}
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN2:GR3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{datatype}[Sequences]
\label{atom:15210:S18:CH8:SEC1:UN2:GR3:AT1:adt:seq::sequences}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR3:AT1}
\parent{...NO.PARENTS...}

For a value type $\alpha$, the~\defn{sequence data type} is the type
$\sseq{\alpha}$ consisting of the set of all $\alpha$ sequences, and
the following values and functions on $\sseq{\alpha}$.
%
In the specifiction, we define booleans as $\tybool = \{\ctrue{},
\cfalse{}\}$ and orders as $\mathcal{O} = \{\cd{less}, \cd{greater},
\cd{equal}\}$.
%
\[
\begin{array}{lcl}
\cd{length}
& : &
\sseq{\alpha} \rightarrow \tynat
\\
\cd{nth}
& : & 
\sseq{\alpha} \rightarrow \tynat \rightarrow \alpha 
\\
\cd{empty}
& : & 
\sseq{\alpha} 
\\
\cd{singleton}
& : & 
\alpha \rightarrow \sseq{\alpha}
\\
\cd{tabulate}
& : & (\tynat \rightarrow \alpha) \rightarrow \tynat \rightarrow \sseq{\alpha}
\\
\cd{map}
& : & (\alpha \rightarrow \beta) \rightarrow \sseq{\alpha} \rightarrow \sseq{\beta}
\\
\cd{subseq}
& : & 
\sseq{\alpha} \rightarrow \tynat \rightarrow \tynat \rightarrow \sseq{\alpha}
\\
\cd{append}
& : & 
\sseq{\alpha} \rightarrow \sseq{\alpha} \rightarrow \sseq{\alpha}
\\
\cd{filter}
& : & (\alpha \rightarrow \tybool) \rightarrow \sseq{\alpha} \rightarrow \sseq{\alpha}
\\
\cd{flatten}
& : & \sseq{\sseq{\alpha}} \rightarrow \sseq{\alpha}
\\
\cd{update}
& : &  \sseq{\alpha} \rightarrow (\tynat \times \alpha) \rightarrow \sseq{\alpha}
\\
\cd{inject}
& : &  \sseq{\alpha} \rightarrow \sseq{\tynat \times \alpha} \rightarrow \sseq{\alpha}
\\
\cd{isEmpty}
& : & \sseq{\alpha} \rightarrow \tybool
\\
\cd{isSingleton}
& : & \sseq{\alpha} \rightarrow \tybool
\\
\cd{iterate}
& : &  
(\alpha \times \beta \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\beta}
\rightarrow
\alpha
\\
\cd{reduce}
& : &  
(\alpha \times \alpha \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\alpha}
\rightarrow
\alpha
\\
\cd{scan}
& : &  
(\alpha \times \alpha \rightarrow \alpha)
\rightarrow
\alpha
\rightarrow
\sseq{\alpha}
\rightarrow
(\sseq{\alpha} \times \alpha)
\\
\cd{collect}
& : &  
(\alpha \times \alpha \rightarrow \mathcal{O})
\rightarrow
\sseq{\alpha \times \beta}
\rightarrow
\sseq{\alpha \times \sseq{\beta}}
\end{array}
\]
\end{datatype}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN2:GR4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN2:GR4:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR4:AT1}
\parent{...NO.PARENTS...}

Inspired by mathematical notation for sequences, we use a
``sequence comprehensions'' notation, which we  define below.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR5}
\no{5}
\unique{15210:S18:CH8:SEC1:UN2:GR5}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{syntax}[Syntax for Sequences]
\label{atom:15210:S18:CH8:SEC1:UN2:GR5:AT1:syn:seq::seq}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR5:AT1}
\parent{...NO.PARENTS...}

The table below defines the syntax for the sequence ADT.
%
In the definition
%
$i$~is a variable ranging over natural numbers,
%
$x$~is a variable ranging over the elements of a sequence,
%
~$e$~is a \PML expression, 
%
$e_n$ and $e_n'$ are \PML expressions whose values are natural numbers, 
%
$e_s$~is a \PML expression whose value is a sequence, 
%
$p$ is a \PML pattern that binds one or more variables.

\medskip

\begin{tabular}{lcl}
$|e_s|$ & $\equiv$ & $\cd{length}$ $e_s$
\\
$e_s[i]$ & $\equiv$ & $\cd{nth}$ $e_s$
\\
$\cseq{}$ & $\equiv$ & $\cd{empty}$
\\
$\cseq{e}$ & $\equiv$ & $\cd{singleton}$ $e$
\\
 $\cseq{e : 0 \leq i < e_n}$  & $\equiv$ & $\cd{tabulate}$ $(\cfn{i}{e})$ ${e_n}$
\\
$\cseq{e : p \in e_s}$ & $\equiv$ & $\cd{map}$ $(\cfn{p}{e})$ $e_s$
\\

$\cseqf{x \in e_s}{e}$ & $\equiv$ & $\cd{filter}$ $(\cfn{x}{e})$ $e_s$

\\
$e_s[e_l,\cdots,e_n']$ & $\equiv$ & $\cd{subseq}$ $(e_s, e_l, e_n'-e_l+1)$
\\
%
$\kwappend{e_s}{e_s'}$ & $\equiv$ & $\cd{append}~e_s~e_s'$
\end{tabular}
\end{syntax}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR6}
\no{6}
\unique{15210:S18:CH8:SEC1:UN2:GR6}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Length and indexing]
\label{atom:15210:S18:CH8:SEC1:UN2:GR6:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR6:AT1}
\parent{...NO.PARENTS...}

Given a sequence $a$, $\cd{length}~a$, also written $\cseqlen{a}$,
returns the length of $a$.
%
The function $\cd{nth}$ returns the element of a sequence at a specified
index, e.g. $\cd{nth}~a~2$, written $a[2]$, returns the element of $a$
with rank $2$.
%
If the element demanded is out of range, the behavior is undefined and
leads to an error.
%
% if for example the index is
% less than $0$ or greater than the rank of the last element, then the
% function returns the special value $\bot$ (bottom), which indicates an
% error or an exception.
%
%% More precisely, we can specify the function \cd{nth} as follows
%% \begin{code}
%% \[
%% \cd{nth}~a~i =
%% \left\{
%% \begin{array}{lc}
%% a[i] & 0 \le i < \cseqlen{a} 
%% \\
%% \bot & \mbox{otherwise.}
%% \end{array} \right.
%% %% 
%% \]
%% \medskip
%% \end{code}
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR7}
\no{7}
\unique{15210:S18:CH8:SEC1:UN2:GR7}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Empty and singleton]
\label{atom:15210:S18:CH8:SEC1:UN2:GR7:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR7:AT1}
\parent{...NO.PARENTS...}

The value $\cd{empty}$ is the empty sequence, $\cseq{}$.  The function
$\cd{singleton}$ takes an element and returns a sequence containing that
element, e.g., $\cd{singleton}~1$ evaluates to $\cseq{1}$.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR8}
\no{8}
\unique{15210:S18:CH8:SEC1:UN2:GR8}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Tabulate]
\label{atom:15210:S18:CH8:SEC1:UN2:GR8:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR8:AT1}
\parent{...NO.PARENTS...}

The function $\cd{tabulate}$ takes a function $f$ and an natural number
$n$ and produces a sequence of length $n$ by applying $f$ at each
position.
%
The function $f$ can be applied to each element in parallel.
%
We specify $\cd{tabulate}$ as follows
%
\[
\begin{alignat}{1}
\cd{tabulate}&~(f: \tynat \rightarrow \alpha)~(n: \tynat) : \sseq{\alpha}
\\
&= \cseq{f(0), f(1), \ldots, f(n-1)}.
\end{alignat}
\]
%
We use the following syntax for $\cd{tabulate}$ operation
%
\[
\equivs
{\cseq{e : 0 \leq i < e_n}}
{\cd{tabulate}~(\cfn{i}{e})~{e_n},}
\]
%
where $e$ and $e_n$ are expressions, the second evaluating
to an integer,  and $i$ is a variable.
%
More generally, we can also start at any other, as in:
\[\cseq{e : e_j \leq i < e_n}. \]
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR9}
\no{9}
\unique{15210:S18:CH8:SEC1:UN2:GR9}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Map]
\label{atom:15210:S18:CH8:SEC1:UN2:GR9:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR9:AT1}
\parent{...NO.PARENTS...}

A common operation on sequences is to apply some computation to each
element of a sequence.  
%
For example we might want to add five to each
element of a sequence.  
%
For this purpose, we can use the operation $\cd{map}$, which takes a
function $f$ and a sequence $a$ and applies the function $f$ to each
element of $a$ returning a sequence of equal length with the results.
%
As with $\cd{tabulate}$, in $\cd{map}$, the function~$f$ can be
applied to all the elements of the sequence in parallel.  
%
We specify the behavior of $\cd{map}$ as follows
\[
\begin{alignat}{1}
\cd{map} &~(f: \alpha  \rightarrow \beta)~(a: \sseq{\alpha}) : \sseq{\beta}
\\
&~= \cset{(i,f(x)) : (i,x) \in a}
\end{alignat}
\]
\smallskip
or equivalently as
\smallskip
\[
\cd{map}~(f: \alpha  \rightarrow \beta)~\cseq{a_1, \ldots, a_{n-1}}: \sseq{\alpha}) : \sseq{\beta}
 = 
\cseq{f(a_1), \ldots, f(a_{n-1})}.
\]

We use the following syntax for the $\cd{map}$ function
%
\[
\equivs
{\cseq{e : p \in e_s}}
{\cd{map}~(\cfn{p}{e})~e_s,}
\]
%
where $e$ and $e_s$ are expressions, the second evaluating to a sequence, and $p$ is a a pattern of
variables (e.g., $x$ or $(x,y)$).
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR10}
\no{10}
\unique{15210:S18:CH8:SEC1:UN2:GR10}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Filter]
\label{atom:15210:S18:CH8:SEC1:UN2:GR10:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR10:AT1}
\parent{...NO.PARENTS...}

To filter out elements from a given sequence, we can use the function
$\cd{filter}$.  The function takes a Boolean function~$f$ and a
sequence~$a$ as arguments and applies~$f$ to each element of~$a$,
returning the sequence consisting exactly of those elements of 
$s \in a$ for which $f(s)$ returns true, and maintaining the order of the
elements returned. 
%
We can specify the behavior of $\cd{filter}$ as follows
%
\[
\begin{alignat}{1}
\cd{filter} & ~(f: \alpha \rightarrow \tybool)~(a: \sseq{\alpha}) : \sseq{\alpha}
=
\\
 & ~\left\{\left(\cseqlen{\csetf{(j,y) \in a}{j < i \land f(y)}}, x\right): (i,x) \in a \mid f(x)\right\}.
\end{alignat}
\]
%
As with $\cd{map}$ and $\cd{tabulate}$, the function $f$ in
$\cd{filter}$ can be applied to the elements in parallel.
%

We use the following syntax for the $\cd{filter}$ function
%
\[
\equivs
{\cseqf{x \in e_s}{e}}
{\cd{filter}~(\cfn{x}{e})~e_s,}
\]
%
where $e$ and $e_s$ are expressions.
%
In the syntax, note the distinction between the colon ($:$) and the
bar ($\mid$).
%
We use the colon to draw elements from a sequence for mapping and we
use the bar to select the elements that we wish to filter.
%
We can use them together, as in: 
%
\[
\begin{alignat}{2}
  \cseqf{e : x \in  e_s}{e_f} & \quad \equiv \quad
   & \cd{map} &~(\cfn{x}{e})
\\
   & & &~(\cd{filter}~(\cfn{x}{e_f})~e_s).
\\
\end{alignat}
\]
%
What appears before the colon (if any) is an expression to apply each
element of the sequence to generate the result; what appears after the
bar (if there is any) is an expression to apply to each element to
decide whether to keep it.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR11}
\no{11}
\unique{15210:S18:CH8:SEC1:UN2:GR11}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Fibonacci]
\label{atom:15210:S18:CH8:SEC1:UN2:GR11:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR11:AT1}
\parent{...NO.PARENTS...}

Given the function $\cd{fib}~i$, which returns the $i^{th}$ Fibonacci
number, the expression:
\[ 
a = \cseq{\cd{fib}~i :  0 \leq i < 9}
\]
%
is equivalent to
%
\[
a = \cd{tabulate}~~\cd{fib}~~9.
\]
%
When evaluated, it returns the sequence
\[
a = \cseq{0, 1, 1, 2, 3, 5, 8, 13, 21, 34}.
\]
%
The expression
\[
\cseq{x^2 : x \in a}
\]
%
is equivalent to
\[
\cd{map}~(\cfn{x}{x^2})~a.
\]
%
When evaluated it returns the sequence:
\[
\cseq{0, 1, 1, 4, 25, 64, 169, 441, 1156}.
\]
%
Given the function $\cd{isPrime}~x$
which checks if $x$ is prime, the expression
\[
\cseq{x : x \in a \sucht \cd{isPrime}~x}
\]
%
is equivalent to
%
\[
\cd{filter}~\cd{isPrime}~a.
\]
When evaluated, it returns the sequence
$
\cseq{2,5,13}.
$
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR12}
\no{12}
\unique{15210:S18:CH8:SEC1:UN2:GR12}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Subsequences]
\label{atom:15210:S18:CH8:SEC1:UN2:GR12:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR12:AT1}
\parent{...NO.PARENTS...}

The 
%
$\cd{subseq}(a,i,j)$ 
%
function extracts a contiguous subsequence of $a$
starting at location~$i$ and with length~$j$.  If the subsequence is
out of bounds of~$a$, only the part within~$a$ is returned.
%
We can specify $\cd{subseq}$ as follows
\[
\begin{alignat}{1}
\cd{subseq} &~(a:\sseq{\alpha})~(i:\tynat)~(j:\tynat): \sseq{\alpha}
\\
&~= \cset{(k-i,x) : (k,x) \in a \mid i \leq k < i + j}.
\end{alignat}
\]

%
We use the following  syntax for denoting subsequences
%
\[
\equivs
{a\cirange{e_i}{e_j}}
{\cd{subseq}~(a,e_i,e_j-e_i+1)}.
\]
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR13}
\no{13}
\unique{15210:S18:CH8:SEC1:UN2:GR13}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Splitting sequences]
\label{atom:15210:S18:CH8:SEC1:UN2:GR13:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR13:AT1}
\parent{...NO.PARENTS...}

As we shall see in the rest of this book, many algorithms operate
inductively on a sequence by splitting the sequence into parts,
consisting for example, of the first element and the rest, a.k.a., the~\defn{head} and the~\defn{tail}, or the first half or the second half.
%
We could define functions such as $\cd{splitHead}$, $\cd{splitMid}$,
$\cd{take}$, and $\cd{drop}$ for these purposes. Since all of these are
trivially expressible in terms of subsequences, we omit their
discussion for simplicity.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR14}
\no{14}
\unique{15210:S18:CH8:SEC1:UN2:GR14}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Append and flatten]
\label{atom:15210:S18:CH8:SEC1:UN2:GR14:AT1:gr:seq::append}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR14:AT1}
\parent{...NO.PARENTS...}

For constructing large sequences from smaller ones, the sequence ADT
provides the  functions $\cd{append}$ and $\cd{flatten}$.
%
The function $\cd{append}~(a,b)$ appends the sequence~$b$
after the sequence~$a$.
%
More precisely, we can specify $\cd{append}$ as follows
\[
\begin{alignat}{1}
\cd{append} & ~(a: \sseq{\alpha})~(b: \sseq{\alpha}) : \sseq{\alpha}
\\
& ~= a \cup \cset{(i+\cseqlen{a}, x) : (i,x) \in b}
\end{alignat}
\]
%
We write $\kwappend{a}{b}$ as a short form for $\cd{append}~a~b$.
%
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR15}
\no{15}
\unique{15210:S18:CH8:SEC1:UN2:GR15}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Flatten]
\label{atom:15210:S18:CH8:SEC1:UN2:GR15:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR15:AT1}
\parent{...NO.PARENTS...}

To append more than two sequences the $\cd{flatten}~a$ function
takes a sequence of sequences and flattens them. If the input is
a sequence $a = \cseq{a_1,a_2,\ldots,a_n}$ it appends all the $a_i$'s.
%
We can specify $\cd{flatten}$ more precisely as follows
\[
\begin{alignat}{1}
\cd{flatten} & ~(a: \sseq{\sseq{\alpha}}) : \sseq{\alpha}
\\
& ~= \left\{\left(i +\sum_{(k,c) \in a, k < j}\cseqlen{c}, x\right) 
%
~:~ (i,x) \in b, (j,b) \in a \right\}.
\end{alignat}
\]
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR16}
\no{16}
\unique{15210:S18:CH8:SEC1:UN2:GR16}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Append and flatten]
\label{atom:15210:S18:CH8:SEC1:UN2:GR16:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR16:AT1}
\parent{gr:seq::append}

The $\cd{append}$ operation $\kwappend{\cseq{1,2,3}}{\cseq{4,5}}$ yields the sequence $\cseq{1,2,3,4,5}.$

The $\cd{flatten}$ operation 
\[
\cd{flatten}~\cseq{\cseq{1,2,3},\cseq{4},\cseq{5,6}}
\]
 yields the sequence $\cseq{1,2,3,4,5,6}$.
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR17}
\no{17}
\unique{15210:S18:CH8:SEC1:UN2:GR17}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Updates and injections]
\label{atom:15210:S18:CH8:SEC1:UN2:GR17:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR17:AT1}
\parent{...NO.PARENTS...}

The function $\cd{update}~(a,(i,x))$, updates location $i$ of
sequence $a$ to contain the value $x$.  If the location is out of
range for the sequence, the function returns the input sequence
unchanged.  
%
We can specify $\cd{update}$ as follows
\[
\begin{alignat}{1}
\cd{update} & ~(a:\sseq{\alpha})~(i:\tynat,x:\alpha): \sseq{\alpha}
\\[1mm]
& ~=  
\left\{
\begin{array}{ll}
\left\{(j, y) : (j, y) \in a \mid j \not= i\right\} \cup \left\{(i, x)\right\} & \mbox{if}~0
\le i < \csetsize{a}
\\
a & \mbox{otherwise}.
\end{array}
\right.
\end{alignat}
\]
\medskip
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR18}
\no{18}
\unique{15210:S18:CH8:SEC1:UN2:GR18}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Inject]
\label{atom:15210:S18:CH8:SEC1:UN2:GR18:AT1:gr:seq::inject}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR18:AT1}
\parent{...NO.PARENTS...}

To update multiple positions at once, we can use $\cd{inject}$.
%
The function $\cd{inject}~(a,b)$ takes a sequence $b$ of
location-value pairs and updates each location with its associated
value.  
%
If any locations are out of range, that pair does nothing.  If
multiple locations are the same,  one of the updates take effect.
%

In the case of duplicates in the update sequence $b$, i.e., multiple
updates to the same position, we leave it unspecified which update
takes effect.
%
The operation $\cd{inject}$ may thus treat duplicate updates
non-deterministically.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR19}
\no{19}
\unique{15210:S18:CH8:SEC1:UN2:GR19}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Inject]
\label{atom:15210:S18:CH8:SEC1:UN2:GR19:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR19:AT1}
\parent{gr:seq::inject}

Given the string sequence 
\[ 
a = \cseq{\cstr{the},\cstr{cat},\cstr{in},\cstr{the},\cstr{hat}},\]
\[
\cd{update}~a~(1,\cstr{rabbit})
\]
magically yields
\[
\cseq{\cstr{the},\cstr{rabbit},\cstr{in},\cstr{the},\cstr{hat}}
\]
since location $1$ is updated with $\cstr{rabbit}$.  The expression
\[
\cd{inject}~a~\cseq{(4,\cstr{log}),(1,\cstr{dog}),(6,\cstr{hog}),(4,\cstr{bog}),(0,\cstr{a})}
\]
could yield
\[ 
\cseq{\cstr{a},\cstr{dog},\cstr{in},\cstr{the},\cstr{bog}}
\]
since location $0$ is updated with $\cstr{a}$, location $1$ with
$\cstr{dog}$, and location $4$ with $\cstr{bog}$.
%
It could also yield
\[ 
\cseq{\cstr{a},\cstr{dog},\cstr{in},\cstr{the},\cstr{log}}
\]
%
The entry with location $6$ is ignored
since it is out of range for $a$.
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR20}
\no{20}
\unique{15210:S18:CH8:SEC1:UN2:GR20}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Collect]
\label{atom:15210:S18:CH8:SEC1:UN2:GR20:AT1:gr:seq::collect}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR20:AT1}
\parent{...NO.PARENTS...}

The primitive $\cd{collect}$ is useful when elements of a sequence
are ``keyed'', making it possible to associate data with some key.
Such pairs consisting of a key and a value are sometimes called~\defn{key-value} pairs.
%
Given a sequence of key-value pairs, we might want to~\defn{collect}
together all the values for a given key.
%
Collecting values together based on a key is very common in processing
databases.  In relational database languages such as SQL it is
referred to as ``Group by''.  More generally it has many applications.


We will use the function $\cd{collect}$ for this purpose, and it is part
of the sequence library.   Its type signature is
\[
\cd{collect}
: 
(\cd{cmp}: \alpha \times \alpha \rightarrow \mathcal{O})
\rightarrow
(a: \sseq{\alpha \times \beta})
\rightarrow
\sseq{\alpha \times \sseq{\beta}}.
\]
%
Here the "order set" $\mathcal{O} = \{\cd{less}, \cd{equal}, \cd{greater}\}$. 

The first argument $cmp$ is a function for comparing keys of type $\alpha$,
and must define a total order over the keys.  
%
The second argument $a$ is a sequence of key-value pairs.  
%
The $\cd{collect}$ function collects all values in $a$ that share the
same key together into a sequence, ordering the values in the same
order as their appearance in the original sequence.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR21}
\no{21}
\unique{15210:S18:CH8:SEC1:UN2:GR21}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Collect]
\label{atom:15210:S18:CH8:SEC1:UN2:GR21:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR21:AT1}
\parent{gr:seq::collect}

The following sequence shows a sequence of key-value pairs consisting
of our students from last semester and the classes they take.
%
\[
\begin{alignat}{1}
kv  = \langle 
& (\cstr{jack}, \cstr{15210}), (\cstr{jack}, \cstr{15213})
\\
& (\cstr{mary}, \cstr{15210}), (\cstr{mary}, \cstr{15213}), (\cstr{mary}, \cstr{15251}),
\\
& (\cstr{peter}, \cstr{15150}), (\cstr{peter}, \cstr{15251}), 
\\
& \ldots
\\
\rangle & .           
\end{alignat}
\]
%
We can determine the classes taken by each student by using
$\cd{collect}~\cd{cmp}$, where $\cd{cmp}$ is a comparison function for
strings
\[
\begin{alignat}{1}
\cd{collect}~\cd{cmp}~kv = \langle
~&~ (\cstr{jack}, \cseq{\cstr{15210}, \cstr{15213}, \ldots})
\\
~&~ (\cstr{mary}, \cseq{\cstr{15210}, \cstr{15213},  \cstr{15251}, \ldots}),
\\
~&~ (\cstr{peter}, \cseq{\cstr{15150}, \cstr{15251}, \ldots}), 
\\
~&~ \ldots
\\
\rangle ~&~ .           
\end{alignat}
\]
%
Note that the output sequence is ordered based on the first instance
of their key in the input sequences.  
%
Similarly, the order of the classes taken by each student are the same
as in the input sequence.
%
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN2:GR22}
\no{22}
\unique{15210:S18:CH8:SEC1:UN2:GR22}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Checking for empty and singularity sequences]
\label{atom:15210:S18:CH8:SEC1:UN2:GR22:AT1:gr:seq::check-small}
\no{1}
\unique{15210:S18:CH8:SEC1:UN2:GR22:AT1}
\parent{...NO.PARENTS...}

To identify trivial sequences such as empty sequences and singular
sequences, which contain only one element, the interface provides the
functions $\cd{isEmpty}$ and $\cd{isSingular}$, which return
respectively return $\cd{true}$ if the sequence is empty or singular
and return $\cd{false}$ otherwise.
%
\end{gram}
\end{group}
\end{unit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{unit}[Aggregation by Iteration]
\label{unit:15210:S18:CH8:SEC1:UN3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[The $\cd{iterate}$ function]
\label{atom:15210:S18:CH8:SEC1:UN3:GR1:AT1:gr:seq::iterate}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR1:AT1}
\parent{...NO.PARENTS...}

Iteration is a key concept in computing, and specifically in algorithm
design.  
%
Iteration involves a sequence of steps, taken one after another, where
each step transforms the state from the previous step.  
%
Iteration is therefore an inherently sequential process.
%
The function $\cd{iterate}$ can be used to create a computation that
iterates over a sequence while accumulating information.
%
It starts with an initial state and a sequence, and on each step
updates the state based on the next element of the sequence.
%


The function $\cd{iterate}$ has the type signature
\[
\cd{iterate}~(f: \alpha \times \beta \ra \alpha)~(x: \alpha)~(a:
\sseq{\beta}) : \alpha
\]

where $f$ is a function mapping a state and an element of $a$ to a new
state, $x$ is the initial state,  $a$ is a sequence.
%
%

The semantics of $\cd{iterate}$ is defined as follows.
\[
\cd{iterate}~f~x~a
=  
\left\{
\begin{array}{ll}
x & \mbox{if}~ \cseqlen{a}= 0\\
f(x, a[0]) & \mbox{if}~\cseqlen{a}= 1\\
\cd{iterate}~f~(f(x, a[0])) (a\cirange{1}{\cseqlen{a}-1}) & \mbox{otherwise.}
\end{array}
\right.
\]
\end{definition}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN3:GR2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Iteration with prefixes]
\label{atom:15210:S18:CH8:SEC1:UN3:GR2:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR2:AT1}
\parent{...NO.PARENTS...}

As a variant of iteration, we define $\cd{iteratePrefixes}$, which
takes the same arguments but returns all the intermediate values
computed as a sequence.
%
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN3:GR3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN3:GR3:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR3:AT1}
\parent{...NO.PARENTS...}

The function $\cd{iterate}$ computes its final result by computing a
result for each element of the sequence.
%
Concretely, $\cd{iterate}~f~x~a$ computes the results $x_i$, $0 \le i \le n
= \cseqlen{a}$.
\[
\begin{array}{lcl}
x_0 & = & x
\\
x_1 & = & f(x_0,a[0])
\\
x_2 & = & f(x_1, a[1])
\\
& \vdots &
\\
x_{n} & = & f(x_{n-1},a[n-1]).
\end{array}
\]
%
As the result
%
\[
\cd{iterate}~f~x~a
\]
%
returns  $x_n$.
%

The expression
%
\[
\cd{iteratePrefixes}~f~x~a
\]
%
performs the same computation and
returns  $\cseq{x_0, \ldots, x_n}$.
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN3:GR4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Iteration]
\label{atom:15210:S18:CH8:SEC1:UN3:GR4:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR4:AT1}
\parent{gr:seq::iterate}

For a sequence of length $5$, iteration computes its final result  as
\[
\cd{iterate}~f~x~a  = f(f(f(f(f(v,a[0]),a[1]),a[2]),a[3]),a[4]).
\]
%

For example,
\[
\cd{iterate}~\cstr{+}~0~\cseq{2, 5, 1, 6}
\]
returns $14$ since it starts with the integer state $0$ and then one
by one adds the integer elements $2$, $5$, $1$ and $6$ of the sequence
to the state. 

Similarly
\[
\cd{iterate}~\cstr{-}~0~\cseq{2, 5, 1, 6}
\]
returns $(((0 - 2) - 5) - 1) - 6 = -14$.
%

The function 
\[
\cd{iterate}~\cstr{+}~0~(\cd{map}~\cd{zeroWhenEven}~a),
\]
which uses the function $\cd{zeroWhenEven}$ to map even numbers to zero,
sums up only the odd numbers in sequence $a,$~returning $6$
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR5}
\no{5}
\unique{15210:S18:CH8:SEC1:UN3:GR5}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{teachask}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN3:GR5:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR5:AT1}
\parent{...NO.PARENTS...}

You are likely familiar with what a properly matched strings are but
how can we define such strings?
\end{teachask}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[Parantheses matching]
\label{group:15210:S18:CH8:SEC1:UN3:GR6}
\no{6}
\unique{15210:S18:CH8:SEC1:UN3:GR6}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Parantheses matching]
\label{atom:15210:S18:CH8:SEC1:UN3:GR6:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR6:AT1}
\parent{def:seq::iterate}

We say a string is matched if it can be described recursively
as
\[
p = \cseq{} \mid p~p \mid \chr{(}~p~\chr{)}, 
\]
where $\cseq{}$ is the empty sequence, $p~p$ indicates appending two
strings of matched parentheses (recursively defined), and
$\chr{(}~p~\chr{)}$ indicates the string starting with $\chr{(}$
followed by a matched string $p$ followed by $\chr{)}$.
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Parenthesis matching]
\label{atom:15210:S18:CH8:SEC1:UN3:GR6:AT2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN3:GR6:AT2}
\parent{...NO.PARENTS...}

The string $\cstr{(())()}$ is matched.
%
The $\cstr{())(()}$ is not matched.
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR7}
\no{7}
\unique{15210:S18:CH8:SEC1:UN3:GR7}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{problem}[Parentheses matching]
\label{atom:15210:S18:CH8:SEC1:UN3:GR7:AT1:pr:seq::matching}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR7:AT1}
\parent{...NO.PARENTS...}

The \emph{parentheses matching} problem requires determining whether a
given a string of parentheses is matched.
\end{problem}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR8}
\no{8}
\unique{15210:S18:CH8:SEC1:UN3:GR8}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{teachask}[Parethesis matching via iteration]
\label{atom:15210:S18:CH8:SEC1:UN3:GR8:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR8:AT1}
\parent{gr:seq::iterate}
\parent{pr:seq::matching}

Can you solve this problem  using $\cd{iterate}$?
\end{teachask}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR9}
\no{9}
\unique{15210:S18:CH8:SEC1:UN3:GR9}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Parethesis matching via iteration]
\label{atom:15210:S18:CH8:SEC1:UN3:GR9:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR9:AT1}
\parent{...NO.PARENTS...}

As an application of iteration, let's try to solve the parenthesis
matching problem.
%
%% There are a several algorithms for solving this problem.  Here we
%% consider a linear-work sequential algorithm based on $\cd{iterate}$.  In
%% Chapter~\ref{ch:divide-and-conquer}, we present a divide-and-conquer
%% algorithm that requires no more work asymptotically, but has a low
%% span.
%
We can solve this problem by starting at the beginning of the sequence
with a counter set to zero and iterating through the elements one by
one.  If we ever see a left parenthesis we increment the counter and
whenever we see a right parenthesis we decrement the counter.
%
A sequence of parentheses can only be matched if the count ends at~$0$
since being matched requires that there are an equal number of right
and left parentheses.  However ending with a count of~$0$ is not
adequate since the string~$\cstr{))((}$ has count~$0$ but is obviously
not matched.  It also has to be the case that the count can never go
below~$0$ during the iterations.  

This observation leads to the algorithm shown below.
%
The algorithm starts with the state  $\csome{0}$ and
increments or decrements the counter on a left and right parenthesis,
respectively.  If the iterations ever encounter a right parenthesis
when the count is zero, this indicates the count will go below zero,
and at this point the state is changed to $\cd{None}$, which is
propagated through the rest of the iterations to the result.
Therefore at the end if the state is $\csome{0}$ then the counter
never went below zero and ended up at zero so the parentheses must be matched.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR10}
\no{10}
\unique{15210:S18:CH8:SEC1:UN3:GR10}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[Parenthesis matching via iterate]
\label{atom:15210:S18:CH8:SEC1:UN3:GR10:AT1:alg:seq::iterate::pmatch}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR10:AT1}
\parent{gr:seq::iterate}

\[
\begin{array}{l}
\cd{matchParens}~a = \\ 
~~\cd{let} \\
~~~~\cd{count}~(s, x) = \\
~~~~~~\cd{case}~(s, x) \\ 
~~~~~~~~|~(\cd{None}, \cignore) \dra \cd{None}\\
~~~~~~~~|~(\cd{Some}~n, \cd{')'}) \dra \cd{if}~(n = 0)~\cd{then}~\cd{None}~\cd{else}~\cd{Some}~(n - 1)\\
~~~~~~~~|~(\cd{Some}~n, \cd{'('}) \dra \cd{Some}~(n + 1)\\
~~\cd{in}\\
~~~~(\cd{iterate}~\cd{count}~(\cd{Some}~0)~a) = \cd{Some}~0 \\
~~\cd{end}
\end{array}
\]
\end{algorithm}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR11}
\no{11}
\unique{15210:S18:CH8:SEC1:UN3:GR11}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{teachask}[Order of additions]
\label{atom:15210:S18:CH8:SEC1:UN3:GR11:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR11:AT1}
\parent{...NO.PARENTS...}

Consider the algorithm for summing the numbers in a sequence of
natural numbers $a$ using $\cd{iterate}$:
%
\[
\cd{iterate}~\cstr{+}  0 a
\]

This algorithm performs the plus operations in a particular order.  Is
this necessary?
\end{teachask}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN3:GR12}
\no{12}
\unique{15210:S18:CH8:SEC1:UN3:GR12}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Iteration and order of operations]
\label{atom:15210:S18:CH8:SEC1:UN3:GR12:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN3:GR12:AT1}
\parent{...NO.PARENTS...}

Iteration is a powerful technique but can be too big of a hammer,
especially when used unnecessarily.  
%
For example, when summing the elements in a sequence, we don't need to
perform the addition operations in a particular order because addition
operations are associative and thus they can be performed in any order
desired.  
%
The iteration-based algorithm for computing the sum does not take
advantage of this property, computing instead the sum in a
left-to-right order.
%
As we will see next, we can use the associativity of the addition
operations to sum up the elements of a sequence in parallel.
\end{gram}
\end{group}
\end{unit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{unit}[Aggregation by Reduction]
\label{unit:15210:S18:CH8:SEC1:UN4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Reduction]
\label{atom:15210:S18:CH8:SEC1:UN4:GR1:AT1:gr:seq::reduce-intro}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR1:AT1}
\parent{...NO.PARENTS...}

The term~\defn{reduction} refers to a computation that repeatedly
applies an associative binary operation to a collection of elements
until the result is reduced to a single value.
%
Recall that  associative operations are defined as operations that
allow commuting the order of operations.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[Associativity]
\label{group:15210:S18:CH8:SEC1:UN4:GR2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN4:GR2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Assocative Function]
\label{atom:15210:S18:CH8:SEC1:UN4:GR2:AT1:def:seq::assoc}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR2:AT1}
\parent{...NO.PARENTS...}

A function~$f: \alpha \times \alpha \rightarrow \alpha$ is associative
if $f(f(x,y),z) = f(x,f(y,z))$ for all $x,y$ and $z$ of type $\alpha$.
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{note}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR2:AT2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN4:GR2:AT2}
\parent{...NO.PARENTS...}

Associativity implies that when applying $f$ to some values, the order
in which the applications are performed does not matter.
%
Associativity does not mean that you can reorder the arguments to a
function (that would be commutativity).
\end{note}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR2:AT3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN4:GR2:AT3}
\parent{...NO.PARENTS...}

Many functions are associative. 

\begin{itemize}
\item Addition and
multiplication on natural numbers are associative, with 0 and 1 as
their identities, respectively.  

\item Minimum and maximum are also
associative with identities $\infty$ and $-\infty$ respectively.
%


\item The $\cd{append}$ function on sequences is associative, with
identity being the empty sequence.


\item The union operation on sets is associative, with the empty set as the
identity.
%

\end{itemize}
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{important}[Associativity of Floating Point Operations]
\label{atom:15210:S18:CH8:SEC1:UN4:GR2:AT4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN4:GR2:AT4}
\parent{...NO.PARENTS...}

An important class of operations that are not associative is
  floating-point operations.
%
These operations are typically not associative because performing a
set of operations in different orders can lead to different results
because of loss of precision.
\end{important}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN4:GR3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[The $\cd{reduce}$ operation]
\label{atom:15210:S18:CH8:SEC1:UN4:GR3:AT1:gr:seq::reduce}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR3:AT1}
\parent{...NO.PARENTS...}

In the sequence ADT, we use the function $\cd{reduce}$ to perform a
reduction over a sequence by applying an associative binary operation
to the elements of the sequence until the result is reduced to a
single value.
%
The operation function has the type signature
\[
\cd{reduce}~(f: \alpha \times \alpha \ra \alpha)~(id: \alpha)~(a: \sseq{\alpha}) : \alpha
\]
where $f$ is an associative function, $a$ is the sequence, and $id$ is
the~\defn{left identity} of $f$, i.e., $f(id,x) = x$ for all $x \in
\alpha$.
%

When applied to an input sequence with a function $f$, $\cd{reduce}$
returns the ``sum'' with respect to~$f$ of the input sequence.  In
fact if~$f$ is associative this sum in equal to iteration.
%
We can define the behavior of $\cd{reduce}$ inductively as follows
%
\[
\cd{reduce}~f~id~a
= 
\left\{
\begin{array}{ll}
id & \mbox{if}~\cseqlen{a}= 0
\\
a[0] & \mbox{if}~\cseqlen{a}= 1
\\[2ex]
f\left(\cd{reduce}~f~id~(a\cirange{0}{\lfloor \frac{\cseqlen{a}}{2}
    \rfloor - 1}),
\right.
\\
~~~~\left.\cd{reduce}~f~id~(a\cirange{\lfloor \frac{\cseqlen{a}}{2} \rfloor}{\cseqlen{a}-1}\right) & \mbox{otherwise.}
\end{array}
\right.
\]
\end{definition}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN4:GR4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{important}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR4:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR4:AT1}
\parent{...NO.PARENTS...}

The function $\cd{reduce}$ is more restrictive than $\cd{iterate}$ because
it is the same function but with extra restrictions on its input
(i.e. that~$f$ be associative, and $id$ is a left identity).
%
If the function $f$ is associative, then we have
\[
\cd{reduce}~f~id~a = \cd{iterate}~f~id~a.
\]
\end{important}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR5}
\no{5}
\unique{15210:S18:CH8:SEC1:UN4:GR5}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Reduce and append]
\label{atom:15210:S18:CH8:SEC1:UN4:GR5:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR5:AT1}
\parent{gr:seq::reduce}

The expression 
\[
\cd{reduce}~\cd{append}~\cseq{}~\cseq{\cstr{another},\cstr{way},\cstr{to},\cstr{flatten}}
\] 
evaluates to
\\
\[
\cstr{anotherwaytoflatten}.
\]
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR6}
\no{6}
\unique{15210:S18:CH8:SEC1:UN4:GR6}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exercise}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR6:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR6:AT1}
\parent{...NO.PARENTS...}

Give an example function $f$, a left identity $x$, and an input
sequence $a$ such that
$\cd{iterate}~f~x~a$ and $\cd{reduce}~f~x~a$ return different results.
\end{exercise}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR7}
\no{7}
\unique{15210:S18:CH8:SEC1:UN4:GR7}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{important}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR7:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR7:AT1}
\parent{...NO.PARENTS...}

Although we will use $\cd{reduce}$ only with associative functions, we
define it for all well-typed functions.
%
To deal properly with functions that are non-associative, the
specification of $\cd{reduce}$ makes precise the order in which the
argument function~$\cd{f}$ is applied.
%
For instance, when reducing with floating point addition or
multiplication, we will need to take the order of operations into
account.
%
Because the specification defines the order in which the operations
are applied, every (correct) implementation of $\cd{reduce}$ must
return the same result: the result is deterministic regardless of the
specifics of the algorithm used in the implementation.
\end{important}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN4:GR8}
\no{8}
\unique{15210:S18:CH8:SEC1:UN4:GR8}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{exercise}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR8:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN4:GR8:AT1}
\parent{...NO.PARENTS...}

Given that $\cd{reduce}$ and $\cd{iterate}$ are equivalent for
assocative functions, why would we use $\cd{reduce}$?
\end{exercise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{solution}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN4:GR8:AT2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN4:GR8:AT2}
\parent{...NO.PARENTS...}

Even though the input-output behavior of $\cd{reduce}$ and $\cd{iterate}$
may match, their cost specifications differ: unlike $\cd{iterate}$,
which is strictly sequential, $\cd{reduce}$ is parallel. 
%
In fact, as we will see later,
% in Section~\ref{sec:seq::cost} , 
the span of $\cd{iterate}$ is linear in the size of the input, whereas
the span of $\cd{reduce}$ is logarithmic.
\end{solution}
\end{group}
\end{unit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{unit}[Aggregation with Scan]
\label{unit:15210:S18:CH8:SEC1:UN5}
\no{5}
\unique{15210:S18:CH8:SEC1:UN5}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR1}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[The $\cd{scan}$ operation]
\label{atom:15210:S18:CH8:SEC1:UN5:GR1:AT1:gr:seq::scan-intro}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR1:AT1}
\parent{...NO.PARENTS...}

When we restrict ourselves to associative functions, the input-output
behavior of the function $\cd{reduce}$ can be defined in terms of the
$\cd{iterate}$. 
%
But the reverse is not true: $\cd{iterate}$ cannot always be defined
in terms of $\cd{reduce}$, because $\cd{iterate}$ can use the results
of intermediate states computed on the prefixes of the sequence,
whereas $\cd{reduce}$ cannot because such intermediate states are not
available.  
%
For example, in our parenthesis matching algorithm
%(Algorithm~\ref{alg:seq::iterate::pmatch}),
we used this property by defining our function to propagate

a mismatched parenthesis forward in the computation.
%
We now describe a function called $\cd{scan}$ that
allows using the results of intermediate computations and also does so
in parallel.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR2}
\no{2}
\unique{15210:S18:CH8:SEC1:UN5:GR2}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{teachnote}[Operations in scan and iteration]
\label{atom:15210:S18:CH8:SEC1:UN5:GR2:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR2:AT1}
\parent{...NO.PARENTS...}

Note that scan still requires the function to be a binary operation
returning the same type as its argument, whereas iteration does not.
For example, the function for computing parenthesis matching does not
work as a scan operator.
\end{teachnote}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR3}
\no{3}
\unique{15210:S18:CH8:SEC1:UN5:GR3}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[The function $\cd{scan}$]
\label{atom:15210:S18:CH8:SEC1:UN5:GR3:AT1:gr:seq::scan-intro}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR3:AT1}
\parent{...NO.PARENTS...}

The term ``scan'' refers to a computation that reduces every prefix of
a given sequence by repeatedly applying an associative binary
operation.  
%
The $\cd{scan}$ function has the type signature
\[
\cd{scan}~(f: \alpha * \alpha \ra \alpha)~(id: \alpha)~(a: \sseq{\alpha})~:~(\sseq{\alpha} * \alpha),
\]
where $f$ is an associative function, $a$ is the sequence, and $id$ is
the left identity element of $f$.
%
The expression $\cd{scan}~f~a$ returns the ``sum'' with respect
to~$f$ of all prefixes of the input sequence~$a$.
%
For this reason, the $\cd{scan}$ operation is sometimes called the~\defn{prefix sums} operation.
%


We define the semantics of $\cd{scan}$ in terms of $\cd{reduce}$ as follows.
\[
\begin{alignat}{2}
\cd{scan}~f~id~a
& ~=~ &
(&\cseq{\cd{reduce}~f~id~a\cirange{0}{(i-1)} : 0 \le i < \cseqlen{a}},
\\
& & &~\cd{reduce}~f~id~a)
\end{alignat}
\]

For the definition, we assume that $a\cirange{0}{-1} = \cseq{}$.
\end{definition}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR4}
\no{4}
\unique{15210:S18:CH8:SEC1:UN5:GR4}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Inclusive Scan]
\label{atom:15210:S18:CH8:SEC1:UN5:GR4:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR4:AT1}
\parent{...NO.PARENTS...}

When computing the result for position~$i$, $\cd{scan}$ does not
include the element of the input sequence at that position.  It is
sometimes useful to do so.  To this end, we define $\cd{scanI}$ (``I''
stands for ``inclusive'').

We define the semantics of $\cd{scanI}$ in terms of $\cd{reduce}$ as follows.
\[
\begin{alignat}{1}
\cd{scanI}~f~id~a
& ~=~ 
\cseq{\cd{reduce}~f~id~a\cirange{0}{i} : 0 \le i < \cseqlen{a}}
\\
\end{alignat}
\]
\end{definition}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR5}
\no{5}
\unique{15210:S18:CH8:SEC1:UN5:GR5}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Scan]
\label{atom:15210:S18:CH8:SEC1:UN5:GR5:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR5:AT1}
\parent{gr:seq::scan}

Consider the sequence $a = \cseq{0,1,2}$.
%
The prefixes of $a$ are  
\begin{itemize}
\item $\cseq{}$
\item $\cseq{0}$
\item $\cseq{0,1}$
\item $\cseq{0,1,2}.$
\end{itemize}
%
The prefixes of a sequence are all the subsequences of the sequence
that starts at its beginning. Empty sequence is a prefix of any
sequence.
%
The computation $\cd{scan}~\cd{+}~0~\cseq{0,1,2}$ can be written as
%
\[
\begin{alignat}{2}
\cd{scan}~\cd{+}~0~\cseq{0,1,2}
& =
& 
\left( \right. 
& \cseqb ~\cd{reduce}~\cd{+}~0~\cseq{}, 
\\
& & & ~~\cd{reduce}~\cd{+}~0~\cseq{0}, 
\\
& & & ~~\cd{reduce}~\cd{+}~0~\cseq{0, 1} 
\\ 
& & & \cseqe~, 
\\
& & & \cd{reduce}~\cd{+}~0~\cseq{0, 1, 2} 
\\
&  & \left.\right) &
\\
& = & \left(\right. & \cseq{0, 0, 1}, 3 \left.\right).
\end{alignat}
\]


%
The computation $\cd{scanI}~\cd{+}~0~\cseq{0,1,2}$ can be written as
\[
\begin{alignat}{2}
\cd{scanI}~\cd{+}~0~\cseq{0,1,2}
& ~=~ & 
\cseqb ~&~ \cd{reduce}~\cd{+}~0~\cseq{0}, 
\\
& & ~&~ \cd{reduce}~\cd{+}~0~\cseq{0, 1}, 
\\
& & ~&~ \cd{reduce}~\cd{+}~0~\cseq{0, 1, 2,} 
\\
& & \cseqe 
\\
& ~=~ & & \!\!\!\cseq{0, 1, 3}.
\end{alignat}
\]
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR6}
\no{6}
\unique{15210:S18:CH8:SEC1:UN5:GR6}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{teachask}[...NO.TITLE...]
\label{atom:15210:S18:CH8:SEC1:UN5:GR6:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR6:AT1}
\parent{...NO.PARENTS...}

Given that scan can be expressed just in terms of the operations that
we have already seen, why do we need it?
\end{teachask}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR7}
\no{7}
\unique{15210:S18:CH8:SEC1:UN5:GR7}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{gram}[Scan versus reduce]
\label{atom:15210:S18:CH8:SEC1:UN5:GR7:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR7:AT1}
\parent{...NO.PARENTS...}

Since $\cd{scan}$ can be specified in terms of reduce, one might be
tempted to argue that it is redundant.
%
In fact, it is not: as we shall see, performing $\cd{reduce}$ repeatedly
on every prefix is not work efficient.  
%
Remarkably $\cd{scan}$ can be implemented by performing essentially the
same work and span of $\cd{reduce}$.
\end{gram}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR8}
\no{8}
\unique{15210:S18:CH8:SEC1:UN5:GR8}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}[Copy scan]
\label{atom:15210:S18:CH8:SEC1:UN5:GR8:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR8:AT1}
\parent{gr:seq::scan}

Scan is useful when we want pass information along the
  sequence. For example, suppose you have some ``marked'' elements
  that you would like to copy across to their right until they reach
  another marked element.
%
For example, suppose that we are given a sequence of type $\sseq{\tynat}$
consisting only of natural numbers and asked to return a sequence
of the same length where each element receives the previous positive
value.  For the example, for input $\cseq{0,~7,~0,~0,~3,~0},$ the
result should be $\cseq{0,~0,~7,~7,~7,~3}$.

Using a sequential loop or $\cd{iterate}$ would be easy.  To solve
this problem using $\cd{scan}$ we need a combining function $f$.  
%
Consider the function
%
\[
\cd{skipZero}~(x,y) = \cd{if}~y > 0~\cd{then}~y~\cd{else}~x.
\]
%
%
The function returns its right (second) argument if it is positive,
otherwise it returns its the left (first) argument.
%

To be used in a scan, $\cd{skipZero}$ must be associative.  In
particular we need to show that for all $x$, $y$ and $z$, we have
\[
\cd{skipZero}(x,\cd{skipZero}(y,z)) =
\cd{skipZero}(\cd{skipZero}(x,y),z).
\]
%
There are eight possibilities corresponding to each of $x$, $y$ and
$z$ being either positive or not.  
%
For the cases where $z$ is
positive, it is easy to verify that either ordering returns $z$.
%
For the cases that $z = 0$ and $y$ is positive, it is likewise easy to
verify that both orderings give $y$.
%
Finally, for the cases that both $y = z = 0$ and $x$ is positive they
both return $x$, and for all being zero, the ordering returns zero.

To use $\cd{skipZero}$ as part of the scan operation, we need to find
its left identity.  We can see that for any natural number $y$
\[
\cd{skipZero}~(0, y) =  y, 
\]
and that for any natural number $x$
\[
\cd{skipZero}~(x, 0) = x.
\]
%
Thus $0$ is the left identity for $\cd{skipZero}.$
\end{example}
\end{group}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{group}[...NO.TITLE...]
\label{group:15210:S18:CH8:SEC1:UN5:GR9}
\no{9}
\unique{15210:S18:CH8:SEC1:UN5:GR9}
\parent{...NO.PARENTS...}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{remark}[Reduce and scan]
\label{atom:15210:S18:CH8:SEC1:UN5:GR9:AT1}
\no{1}
\unique{15210:S18:CH8:SEC1:UN5:GR9:AT1}
\parent{...NO.PARENTS...}

Experience in parallel computing shows that $\cd{reduce}$ and $\cd{scan}$
are powerful primitives that suffice to express many parallel
algorithms on sequences. 
%
In some ways this is not surprising, because the operations allow
using two important algorithm-design techniques: $\cd{reduce}$ operation
allows expressing divide-and-conquer algorithms and
%
the $\cd{scan}$ operation allows expressing an iterative algorithms.
\end{remark}
\end{group}
\end{unit}
\end{section}
\end{chapter}

\end{book}
