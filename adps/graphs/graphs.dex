\documentclass{course}
\title{Parallel and Sequential Algorithms}

% Course number must be unique in the database
\coursenumber{15210}

\semester{Spring 2018}
\picture{/210/course/air-pavilion.jpg}
\website{http://www.cs.cmu.edu/~15210}

% Provides book
% This must be provided
% The name should be relative to course number.
\providesbook{S18}

% Start counting chapters from 
% This is optional. Will start counting at 1.
\provideschapter{14}
\providessection{1}

15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking â€” i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues. 


\begin{book}
\title{Algorithm Design: Parallel and Sequential}
\authors{Umut A. Acar and Guy Blelloch}

\begin{chapter}[An Introduction to Graphs]
\label{ch:graph-search}

\picture{./media/game-of-thrones.png}

This chapter presents a brief overview of graphs.

\begin{section}[Graphs and Relations]

\begin{unit}

\begin{gram}
Graphs (sometimes referred to as networks) are one of the most
important abstractions in computer science.
%
%% \begin{question}
%% What makes graphs so special?
%% \end{question}
%
What makes graphs important is that they represent relationships.  
%
Relationships between things from the most abstract to the most
concrete, e.g., mathematical objects, people, events, are what makes
everything interesting.
%
Considered in isolation, hardly anything is interesting. For example,
considered in isolation, there would be nothing interesting about a
person. It is only when you start considering his or her relationships
to the world around, the person becomes interesting.  
%
Even at a biological level, what is interesting are the relationships
between cells, molecules, and the biological mechanisms.
\end{gram}

%% \begin{question}
%% Trees captures relationships too, so why are graphs more interesting?
%% \end{question}

\begin{gram}
Other abstractions such as trees can also represent relationships, but
only certain ones. Graphs are more interesting because they can
represent any relationships---they are far more expressive.  
%
For example, in a tree, there cannot be cycles or multiple paths
between two nodes.
%
%% \begin{question}
%% What do we mean by a ``relationship''? Can you think of a mathematical way
%% to represent relationships.
%% \end{question}
%
Here, what we mean by a relationship is essentially anything that we
can represent abstractly by the mathematical notion of a relation. A~\defn{relation} is defined as a subset of the Cartesian product of two
sets.
\end{gram}
%% \begin{question}
%% Can you see how to represent a  (mathematical) relation with a graph?
%% \end{question}


\begin{gram}
To represent a relation with a graph, we construct a graph, whose
vertices represent the domain and the range of the relationship and
connect the vertices with edges as described by the relation.
\end{gram}

\begin{example}[Friends]
\label{ex:graphs::friends}
You can represent the friendship relation between people as a subset
of the Cartesian product of the people, e.g, \{(Alice,Bob),
(Alice,Arthur), (Bob,Alice), (Bob,Arthur), (Arthur,Josefa),
(Arthur,Bob), (Arthur, Alice), (Josefa,Arthur)\}.

This relation can then be represented as a directed graph where each
arc denotes a member of the relation or as an undirected graph where
each edge denotes a pair of the members of the relation of the form
$(a,b)$ and $(b,a)$.

\begin{center}
\includegraphics[width=1.75in]{./media/friends.jpg}
~~~~~~~~~~~~~~~~
\includegraphics[width=1.75in]{./media/friends-undirected.jpg}
\end{center}

\end{example}


\begin{gram}
In some cases, it is possible to label the vertices of the graphs with
natural numbers starting from $0$.  More precisely, an~\defn{enumerated graph} is a graph $G = (V,E)$ where $V =
\{0,1,\ldots,n-1\}$.
%
As we shall see, such graphs can be more efficient to represent than
general graphs, where we may not assume enumeration.
\end{gram}

\begin{gram}
To use graph abstractions effectively, we need to set up some
definitions and introduce some terminology.  
%
Please see graph theory section of the Preliminaries Chapter
%
%\secref{preliminaries::graph-theory}
%
to review the basic definitions and concepts involving graphs. In the
rest of this chapter, we assume familiarity with basic graph theory
and discuss representation techniques for graphs as well as
applications of graphs.
\end{gram}
\end{unit}
\end{section}

\begin{section}[Representing Graphs]

\begin{unit}
\begin{gram}
To choose an efficient and fast representation for graphs, we need to
determine first the kinds of operations that we intend to support.
For example we might want to perform the following operations on a
graph $G = (V,E)$.
\begin{enumerate}[label=(\arabic*)]
\item Map over the vertices $v \in V$.
\item Map over the edges $(u,v) \in E$.
\item Map over the (in and out) neighbors of a vertex $v \in V$.
\item Return the degree of a vertex $v \in V$.
\item Determine if the edge $(u,v)$ is in $E$.
\item Insert or delete vertices.
\item Insert or delete edges.
\end{enumerate}
\end{gram}


\begin{gram}[Representing Graphs for Parallel Algorithms]
To enable parallel algorithm design, in this book, we represent graphs
by using the abstract data types that we have seen such as sequences,
sets, and tables.
%
This strategy allows us to select the best implementation (data
structure) that meets the needs of the algorithm at the lowest cost.
% 
In the discussion below, we mostly consider directed graphs.  To
represent undirected graphs one can, for example, keep each edge in
both directions, or in some cases just keep it in one direction.
%
For the following discussion, consider a graph $G = (V,E)$ with $n$
vertices and $m$ edges.
\end{gram}

%%%%  Umut: This reads a bit imprecise to me  because 
%%%%  it is unclear what ``abstract'' means.  
%%%%  For exmple, linked lists may be viewed as an abstraction
%%%%  as well.
%%%% 
%% In this book, we take a more abstract view of the representation of
%% graphs and instead of jumping right down to the low-level data
%% structures such as arrays or linked-lists, we will consider
%% representations based on sets and tables.  We then view the standard
%% representations as the special cases when using particular
%% implementations of sets and tables.  This makes it easier to apply
%% parallel operations to the graphs.  It also allows us to use arbitrary
%% sets of vertices instead of requiring the vertices to labeled from $1,
%% 2, \ldots, n$ (or $0, 1, \ldots, n-1$).  The two representations we
%% consider, edge sets and adjacency tables, are generalizations of edge
%% lists and adjacency lists, respectively.  Here we mostly consider
%% directed graphs.  To represent undirected graphs one can, for example,
%% keep each edge in both directions, or in some cases just keep it in
%% one direction.
\end{unit}

\begin{unit}[Edge Sets]
\begin{group}
\begin{gram}
The simplest representation of a graph is based on its definition as a
set of vertices $V$ and a set of directed edges $E \subseteq V \times
V$.  If we use the set ADT, the keys for the edge set are simply pairs
of vertices.  
%
The set could be implemented as a list, an array, a tree, or a hash
table.
%
%% The representation is similar to the edge list representation, but it
%% abstracts away from the particular data structure used for the
%% set---
\end{gram}

\begin{example}

In the edge-set representation, we can represent the directed graph in
Example Friends
%\exref{graphs::friends} 
by using a set of the edges:
\[
\begin{alignat}{1}
\{ 
&
\\
& ~(\alice,\bob), (\alice,\arthur), (\bob,\alice), (\bob,\arthur),
\\
& ~(\arthur,\josefa), (\arthur,\bob), (\arthur, \alice),
(\josefa,\arthur)
\\
\}. &
\end{alignat}
\]
\end{example}
\end{group}


%% \begin{question}
%%   What is the cost of performing graph operations using this
%%   representation?
%% \end{question}

\begin{gram}
Consider the tree-based cost specification for sets.
% given in Chapter~\ref{ch:sets-tables}.  
Using edge sets for a graph with $m$ edges, we can determine if an arc
$(u,v)$ is in the graph with $O(\lg m)$ work using a find, and insert
or delete an arc $(u,v)$ in the same work.  We note that we will often
use $O(\lg n)$ instead of $O(\lg m)$, where $n$ is the number of
vertices.  This is fine, because $m \leq n^2$, which means that $O(\lg
m)$ implies $O(\lg n)$.

Although edge sets are efficient for finding, inserting, or deleting
an edge, they are not efficient if we want to identify the 
neighbors of a vertex $v$.  For example, finding the set of out
edges requires a filter based on checking if the first element of
each pair matches $v$:
\[
\csetf{(x,y) \in E}{v = x}
\]
For $m$ edges this requires $\Theta(m)$ work and $O(\lg n)$
span, which is not efficient in terms of work.  
%
In fact, just about any representation of sets would require at least
$O(m)$ work.
\end{gram}

\begin{costspec}[Edge Sets for Graphs]
  The cost for various graph operations assuming a tree-based cost
  model for sets.  Assumes the function being mapped uses constant
  work and span, and that when mapping over the neighbors of a vertex,
  we have already found the neighbors for that vertex.

\[
\begin{array}{l c c}
 & \mathbf{Work} & \mathbf{Span}  
\\
\hline
(u,v) \stackrel{?}{\in} G
& \bigoh{\lg n} & \bigoh{\lg n}
\\
\mbox{Map over all edges in the graph}
& \bigoh{m} & \bigoh{\lg n}
\\
\mbox{Find neighbors of a vertex}
& \bigoh{m} & \bigoh{\lg n}
\\
\mbox{Map over neighbors of vertex}
& \bigoh{d_G(v)} & \bigoh{\lg n}
\\
\mbox{Find the degree of a vertex}
& \bigoh{m} & \bigoh{\lg n}
\\
\end{array}
\]
\end{costspec}
\end{unit}

\begin{unit}[Adjacency Tables]

\begin{gram}
To access neighbors more efficiently, we can use adjacency tables.
%
The \emph{adjacency table} representation is a table that maps every
vertex to the set of its (out) neighbors.  This is simply an edge-set
table.
%
%% \begin{question}
%% What is the cost of accessing the neighbors of a vertex? 
%% \end{question}
%
In this representation, we can access efficiently the out neighbors of
a vertex by performing a table lookup.  
%
Assuming the tree-based cost model for tables, this requires $O(\lg
n)$ work and span.
\end{gram}

\begin{example}

The adjacency table representation for the directed graphs
representation of the friends relationship in 
Example Friends
%\exref{graphs::friends} 
is

\[
\begin{alignat}{1}
\{ & 
\\
& ~\alice \mapsto \cset{\arthur,\bob},
\\
& ~\bob \mapsto \cset{\alice,\arthur},
\\
& ~\arthur \mapsto \cset{\alice,\josefa},
\\
& ~\josefa \mapsto \cset{\arthur}
\\
\} &
\end{alignat}
\]

\end{example}

%% \begin{question}
%% Can you give an algorithm for finding an edge $(u,v)$? 
%% \end{question}

\begin{gram}
We can check if a particular arc $(u,v)$ is in the graph by first
pulling out the adjacency set for $u$, and then using a find operation
to determine if $v$ is in the set of neighbors.  
%
The operations thus requires $O(\lg n)$ work and span using a
tree-based cost model.  
%
Similarly inserting an arc, or deleting an arc requires $O(\lg
n)$ work and span.  
%
The cost of finding, inserting or deleting an edge is therefore the
same as with edge sets.  
%
Note that in general, once the neighbor set has been pulled out, we
can apply a constant work function over the neighbors in $O(d_G(v))$
work and $O(\lg d_G(v))$ span.
\end{gram}

\begin{costspec}[Adjacency Tables]
  The cost for various graph operations assuming a tree-based cost
  model for tables and sets.  Assumes the function being mapped uses
  constant work and span and assumes that when mapping over the
  neighbors of a vertex, we have already found the neighbors for that
  vertex.

\[
\begin{array}{l c c}
 & \mathbf{Work} & \mathbf{Span}  
\\
\hline
(u,v) \stackrel{?}{\in} G
& \bigoh{\lg n} & \bigoh{\lg n}
\\
\mbox{Map over all edges in the graph}
& \bigoh{m} & \bigoh{\lg n} 
\\
\mbox{Find neighbors of a vertex}
& \bigoh{\lg n} & \bigoh{\lg n} 
\\
\mbox{Map over neighbors of a vertex}
& \bigoh{d_G(v)} & \bigoh{\lg n} 
\\
\mbox{Find the degree of vertex}
& \bigoh{\lg n} & \bigoh{\lg n}
\\
\hline
\end{array}
\]

% \[
% \begin{array}{|l| c c | c c | c c|}
% \hline
%  & \multicolumn{2}{c|}{\mbox{\textbf{edge set}}}
%  & \multicolumn{2}{c|}{\mbox{\textbf{adj table}}}
%  & \multicolumn{2}{c|}{\mbox{\textbf{adj seq}}}\\
%  & \emph{work} & \emph{span}  
%  & \emph{work} & \emph{span}  
%  & \emph{work} & \emph{span}\\ 
% \hline
% (u,v) \stackrel{?}{\in} G
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{d_G(u)} & \bigoh{\lg d_G(u)} \\
% \mbox{map over edges}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{m} & \bigoh{\lg n} 
% & \bigoh{m} & \bigoh{1} \\
% \mbox{find neighbors}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n} 
% & \bigoh{1} & \bigoh{1} \\
% \mbox{map over neighbors}
% & \bigoh{d_G(v)} & \bigoh{\lg n}
% & \bigoh{d_G(v)} & \bigoh{\lg n} 
% & \bigoh{d_G(v)} & \bigoh{1} \\
% \mbox{degree of vertex $v$}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{1} & \bigoh{1}\\
% \hline
% \end{array}
% \]
\end{costspec}

\end{unit}

\begin{unit}[Adjacency Sequences]
%

\begin{gram}
For enumerated graphs $G = (V,E)$, where the vertices are labeled with
the natural numbers $0 \ldots (|V|-1)$, we can use sequences to
improve efficiency of the adjacency table representation by using
sequences for both  tables and sets.
%
This representation allow for fast random access, requiring only
$O(1)$ work to access the $i^{th}$ element rather than $O(\lg n)$.
%
For example, we can find the out neighbors of a vertex in $O(1)$ work
and span.
%
Certain other operations, such as subselecting vertices, however, is
more expensive.
%
Because of the reduced cost of access, we sometimes use adjacency
sequences to represent a graph.
\end{gram}

\begin{example}
  We can relabel the directed graph in Example Friends
%\exref{graphs::friends} 
by assigning the labels $0,1,2,3$ to $\alice, \arthur, \bob, \josefa$
respectively. We can represent the resulting enumerated graph with the
following adjacency sequence:
\[
\begin{alignat}{1}
\langle & 
\\
& ~\cseq{1,2},
\\
& ~\cseq{0,2,3},
\\
& ~\cseq{0,1},
\\
& ~\cseq{1}
\\
\rangle. &
\end{alignat}
\]

\end{example}




\begin{costspec}[Adjacency Sequences]
  The cost for various graph operations assuming a tree-based cost
  model for tables and sets and an array-based cost model for
  sequences.  Assumes the function being mapped uses constant work and
  span and assumes that when mapping over the neighbors of a vertex,
  we have already found the neighbors for that vertex.


\[
\begin{array}{l c c}
\hline
 & \mathbf{Work} & \mathbf{Span}  
\\
\hline
(u,v) \stackrel{?}{\in} G
& \bigoh{d_G(u)} & \bigoh{\lg d_G(u)} 
\\
\mbox{Map over edges}
& \bigoh{m} & \bigoh{1} 
\\
\mbox{Find neighbors}
& \bigoh{1} & \bigoh{1} 
\\
\mbox{Map over neighbors of a vertex}
& \bigoh{d_G(v)} & \bigoh{1} 
\\
\mbox{Find the degree of vertex}
& \bigoh{1} & \bigoh{1}
\\
\hline
\end{array}
\]

% \[
% \begin{array}{|l| c c | c c | c c|}
% \hline
%  & \multicolumn{2}{c|}{\mbox{\textbf{edge set}}}
%  & \multicolumn{2}{c|}{\mbox{\textbf{adj table}}}
%  & \multicolumn{2}{c|}{\mbox{\textbf{adj seq}}}\\
%  & \emph{work} & \emph{span}  
%  & \emph{work} & \emph{span}  
%  & \emph{work} & \emph{span}\\ 
% \hline
% (u,v) \stackrel{?}{\in} G
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{d_G(u)} & \bigoh{\lg d_G(u)} \\
% \mbox{map over edges}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{m} & \bigoh{\lg n} 
% & \bigoh{m} & \bigoh{1} \\
% \mbox{find neighbors}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n} 
% & \bigoh{1} & \bigoh{1} \\
% \mbox{map over neighbors}
% & \bigoh{d_G(v)} & \bigoh{\lg n}
% & \bigoh{d_G(v)} & \bigoh{\lg n} 
% & \bigoh{d_G(v)} & \bigoh{1} \\
% \mbox{degree of vertex $v$}
% & \bigoh{m} & \bigoh{\lg n}
% & \bigoh{\lg n} & \bigoh{\lg n}
% & \bigoh{1} & \bigoh{1}\\
% \hline
% \end{array}
% \]
\end{costspec}
\end{unit}


\begin{unit}[Traditional Representations for Graphs]

\begin{gram}
\label{fig:graphs-intro::undir-graph1}
Traditionally, graphs are represented by using one of the four
standard representations, which we review briefly below.  Of these
representations, edge lists and adjacency lists can be viewed as
implementations of edge sets and adjacency tables, by using lists to
implement sets.
%
For the following discussion, consider a graph $G = (V,E)$ with
$n$ vertices and $m$ edges.
%
As we consider different representations, we illustrate how the graph
shown below is represented using each one.

\begin{center}
\includegraphics[width=1.2in]{./media/undir-graph1.jpg}
\end{center}

\end{gram}

\begin{group}
\begin{gram}[Adjacency Matrix]
Assign a unique label from $0$ to $n-1$ to each vertex and construct
an $n \times n$ matrix of binary values in which location $(i,j)$ is
$1$ if $(i,j) \in E$ and $0$ otherwise.  Note that for an undirected
graph the matrix is symmetric and $0$ along the diagonal.  For
directed graphs the $1$s can be in arbitrary positions.

The disadvantage of adjacency matrices is their space demand of
$\Theta(n^2)$.  Graphs are often sparse, with far fewer edges than
$\Theta(n^2)$.
\end{gram}

\begin{example}
Using an adjacency matrix, the graph 

\includegraphics[width=1.2in]{./media/undir-graph1.jpg}

can be represented as follows.

  \begin{center}
    \begin{minipage}{1.5in}
    $ \begin{bmatrix}
        0 & 0 & 1 & 1 \\
        0 & 0 & 0 & 1 \\
        1 & 0 & 0 & 1 \\
        1 & 1 & 1 & 0
      \end{bmatrix}$
    \end{minipage}
  \end{center}
\end{example}
\end{group}
%% \begin{question}
%% What are the advantages and disadvantages of this representation? 
%% \end{question}


\begin{group}
\begin{gram}[Adjacency List]
Assign a unique label from $0$ to $n-1$ to each vertex and construct
an array $A$ of length $n$ where each entry $A[i]$ contains a pointer
to a linked list of all the out-neighbors of vertex $i$.  In an
undirected graph with edge $\{u,v\}$ the edge will appear in the
adjacency list for both $u$ and $v$.
\end{gram}

\begin{example}
Using adjacency lists, our example graph
\begin{center}
\includegraphics[width=1.2in]{./media/undir-graph1.jpg}
\end{center}
% \figref{graphs-intro::undir-graph1}
is represented as follows.

\begin{center}
\includegraphics[width=2.8in]{./media/adjlist1.jpg}
\end{center}
\end{example}

%% \begin{question}
%% What are the advantages and disadvantages of this representation? 
%% \end{question}

\begin{note}
Adjacency lists are not well suited for parallelism since the lists
require that we traverse the neighbors of a vertex sequentially.
\end{note}
\end{group}

\begin{group}
\begin{gram}[Adjacency Array]

 Similar to an adjacency list, an adjacency array keeps the neighbors
 of all vertices, one after another, in an array $\cd{adj},$ and
 separately, keeps an array of indices that tell us where in the
 $\cd{adj}$ array to look for the neighbors of each vertex.

The disadvantage of the adjacency-array representation is that it is
not easy to insert new edges.
\end{gram}

\begin{example}
Using an adjacency array, our example graph
\begin{center}
\includegraphics[width=1.2in]{./media/undir-graph1.jpg}
\end{center}
% \figref{graphs-intro::undir-graph1}
is represented as follows.
  \begin{center}
    \includegraphics[width=2.6in]{./media/adjarray1.jpg}
  \end{center}
\end{example}
\end{group}


\begin{gram}[Edge List]
In edge-list representation, we use a list to remember all edges in
the graph.  As with adjacency lists, this representation is not good
for parallelism.
\end{gram}

\end{unit}
\end{section}

\begin{section}[Weighted Graphs and Their Representation]

Many applications of graphs require associating weights or other
values with the edges of a graph. In this section, we review the
definition of weighted graphs and discuss how they can be represented.

\begin{unit}

%% This is redundant with preliminaries
\begin{group}
\begin{definition}[Weighted or Edge-Labeled Graphs]
An {\em edge-labeled graph} or a {\em weighted graph} is a triple $G =
(E,V,w)$ where $w\!: E \to L$ is a function mapping edges or directed
edges to their labels (weights), and $L$ is the set of possible
labels (weights).
\end{definition}

\begin{gram}
In a graph, if the data associated with the edges are real numbers, we
often use the term ``weight'' to refer to the edge labels, and use the
term ``weighted graph'' to refer to the graph.  In the general case,
we use the terms ``edge label'' and edge-labeled graph.  Weights or
other values on edges could represent many things, such as a distance,
or a capacity, or the strength of a relationship.
\end{gram}

\begin{example}[Weighted Graph]
\label{ex:graphs-intro::wgraph}
An example directed weighted graph.

\begin{center}
\includegraphics[width=1.5in]{./media/dir-graph1.jpg}
\end{center}
\end{example}
\end{group}

\begin{group}
\begin{gram}[Label Table]
We described three different representations of graphs suitable for
parallel algorithms: edge sets, adjacency tables, and adjacency
sequences.
%% \begin{question}
%% Can you see how we can extend these representations to support edge values?
%% \end{question}
We can extend each of these representations to support edle-labels by
separately representing the function from edges to labels as a table
mapping each edge (or arc) to its value.  This representation allows
looking up the edge value of an edge $e = (u,v)$ by using a table
lookup.  We call this an~\defn{edg-elabel table} or a~\defn{label
  table} for short.
\end{gram}

\begin{example}
For the weighted graph in
Example Weighted-Graph,
% \exref{graphs-intro::wgraph},
 the edge-label table is:

\[
W = \cset{(0,2) \mapsto 0.7,~(0,3) \mapsto -1.5,~(2,3) \mapsto
  -2.0,~(3,1) \mapsto 3.0}
\] 
\end{example}
\end{group}

\begin{group}
\begin{gram}
Label tables work uniformly with all graph representations, and they
are elegant, because they separates the edge labels from the
structural information.
%
However, keeping a separate label table creates redundancy, wasting
space and possibly requiring extra work to access the edge labels.
%% %
%% \begin{question}
%% Can you eliminate this redundancy?
%% \end{question}
%% %
The redundancy can be avoided by storing the edge labels directly with
the edge.
%


For example, when using the edge-set representation for graphs, we can
use label tables (mapping edges to their values) instead of edge sets.
%
Similarly, when using the adjacency-table representation, we can
replace each set of neighbors with a table mapping each neighbor to
the label of the edge to that neighbor.
%
Finally, we can extend an adjacency sequences by creating a sequence
of neighbor-value pairs for each out edge of a vertex.  This is
illustrated in the following example.
\end{gram}

\begin{example}
  For the weighted graph in
Example Weighted-Graph,
% \exref{graphs-intro::wgraph},
%
the adjacency table representation is
\[
G = \cset{0 \mapsto \cset{2 \mapsto 0.7, 3 \mapsto-1.5}, 
          2 \mapsto \cset{3 \mapsto -2.0},
          3 \mapsto \cset{1 \mapsto 3.0}
},
\] 
and the adjacency sequence representation is
\[
G = \cseq{\cseq{(2,0.7),~(3,-1.5)}, 
          \cseq{},
          \cseq{(3,-2.0)},
          \cseq{(1,3.0)}
}.
\] 
\end{example}
\end{group}
\end{unit}
\end{section}

\begin{section}[Applications of Graphs]

Since they are powerful abstractions, graphs can be very important in
modeling data.  In fact, many problems can be reduced to known graph
problems.  in this section, we outline some of the many applications
of graphs.

\begin{unit}

\begin{gram}[Social Network Graphs]
  Graphs that represent who knows whom, who communicates with whom, who
  influences whom or other relationships in social structures.  An example is
  the twitter graph of who follows whom.  These can be used to determine how
  information flows, how topics become hot, how communities develop, or even who
  might be a good match for who, or is that whom.
\end{gram}

\begin{gram}[Transportation Networks]
In road networks vertices are
  intersections and edges are the road segments between them, and for
  public transportation networks vertices are stops and edges are the
  links between them.  Such networks are used by many map programs
  such as Google maps, Bing
  maps and now Apple IOS 6 maps (well perhaps without the public
  transport) to find the best routes between locations.  They are also
  used for studying traffic patterns, traffic light timings, and many
  aspects of transportation.
\end{gram}

\begin{gram}[Utility Graphs]
The power grid, the Internet, and the water network are all examples
of graphs where vertices represent connection points, and edges the
wires or pipes between them.  Analyzing properties of these graphs is
very important in understanding the reliability of such utilities
under failure or attack, or in minimizing the costs to build
infrastructure that matches required demands.
\end{gram}

\begin{gram}[Document-Link Graphs]
  The best known example is the link
  graph of the web, where each web page is a vertex, and each
  hyperlink a directed edge.  Link graphs are used, for example, to analyze
  relevance of web pages, the best sources of information, and
  good link sites.
\end{gram}

\begin{gram}Protein-Protein Interactions Graphs]
Vertices represent proteins and edges represent interactions between
them that carry out some biological function in the cell.
These graphs can be used, for example, to study molecular
pathways---chains of molecular interactions in a cellular process.
Humans have over 120K proteins with millions of interactions among
them.
\end{gram}

\begin{gram}[Network-Packet Traffic Graphs]

Vertices are IP (Internet protocol) addresses and edges are the
packets that flow between them.  Such graphs are used for analyzing
network security, studying the spread of worms, and tracking criminal
or non-criminal activity.
\end{gram}

\begin{gram}[Scene Graphs]
In graphics and computer games scene graphs represent the logical or
spacial relationships between objects in a scene.  Such graphs are
very important in the computer games industry.
\end{gram}

\begin{gram}[Finite-Element Meshes]
In engineering many simulations of physical systems, such as the flow
of air over a car or airplane wing, the spread of earthquakes through
the ground, or the structural vibrations of a building, involve
partitioning space into discrete elements.  The elements along with the
connections between adjacent elements forms a graph that is called a
finite element mesh.
\end{gram}

\begin{gram}[Robot Planning]
Vertices represent states the robot can be in and the edges the
possible transitions between the states.  This requires approximating
continuous motion as a sequence of discrete steps.  Such graph plans
are used, for example, in planning paths for autonomous vehicles.
\end{gram}

\begin{gram}[Neural Networks]
Vertices represent neurons and edges the synapses between them.
Neural networks are used to understand how our brain works and how
connections change when we learn.  The human brain has about $10^{11}$
neurons and close to $10^{15}$ synapses.
\end{gram}

\begin{gram}[Graphs in Quantum Field Theory]
Vertices represent states of a quantum system and the edges the
transitions between them.  The graphs can be used to analyze path
integrals and summing these up generates a quantum amplitude (yes, I
have no idea what that means).
\end{gram}

\begin{gram}[Semantic Networks]
Vertices represent words or concepts and edges represent the
relationships among the words or concepts.  These have been used in
various models of how humans organize their knowledge, and how
machines might simulate such an organization.
\end{gram}

\begin{gram}[Graphs in Epidemiology]
Vertices represent individuals and directed edges the transfer of an
infectious disease from one individual to another.  Analyzing such
graphs has become an important component in understanding and
controlling the spread of diseases.
\end{gram}

\begin{gram}[Graphs in Compilers]
Graphs are used extensively in compilers.  They can be used for type
inference, for so called data flow analysis, register allocation and
many other purposes.  They are also used in specialized compilers, such
as query optimization in database languages.
\end{gram}

\begin{gram}[Constraint Graphs]
Graphs are often used to represent constraints among items.  For
example the GSM network for cell phones consists of a collection of
overlapping cells.  Any pair of cells that overlap must operate at
different frequencies.  These constraints can be modeled as a graph
where the cells are vertices and edges are placed between cells
that overlap.
\end{gram}

\begin{gram}[Dependence Graphs]
Graphs can be used to represent dependences or precedences among
items.  Such graphs are often used in large projects in laying out
what components rely on other components and used to minimize the
total time or cost to completion while abiding by the dependences.
\end{gram}
\end{unit}
\end{section}
\end{chapter}
\end{book}

