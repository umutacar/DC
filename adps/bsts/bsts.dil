%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilCourse}
\begin{dilFieldTitle}
Parallel and Sequential Algorithms
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Parallel and Sequential Algorithms
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210
\end{dilFieldUnique}
\begin{dilLabel}
15210
\end{dilLabel}
\begin{dilNo}
15210
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldCourseNumber}
15210
\end{dilFieldCourseNumber}
\begin{dilFieldPicture}
/210/course/air-pavilion.jpg
\end{dilFieldPicture}
\begin{dilFieldSemester}
Spring 2018
\end{dilFieldSemester}
\begin{dilFieldWebsite}
http://www.cs.cmu.edu/~15210
\end{dilFieldWebsite}
\begin{dilFieldProvidesBook}
S18
\end{dilFieldProvidesBook}
\begin{dilFieldProvidesChapter}
12
\end{dilFieldProvidesChapter}
\begin{dilFieldProvidesSection}
1
\end{dilFieldProvidesSection}
\begin{dilFieldProvidesUnit}
1
\end{dilFieldProvidesUnit}
\begin{dilFieldProvidesAssignment}
1
\end{dilFieldProvidesAssignment}
\begin{dilIntro}
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>

\end{dilIntro}
\begin{dilIntroDex}
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilBook}
\begin{dilFieldTitle}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Algorithm Design: Parallel and Sequential
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18
\end{dilFieldUnique}
\begin{dilLabel}
book:15210:S18
\end{dilLabel}
\begin{dilNo}
0
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldAuthors}
Umut A. Acar and Guy Blelloch
\end{dilFieldAuthors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilChapter}
\begin{dilFieldTitle}
Binary Search Trees
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Binary Search Trees
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12
\end{dilFieldUnique}
\begin{dilLabel}
chapter:15210:S18:CH12:ch:bsts
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldPicture}
/210/bsts/abstract-tree.jpg
\end{dilFieldPicture}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}


...NO.INTRO...
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Motivation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Motivation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>Searching is one of the most important operations in computer science. Of the many search data structures that have been designed and are used in practice, search trees, more specifically balanced binary search trees, occupy a coveted place because of their broad applicability to many different sorts of problems. For example, in this book, we rely on binary search trees to implement set and table (dictionary) abstract data types which are then used in the implementation of many algorithms, including for example graph algorithms.</p>

\end{dilIntro}
\begin{dilIntroDex}


Searching is one of the most important operations in computer science.
Of the many search data structures that have been designed and are
used in practice, search trees, more specifically balanced binary
search trees, occupy a coveted place because of their broad
applicability to many different sorts of problems.  For example, in
this book, we rely on binary search trees to implement set and table
(dictionary) abstract data types
%(\chref{sets-tables}),
which are then used in the
implementation of many algorithms, including for example graph
algorithms.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC1:UN1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC1:UN1:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC1:UN1:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>If we are interested in searching a static or unchanging collection of elements, then we can use a simpler data structure such as sequences. For example, we can use a sequence with the array-based cost specification to implement an efficient search function by representing the collection as a sorted sequence and by using binary search. Such an implementation would yield a logarithmic-work search operation. If, however, we want to support dynamic collections, where for example, we insert new elements and delete existing elements, sequences would require linear work. Binary search trees, or  <span style="color: black"><span><strong><em>BSTs</em></strong></span></span> for short, make it possible to compute with dynamic collections by using insertions, deletions, as well as searches all in logarithmic number of tree operations.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
If we are interested in searching a static or unchanging collection of
elements, then we can use a simpler data structure such as sequences.
%
For example, we can use a sequence with the array-based cost
specification to implement an efficient search function by
representing the collection as a sorted sequence and by using binary
search.  
%
Such an implementation would yield a logarithmic-work search
operation.
%
If, however, we want to support dynamic collections, where for
example, we insert new elements and delete existing elements,
sequences would require linear work.
% 
Binary search trees, or~\defn{BSTs} for short, make it possible to
compute with dynamic collections by using insertions, deletions, as
well as searches all in logarithmic number of tree operations.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC1:UN1:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC1:UN1:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In the traditional treatment of algorithms, which focuses on sequential algorithms, binary search trees revolve around three operations: insertion, deletion, and search. While these operations are important, they are not sufficient for parallelism, since they perform a single update at a time. We therefore consider aggregate update operations, such as union and difference, which can be used to insert and delete (respectively) many elements atonce.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In the traditional treatment of algorithms, which focuses on
sequential algorithms, binary search trees revolve around three
operations: insertion, deletion, and search.
%
While these operations are important, they are not sufficient for
parallelism, since they perform a single update at a time.
% 
We therefore consider aggregate update operations, such as union and
difference, which can be used to insert and delete (respectively) many
elements atonce.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC1:UN1:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC1:UN1:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC1:UN1:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The rest of this chapter is organized as follows. We first define binary search trees and present an ADT for them. We then present a parametric implementation of the ADT by using only two operations, <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>, which respectively split a tree at a given key and join two trees. Next, we present a cost specification based on the parametric implementation, which achieves strong bounds as long as the <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations have logarithmic work and span. As a result, we are able to reduce the problem of implementing the BST ADT to the problem of implementing just the functions <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>. We finish the chapter by presenting a specific instance of the parametric implementation using Treaps. Other possible implementation techniques are also described.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The rest of this chapter is organized as follows.  We first define
binary search trees
%(\secref{bst::prelim})
and present an ADT for them.
%(\secref{bst::adt}). 
%
We then present a parametric implementation of the ADT
%(\secref{bst::parametric})
by using only two operations, $\cd{split}$
and $\cd{join}$, which respectively split a tree at a given key and
join two trees.
%
%In \secref{bst::cost},
Next, we present a cost specification based on the
parametric implementation, which achieves strong bounds as long as the
$\cd{split}$ and $\cd{join}$ operations have logarithmic work and
span.
%
As a result, we are able to reduce the problem of implementing the BST
ADT to the problem of implementing just the functions $\cd{split}$
and $\cd{join}$.  
%
We finish the chapter by presenting a specific instance of the
parametric implementation using Treaps.
%(\secref{bst::treaps}).
%
Other possible implementation techniques are also described.
%(\secref{bst::bsts-review})

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Preliminaries
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Preliminaries
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC2:sec:bst::prelim
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}


...NO.INTRO...
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC2:UN2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC2:UN2:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC2:UN2:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We start with some basic definitions and terminology involving rooted and binary search trees. Recall first that a rooted tree is a tree with a distinguished root node. A  <span style="color: black"><span><strong><em>full binary tree</em></strong></span></span> is a rooted tree, where each node is either a  <span style="color: black"><span><strong><em>leaf</em></strong></span></span>, which has no children, or an  <span style="color: black"><span><strong><em>internal node</em></strong></span></span>, which have a left and a right child.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We start with some basic definitions and terminology involving rooted
and binary search trees.  Recall first that a rooted tree is a tree
with a distinguished root node.
%(\defref{prelim::rootedtree}). 
%
A~\defn{full binary tree} is a rooted tree, where each node is either
a~\defn{leaf}, which has no children, or an~\defn{internal node},
which have a left and a right child.
%(\defref{bst::binarytree}).
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC2:UN2:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Full Binary Tree
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Full Binary Tree
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC2:UN2:GR2:AT1:def:bst::binarytree
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>full binary tree</em></strong></span></span> is an ordered rooted tree in which every internal node has exactly two children: the first or the  <span style="color: black"><span><strong><em>left child</em></strong></span></span> and the second or the  <span style="color: black"><span><strong><em>right child</em></strong></span></span>. The  <span style="color: black"><span><strong><em>left subtree</em></strong></span></span> of a node is the subtree rooted at the left child, and the  <span style="color: black"><span><strong><em>right subtree</em></strong></span></span> the one rooted at the right child.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{full binary tree} is an ordered rooted tree in which every
internal node has exactly two children: the first or the~\defn{left
  child} and the second or the~\defn{right child}.  
%
The~\defn{left subtree} of a node is the subtree rooted at the left
child, and the~\defn{right subtree} the one rooted at the right child.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC2:UN2:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC2:UN2:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A binary search tree is a full binary tree, where each internal node <span class="math inline">\(u\)</span> has a unique key <span class="math inline">\(k\)</span> such that each node in its left subtree has a key less than <span class="math inline">\(k\)</span> and each node in its right subtree has a key greater that <span class="math inline">\(x\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A binary search tree is a full binary tree, where each internal node
$u$ has a unique key~$k$ such that each node in its left subtree has a
key less than $k$ and each node in its right subtree has a key greater
that $x$.  
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC2:UN2:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Binary Search Tree (BST)
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Binary Search Tree (BST)
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC2:UN2:GR4:AT1:def:bst::bst
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A  <span style="color: black"><span><strong><em>binary search tree</em></strong></span></span> (BST) over a totally ordered set <span class="math inline">\(S\)</span> is a full binary tree that satisfies the following conditions.</p>
<ol>
<li><p>There is a one-to-one mapping <span class="math inline">\(k(v)\)</span> from internal tree nodes to elements in <span class="math inline">\(S\)</span>.</p></li>
<li><p>for every <span class="math inline">\(u\)</span> in the left subtree of <span class="math inline">\(v\)</span>, <span class="math inline">\(k(u) &lt; k(v)\)</span></p></li>
<li><p>for every <span class="math inline">\(u\)</span> in the right subtree of <span class="math inline">\(v\)</span>, <span class="math inline">\(k(u) &gt; k(v)\)</span></p></li>
</ol>
<p>In the definition, conditions 2 and 3 are referred to as the  <span style="color: black"><span><strong><em>BST property</em></strong></span></span>. We often refer to the elements of <span class="math inline">\(S\)</span> in a BST as keys, and use <span class="math inline">\(\textsf{dom}(T)\)</span> to indicate the domain (keys) in a BST <span class="math inline">\(T\)</span>. The  <span style="color: black"><span><strong><em>size</em></strong></span></span> of a BST is the number of keys in the tree, i.e. <span class="math inline">\(|S|\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A~\defn{binary search tree} (BST) over a totally ordered set $S$ is a
full binary tree that satisfies the following conditions.
\begin{enumerate}
 \item There is a one-to-one mapping $k(v)$ from internal tree nodes to elements in $S$.
 \item for every $u$ in the left subtree of $v$, $k(u) < k(v)$
 \item for every $u$ in the right subtree of $v$, $k(u) > k(v)$
\end{enumerate}
%
In the definition, conditions 2 and 3 are referred to as the~\defn{BST
  property}.  We often refer to the elements of $S$ in a BST as keys,
and use $\dom{T}$ to indicate the domain (keys) in a BST $T$.
The~\defn{size} of a BST is the number of keys in the tree,
i.e. $|S|$.


% A BST can equivalently be defined recursively as:
% \[
% \cd{BST}(S) = \left\{\begin{array}{ll}
% \cd{Leaf} & S = \emptyset\\
% \cd{iNode}(\cd{BST}(S_L), k, \cd{BST}(S_R)) & 
% \underbrace{(S = S_L \cup \cset{k} \cup S_R)}_{\mbox{one to one (inclusion)}} \wedge \underbrace{(S_L < k < S_R)}_{\mbox{BST property}}
% \end{array}\right.
% \]

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC2:UN2:GR4:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC2:UN2:GR4:AT2:ex:bst
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An example binary search tree over the set of natural numbers <span class="math inline">\(\{1,3,4,5,6,7,8,9\}\)</span> is shown below.</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst2.jpg" alt="image" style="width:2.5in" /></p></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">

<p><img src="/media/210/bsts/bst3.jpg" alt="image" style="width:1.8in" /></p></td>
</tr>
</tbody>
</table>
<p>On the left the <span class="math inline">\(L\)</span> and <span class="math inline">\(R\)</span> indicate the left (first) and right (second) child, respectively. All internal nodes (white) have a key associated with them while the leaves (black) are empty. The keys satisfy the BST property—for every node, the keys in the left subtree are less, and the ones in the right subtree are greater.</p>

<p>In the illustration on the left, the edges are oriented away from the root. They could have also been oriented towards the root. When illustrating binary search trees, we usually replace the directed arcs with undirected edges, leaving the orientation to be implicit. We also draw the left and right subtrees of a node on its left and right respectively. Following this convention, we can draw the tree on the left above as shown an the right. We use this convention in future figures.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An example binary search tree over the set of natural numbers
$\{1,3,4,5,6,7,8,9\}$ is shown below.

\begin{tabular}{ccc}
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=2.5in]{/media/210/bsts/bst2.jpg}
\end{minipage}
%
& \quad\quad\quad &
%
\vspace*{0in}
\begin{minipage}[t]{2.5in}
\vspace*{0in}
\includegraphics[width=1.8in]{/media/210/bsts/bst3.jpg}
\end{minipage}
\end{tabular}
On the left the $L$ and $R$ indicate the left (first) and right
(second) child, respectively.  All internal nodes (white) have a key
associated with them while the leaves (black) are empty.  The keys
satisfy the BST property---for every node, the keys in the left
subtree are less, and the ones in the right subtree are greater. 


\smallskip 

In the illustration on the left, the edges are oriented away from the
root. They could have also been oriented towards the root.
%
When illustrating binary search trees, we usually replace the directed
arcs with undirected edges, leaving the orientation to be implicit.
%
We also draw the left and right subtrees of a node on its left and
right respectively.
%
Following this convention, we can draw the tree on the left above as
shown an the right.
%
We use this convention in future figures.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
The BST Abstract Data Type
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The BST Abstract Data Type
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC3:sec:bst::adt
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}


...NO.INTRO...
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC3:UN3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The Abstract Data Type specification below describes an ADT for BSTs parametrized by a totally ordered key set. We briefly describe this ADT and present some examples. As we shall see, the BST ADT can be implemented in many ways. In order to present concrete examples, we assume an implementation but do not specify it.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The Abstract Data Type specification below describes an ADT for BSTs
parametrized by a totally ordered key set. We briefly describe this
ADT and present some examples. As we shall see, the BST ADT can be
implemented in many ways.  In order to present concrete examples, we
assume an implementation but do not specify it.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDatatype}
\begin{dilFieldTitle}
Binary Search Tree (BST)
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Binary Search Tree (BST)
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR2:AT1:adt:bst::adt
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>For a universe of totally ordered keys <span class="math inline">\({\mathbb{K}}\)</span>, the BST ADT consists of a type <span class="math inline">\({\mathbb{T}}\)</span> representing a power set of keys and the functions whose types are specified as follows.</p>
<p><span class="math display">\[\begin{array}{lcl} 
\texttt{empty} &amp; : &amp;{\mathbb{T}}
\\ 
% 
\texttt{singleton} &amp; : &amp; {\mathbb{K}}\rightarrow{\mathbb{T}}
\\ 
% 
\texttt{find} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{K}}\rightarrow{\mathbb{B}}
\\ 
% 
\texttt{delete} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{K}}\rightarrow{\mathbb{T}}
\\ 
\texttt{insert} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{K}}\rightarrow{\mathbb{T}}
\\ 
% 
\texttt{intersection} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{T}}\rightarrow{\mathbb{T}}
\\ 
% 
\texttt{difference} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{T}}\rightarrow{\mathbb{T}}
\\ 
% 
\texttt{union} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{T}}\rightarrow{\mathbb{T}}
\\ 
% 
\texttt{split} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{K}}\rightarrow({\mathbb{T}}\times {\mathbb{B}}\times {\mathbb{T}}) 
\\ 
\texttt{join} 
&amp; : &amp; {\mathbb{T}}\rightarrow{\mathbb{T}}\rightarrow{\mathbb{T}}
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
For a universe of totally ordered keys $\kkk$, the BST ADT
consists of a type $\bstt$ representing a power set of keys and the
functions whose types are specified as follows. 

\[
\begin{array}{lcl}
\texttt{empty} & : &\bstt
\\
%
\cd{singleton} & : & \kkk \ra \bstt
\\
%
\cd{find}
& : & \bstt \ra \kkk \ra \bbb
\\
%
\cd{delete}
& : & \bstt \ra \kkk \ra  \bstt
\\
\cd{insert}
& : & \bstt \ra \kkk \ra  \bstt
\\
%
\cd{intersection}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{difference}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{union}
& : & \bstt \ra \bstt \ra  \bstt
\\
%
\cd{split}
& : & \bstt \ra \kkk \ra (\bstt \times \bbb \times \bstt)
\\
\cd{join}
& : & \bstt \ra \bstt \ra \bstt 
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomDatatype}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The ADT supports two constructors: <span class="math inline">\(\texttt{empty}\)</span> creates an empty BST and <span class="math inline">\(\texttt{singleton}\)</span> creates a BST with a single key.</p>
<p>The function <span class="math inline">\(\texttt{find}\)</span> searches for a given key and returns a boolean indicating success.</p>
<p>The functions <span class="math inline">\(\texttt{insert}\)</span> and <span class="math inline">\(\texttt{delete}\)</span> insert and delete a given key into or from the BST.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The ADT supports two constructors: $\cd{empty}$ creates an empty BST
  and $\cd{singleton}$ creates a BST with a single key.
%

The function $\cd{find}$ searches for a given key and returns a
boolean indicating success.

The functions $\cd{insert}$ and $\cd{delete}$ insert and delete a
given key into or from the BST.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR3:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR3:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Searching in BSTs illustrated.</p>
<ul>
<li><p>Searching for <span class="math inline">\(5\)</span> in the input tree returns <span class="math inline">\(\texttt{true}.\)</span></p>
<p><span class="math inline">\(\texttt{find}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{5}\)</span> <span class="math inline">\(~=~\)</span> <span class="math inline">\(\texttt{true}\)</span></p></li>
<li><p>Searching for <span class="math inline">\(6\)</span> in the input tree returns <span class="math inline">\(\texttt{false}.\)</span></p>
<p><span class="math inline">\(\texttt{find}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{6}\)</span> <span class="math inline">\(~=~\)</span> <span class="math inline">\(\texttt{false}\)</span></p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Searching in BSTs illustrated.

\begin{itemize}
\item 
Searching for  $5$  in the input tree returns $\cd{true}.$

$\cd{find}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{5}$
$~=~$
$\cd{true}$

\item 
Searching for  $6$  in the input tree returns $\cd{false}.$
%

$\cd{find}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
$~=~$ 
$\cd{false}$

\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Insertion
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Insertion
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR3:AT3
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR3:AT3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Inserting the key <span class="math inline">\(6\)</span> into the input tree returns a new tree including <span class="math inline">\(6\)</span>.</p>
<p><span class="math inline">\(\texttt{insert}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{6}\)</span> = <img src="/media/210/bsts/bst5.jpg" alt="image" style="width:3cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Inserting the key $6$  into the input tree returns a new tree including $6$.
%

$\cd{insert}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
=
\includegraphics[width=3cm]{/media/210/bsts/bst5.jpg}

\end{dilFieldBodyDex}
\end{dilAtomExample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
Deletion
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Deletion
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR3:AT4
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR3:AT4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Deleting the key <span class="math inline">\(6\)</span> from the input tree returns a tree without it.</p>
<p><span class="math inline">\(\texttt{delete}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst5.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{6}\)</span> = <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Deleting the key  $6$ from the input tree returns a tree without it.
%

$\cd{delete}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst5.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
= 
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Union
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Union
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{union}\)</span> takes two BSTs and returns a BST that contains all the keys in them; <span class="math inline">\(\texttt{union}\)</span> is an aggregate insert operation. The function <span class="math inline">\(\texttt{intersection}\)</span> takes two BSTs and returns a BST that contains the keys common in both. The function <span class="math inline">\(\texttt{difference}\)</span> takes two BSTs <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> and returns a BST that contains the keys in <span class="math inline">\(t_1\)</span> that are not in <span class="math inline">\(t_2\)</span>; <span class="math inline">\(\texttt{difference}\)</span> is an aggregate delete operation.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{union}$ takes two BSTs and returns a BST that
contains all the keys in them; $\cd{union}$ is an aggregate insert
operation.
% 
The function $\cd{intersection}$ takes two BSTs and returns a BST
that contains the keys common in both.
% 
The function $\cd{difference}$ takes two BSTs $t_1$ and $t_2$ and returns
a BST that contains the keys in $t_1$ that are not in $t_2$;
$\cd{difference}$ is an aggregate delete operation.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Split
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Split
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{split}\)</span> takes a tree <span class="math inline">\(t\)</span> and a key <span class="math inline">\(k\)</span> and splits <span class="math inline">\(t\)</span> into two trees: one consisting of all the keys of <span class="math inline">\(t\)</span> less than <span class="math inline">\(k\)</span>, and another consisting of all the keys of <span class="math inline">\(t\)</span> greater than <span class="math inline">\(k\)</span>. It also returns a Boolean value indicating whether <span class="math inline">\(k\)</span> appears in <span class="math inline">\(t\)</span>. The exact structure of the trees returned by <span class="math inline">\(\texttt{split}\)</span> can differ from one implementation to another: the specification only requires that the resulting trees to be valid BSTs and that they contain the keys less than <span class="math inline">\(k\)</span> and greater than <span class="math inline">\(k\)</span>, leaving their structure otherwise unspecified.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{split}$ takes a tree $t$ and a key $k$ and
splits $t$ into two trees: one consisting of all the keys of $t$ less
than $k$, and another consisting of all the keys of $t$ greater than
$k$.  
%
It also returns a Boolean value indicating whether $k$ appears in $t$.
%
The exact structure of the trees returned by $\cd{split}$ can differ
from one implementation to another: the specification only requires
that the resulting trees to be valid BSTs and that they contain the
keys less than $k$ and greater than $k$, leaving their structure
otherwise unspecified.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR5:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR5:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{split}\)</span> illustrated.</p>
<ul>
<li><p>Splitting the input tree at <span class="math inline">\(6\)</span> yields two trees, consisting of the keys less that <span class="math inline">\(6\)</span> and those greater that <span class="math inline">\(6\)</span>, indicating also that <span class="math inline">\(6\)</span> is not in the input tree.</p>
<p><span class="math inline">\(\texttt{split}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{6}\)</span> <span class="math inline">\(~~=~~\)</span> <span class="math inline">\(\left(\\[1.5cm]\right.\)</span> <img src="/media/210/bsts/bst4a.jpg" alt="image" style="width:1cm" />  , <span class="math inline">\(\texttt{False}\)</span> ,   <img src="/media/210/bsts/bst4b.jpg" alt="image" style="width:2cm" /> <span class="math inline">\(\left.\\[1.5cm]\right)\)</span></p></li>
<li><p>Splitting the input tree at <span class="math inline">\(5\)</span> yields two trees, consisting of the keys less than <span class="math inline">\(5\)</span> and those greater than <span class="math inline">\(5\)</span>, indicating also that <span class="math inline">\(5\)</span> is found in the input tree.</p>
<p><span class="math inline">\(\texttt{split}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span>   <span class="math inline">\(\texttt{5}\)</span> <span class="math inline">\(~~=~~\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <span><img src="/media/210/bsts/bst4c.jpg" alt="image" style="width:7mm" /></span>  ,  <span class="math inline">\(\texttt{True}\)</span> ,   <span><img src="/media/210/bsts/bst4b.jpg" alt="image" style="width:2cm" /></span> <span class="math inline">\(\left.\\[2cm]\right)\)</span></p></li>
</ul>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{split}$ illustrated.

\begin{itemize}
\item 
Splitting the input tree at $6$ yields two trees, consisting of the
keys less that $6$ and those greater that $6$, indicating also that
$6$ is not in the input tree. 

$\cd{split}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{6}$
$~~=~~$
$\leftparen{1.5cm}$
\includegraphics[width=1cm]{/media/210/bsts/bst4a.jpg}~~,
$\cd{False}$~,~~
\includegraphics[width=2cm]{/media/210/bsts/bst4b.jpg}
$\rightparen{1.5cm}$

\item 
Splitting the input tree at $5$ yields two trees, consisting of the
keys less than $5$ and those greater than $5$, indicating also that
$5$ is found in the input tree. 

$\cd{split}$
$\leftparen{2cm}$
\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}
$\rightparen{2cm}$
~~$\cd{5}$
%
$~~=~~$
%
$\leftparen{2cm}$
{\includegraphics[width=7mm]{/media/210/bsts/bst4c.jpg}}~~,
~$\cd{True}$~,~~
{\includegraphics[width=2cm]{/media/210/bsts/bst4b.jpg}}
$\rightparen{2cm}$
\end{itemize}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC3:UN3:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Join
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Join
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{join}\)</span> takes two trees <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> such that all the keys in <span class="math inline">\(t_1\)</span> are less than the keys in <span class="math inline">\(t_2\)</span>. The function returns a tree that contains all the keys in <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span>. The exact structure of the tree returned by <span class="math inline">\(\texttt{join}\)</span> can differ from one implementation to another: the specification only requires that the resulting tree is a valid BST and that it contains all the keys in the trees joined.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{join}$ takes two trees $t_1$ and $t_2$
such that all the keys in $t_1$ are less than the keys in $t_2$.  The
function returns a tree that contains all the keys in $t_1$ and $t_2$.
%
The exact structure of the tree returned by $\cd{join}$ can differ
from one implementation to another: the specification only requires
that the resulting tree is a valid BST and that it contains all the
keys in the trees joined.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC3:UN3:GR6:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC3:UN3:GR6:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The function <span class="math inline">\(\texttt{join}\)</span> illustrated.</p>
<p><span class="math inline">\(\texttt{join}\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <img src="/media/210/bsts/bst4a.jpg" alt="image" style="width:1cm" /> <span class="math inline">\(\left.\\[2cm]\right)\)</span> <span class="math inline">\(\left(\\[2cm]\right.\)</span> <span><img src="/media/210/bsts/bst6.jpg" alt="image" style="width:3cm" /></span> <span class="math inline">\(\left.\\[2cm]\right)\)</span> <span class="math inline">\(~~=~~\)</span> <span><img src="/media/210/bsts/bst4.jpg" alt="image" style="width:3cm" /></span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The function $\cd{join}$ illustrated.

$\cd{join}$
$\leftparen{2cm}$
\includegraphics[width=1.0cm]{/media/210/bsts/bst4a.jpg}
$\rightparen{2cm}$
%
$\leftparen{2cm}$
{\includegraphics[width=3cm]{/media/210/bsts/bst6.jpg}}
$\rightparen{2cm}$
%
$~~=~~$
%
{\includegraphics[width=3cm]{/media/210/bsts/bst4.jpg}}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Implementation via Balancing
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Implementation via Balancing
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC4:sec:bst::bsts-review
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}


...NO.INTRO...
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC4:UN4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
The Main Ideas
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
The Main Ideas
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The key idea behind the implementation of BSTs is to organize the keys to facilitate</p>
<ol>
<li><p>finding a key by following a branch in the tree, performing key comparisons along the way, and</p></li>
<li><p>moving the keys that together form a contiguous range in the sorted ordering of the keys in the tree by performing constant work.</p></li>
</ol>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The key idea behind the implementation of BSTs is to organize the
keys to facilitate
\begin{enumerate}
\item
finding a key by following a branch in the tree, performing key
comparisons along the way, and

\item moving the keys that together form a contiguous range in the
  sorted ordering of the keys in the tree by performing constant work.
\end{enumerate}

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Searching a Tree
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Searching a Tree
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To see how we can search in a tree, consider searching for a key <span class="math inline">\(k\)</span> in a tree <span class="math inline">\(t\)</span> whose root is <span class="math inline">\(r\)</span>. We can start at the root <span class="math inline">\(r\)</span> and if <span class="math inline">\(k\)</span> equals the key at the root, <span class="math inline">\(k(r)\)</span>, then we have found our key, otherwise if <span class="math inline">\(k &lt; k(r)\)</span>, then we know that <span class="math inline">\(k\)</span> cannot appear in the right subtree, so we only need to search the left subtree, and if <span class="math inline">\(k &gt; k(r)\)</span>, then we only have to search the right subtree. Continuing the search, we will either find the key or reach a leaf and conclude that the key is not in the tree. In both cases we have followed a single path through the BST starting at the root.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To see how we can search in a tree, consider searching for a key $k$
in a tree $t$ whose root is $r$.
%
We can start at the root $r$ and if $k$ equals the key at the root,
$k(r)$, then we have found our key, otherwise if $k < k(r)$, then we
know that $k$ cannot appear in the right subtree, so we only need to
search the left subtree, and if $k > k(r)$, then we only have to
search the right subtree.  Continuing the search, we will either find
the key or reach a leaf and conclude that the key is not in the tree.
%
In both cases we have followed a single path through the BST starting
at the root.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR2:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR2:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A successful search for <span class="math inline">\(7\)</span> and an unsuccessful search for <span class="math inline">\(4\)</span> in the given tree. Search paths are highlighted.</p>
<p><img src="/media/210/bsts/bst5-search-7.jpg" alt="image" style="width:3cm" />  <img src="/media/210/bsts/bst5-search-4.jpg" alt="image" style="width:3cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A successful search for $7$ and an unsuccessful search for $4$ in the
given tree.  Search paths are highlighted.

\begin{center}
\includegraphics[width=3cm]{/media/210/bsts/bst5-search-7.jpg}\
%
\hspace*{3cm}
%
\includegraphics[width=3cm]{/media/210/bsts/bst5-search-4.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Operating on Ranges
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Operating on Ranges
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To see how we can operate on a range of keys, note first that each subtree in a binary tree contains all the keys that are within a specific range. We can find such a range by performing a search as described—in fact, a search as described identifies a possibly empty range. Once we find a range of keys, we can operate on them as a group by handling their root. For example, we can move the whole subtree to another location by linking the root to another parent.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To see how we can operate on a range of keys, note first that each
subtree in a binary tree contains all the keys that are within a
specific range. 
%
We can find such a range by performing a search as
described---in fact, a search as described identifies a possibly empty
range. Once we find a range of keys, we can operate on them as a group
by handling their root.
%
For example, we can move the whole subtree to another location by
linking the root to another parent.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR3:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR3:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider the tree shown below on the left, we can handle all the keys that are less than <span class="math inline">\(8\)</span> by holding the subtree rooted at <span class="math inline">\(5\)</span>, the left child of <span class="math inline">\(8\)</span>. For example, we can make <span class="math inline">\(5\)</span> the left child of <span class="math inline">\(9\)</span> and delete <span class="math inline">\(8\)</span> from the tree. Note that if <span class="math inline">\(8\)</span> remains in the tree, the resulting tree would not be a valid BST.</p>
<p><img src="/media/210/bsts/bst5-search-5.jpg" alt="image" style="width:3cm" /></p>
<p><img src="/media/210/bsts/bst5-move-5.jpg" alt="image" style="width:2.5cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider the tree shown below on the left, we can handle all the keys
that are less than $8$ by holding the subtree rooted at $5$, the left
child of $8$.  For example, we can make $5$ the left child of $9$ and
delete $8$ from the tree. Note that if $8$ remains in the tree, the
resulting tree would not be a valid BST.

\begin{center}
\begin{minipage}[t]{10cm}
\begin{minipage}[t]{3cm}
\includegraphics[width=3cm]{/media/210/bsts/bst5-search-5.jpg}
\end{minipage}
%
%\hspace{3cm}
%
\begin{minipage}[t]{3cm}
\includegraphics[width=2.5cm]{/media/210/bsts/bst5-move-5.jpg}
\end{minipage}
\end{minipage}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Balancing
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Balancing
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>By finding a range of keys by traversing a path in the BST, and by moving ranges with constant work, it turns out to be possible to implement all the operations in the BST ADT efficiently as long as the paths traversed are not too long. To guarantee the absence of long paths, we can make sure that the tree remains balanced, i.e., the longest paths have approximately the same length.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
By finding a range of keys by traversing a path in the BST, and by
moving ranges with constant work, it turns out to be possible to
implement all the operations in the BST ADT efficiently as long as the
paths traversed are not too long.
%
To guarantee the absence of long paths, we can make sure that the tree
remains balanced, i.e., the longest paths have approximately the same
length.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Perfectly Balanced BSTs
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Perfectly Balanced BSTs
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A binary tree is  <span style="color: black"><span><strong><em>perfectly balanced</em></strong></span></span> if it has the minimum possible height. For a binary search tree with <span class="math inline">\(n\)</span> keys, a perfectly balanced tree has height exactly <span class="math inline">\(\lceil \lg (n + 1) \rceil\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A binary tree is~\defn{perfectly balanced} if it has the
minimum possible height.  
%
For a binary search tree with $n$ keys, a perfectly balanced tree has
height exactly $\lceil \lg (n + 1) \rceil$.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Ideally we would like to use only perfectly balanced trees. If we never make changes to the tree, we could balance it once and for all. If, however, we want to update the tree by, for example, inserting new keys, then maintaining such perfect balance is costly. In fact, it turns out to be impossible to maintain a perfectly balanced tree while allowing insertions in <span class="math inline">\(O(\lg n)\)</span> work. BST data structures therefore aim to keep approximate balance instead of a perfect one.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Ideally we would like to use only perfectly balanced trees.  
%
If we never make changes to the tree, we could balance it
once and for all.
%
If, however, we want to update the tree by, for example, inserting new
keys, then maintaining such perfect balance is costly.  
%
In fact, it turns out to be impossible to maintain a perfectly
balanced tree while allowing insertions in $O(\lg n)$ work.  
%
BST data structures therefore aim to keep approximate balance instead
of a perfect one.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Nearly Balanced BSTs
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Nearly Balanced BSTs
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We refer to a BST data structure as  <span style="color: black"><span><strong><em>nearly balanced</em></strong></span></span> or simply as  <span style="color: black"><span><strong><em>balanced</em></strong></span></span> if all trees with <span class="math inline">\(n\)</span> elements have height <span class="math inline">\(O(\lg 
n)\)</span>, perhaps in expectation or with high probability.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We refer to a BST data structure as~\defn{nearly balanced} or simply
as~\defn{balanced} if all trees with $n$ elements have height $O(\lg
n)$, perhaps in expectation or with high probability.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Balanced BST Data Structures
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Balanced BST Data Structures
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>There are many balanced BST data structures. Most either try to maintain height balance (the children of a node are about the same height) or weight balance (the children of a node are about the same size). Here we list a few such data structures:</p>
<ol>
<li><p><span style="color: black"><span><strong><em>AVL trees</em></strong></span></span> are the earliest nearly balanced BST data structure (1962). It maintains the invariant that the two children of each node differ in height by at most one, which in turn implies approximate balance.</p></li>
<li><p><span style="color: black"><span><strong><em>Red-Black trees</em></strong></span></span> maintain the invariant that all leaves have a depth that is within a factor of 2 of each other. The depth invariant is ensured by a scheme of coloring the nodes red and black.</p></li>
<li><p><span style="color: black"><span><strong><em>Weight balanced (BB[<span class="math inline">\(\alpha\)</span>]) trees</em></strong></span></span> maintain the invariant that the left and right subtrees of a node of size <span class="math inline">\(n\)</span> each have size at least <span class="math inline">\(\alpha n\)</span> for <span class="math inline">\(0 &lt; \alpha \leq 
  1 - \frac{1}{\sqrt{2}}\)</span>. The BB stands for bounded balance, and adjusting <span class="math inline">\(\alpha\)</span> gives a tradeoff between search and update costs.</p></li>
<li><p><span style="color: black"><span><strong><em>Treaps</em></strong></span></span> associate a random priority with every key and maintain the invariant that the keys are stored in heap order with respect to their priorities (the term “Treap” is short for “tree heap”). Treaps guarantee approximate balance with high-probability.</p></li>
<li><p><span style="color: black"><span><strong><em>Splay trees</em></strong></span></span> are an amortized data structure that does not guarantee approximate balance, but instead guarantees that for any sequence of <span class="math inline">\(m\)</span> insert, find and delete operations each does <span class="math inline">\(O(\lg n)\)</span> amortized work.</p></li>
</ol>
<p>There are dozens of other balanced BST data structures (e.g. scapegoat trees and skip lists), as well as many that allow larger degrees, including 2–3 trees, brother trees, and B trees.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
There are many balanced BST data structures.  Most either try to
maintain height balance (the children of a node are about the same
height) or weight balance (the children of a node are about the same
size).  Here we list a few such data structures:

\begin{enumerate}
\item \defn{AVL trees} are the earliest nearly balanced BST data
  structure (1962).  It maintains the invariant that the two children
  of each node differ in height by at most one, which in turn implies
  approximate balance.

\item \defn{Red-Black trees} maintain the invariant that all leaves
  have a depth that is within a factor of 2 of each other.  The depth
  invariant is ensured by a scheme of coloring the nodes red and
  black.

\item \defn{Weight balanced (BB[$\alpha$]) trees} maintain the
  invariant that the left and right subtrees of a node of size $n$
  each have size at least $\alpha n$ for $0 < \alpha \leq
  1 - \frac{1}{\sqrt{2}}$.  The BB stands for bounded balance, and adjusting
  $\alpha$ gives a tradeoff between search and update costs.

\item \defn{Treaps} associate a random priority with every key and
  maintain the invariant that the keys are stored in heap order with
  respect to their priorities (the term ``Treap'' is short for ``tree
  heap'').  Treaps guarantee approximate balance with
  high-probability.

\item \defn{Splay trees} are an amortized data structure that does not
  guarantee approximate balance, but instead guarantees that for any sequence
  of $m$ insert, find and delete operations each does $O(\lg n)$
  amortized work.
\end{enumerate}
There are dozens of other balanced BST data structures (e.g. scapegoat
trees and skip lists), as well as many that allow larger degrees,
including 2--3 trees, brother trees, and B trees.  
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR9:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Many of the existing BST data structures were developed for sequential computing. Some of these data structures such as Treaps, which we describe here, generalize naturally to parallel computing. But some others, such as data structures that rely on amortization techniques can be challenging to support in the parallel setting.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Many of the existing BST data structures were developed for sequential
computing.   
%
Some of these data structures such as Treaps, which we describe here,
generalize naturally to parallel computing. 
%
But some others, such as data structures that rely on amortization
techniques can be challenging to support in the parallel setting.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC4:UN4:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC4:UN4:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC4:UN4:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Bob Harper comment: misleading discussion? pages 226-227 the discussion of splay trees, etc ignores the important issue of single-threaded vs multi-threaded data structures; amortization doesn’t work for the multithreaded case. do the treaps work for that case?</p>
<p>It might indeed be worthwhile to discuss the weakness of amortization with respect to persistence. Though this seems a bit advanced for this material. Further thought is needed...</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Bob Harper comment:
misleading discussion? pages 226-227 the discussion of splay trees,
etc ignores the important issue of single-threaded vs multi-threaded
data structures; amortization doesn't work for the multithreaded case.
do the treaps work for that case?

It might indeed be worthwhile to discuss the weakness of amortization
with respect to persistence.  Though this seems a bit advanced for
this material.  Further thought is needed...

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
A Parametric Implementation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
A Parametric Implementation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC5:sec:bst::parametric
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>We describe a minimalist implementation of the BST ADT based on two functions, <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>. Since the implementation depends on just these two functions, we refer to it as a parametric implementation.</p>

\end{dilIntro}
\begin{dilIntroDex}


We describe a minimalist implementation of the BST ADT based on two
functions, $\cd{split}$ and $\cd{join}$. 
%
Since the implementation depends on just these two functions, we refer
to it as a parametric implementation.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC5:UN5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC5:UN5:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Implementing the BST ADT with <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Implementing the BST ADT with $\cd{split}$ and $\cd{join}$
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR1:AT1:ds:bst::parametric
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; \texttt{type ${\mathbb{T}}$ = Leaf | Node of (${\mathbb{T}}$ $\times$ ${\mathbb{K}}$ $\times$ ${\mathbb{T}}$)} 
\\ 
&amp; 
\\ 
2 &amp; \texttt{split $t$ $k$ = ... (* as given *)} 
\\ 
&amp; 
\\ 
3 &amp; \texttt{join $t_1$ $t_2$ = ... (* as given *)} 
\\ 
&amp; 
\\ 
4 &amp; \texttt{joinM $t_1$ $k$ $t_2$ = join $t_1$ (join (singleton $k$) $t_2$)} 
\\ 
&amp; 
\\ 
5 &amp; \texttt{empty = Leaf} 
\\ 
&amp; 
\\ 
6 &amp; \texttt{singleton $(k)$ = Node(Leaf,$k$,Leaf)  } 
\\ 
&amp; 
\\ 
7 &amp; \texttt{find $t$ $k$ = let (_,$v$,_) = split $t$ $k$  in $v$ end } 
\\ 
&amp; 
\\ 
8 &amp; \texttt{delete $t$ $k$ = let $(l,\_,r)$ = split $t$ $k$ in join $l$ $r$ end} 
\\ 
&amp; 
\\ 
9 &amp; \texttt{insert $t$ $k$ = let $(l,\_,r)$ = split $t$ $k$ in joinM $l$ $k$ $r$ end } 
\\ 
&amp; 
\\ 
10 &amp; \texttt{intersect $t_1$ $t_2$ =} 
\\ 
11 &amp; ~~\texttt{case ($t_1$,$t_2$) } 
\\ 
12 &amp; ~~\texttt{| (Leaf,_) $\Rightarrow$ Leaf} 
\\ 
13 &amp; ~~\texttt{| (_,Leaf) $\Rightarrow$ Leaf} 
\\ 
14 &amp; ~~\texttt{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$ } 
\\ 
15 &amp; ~~~~\texttt{let $(l_2,b,r_2)$ = split $t_2$ $k_1$} 
\\ 
16 &amp; ~~~~~~~\texttt{$(l,r)$ = (intersect $l_1$ $l_2$) || (intersect $r_1$ $r_2$)} 
\\ 
17 &amp; ~~~~\texttt{in if $b$ then joinM $l$ $k_1$ $r$ else join $l$ $r$ end} 
\\ 
&amp; 
\\ 
18 &amp; \texttt{difference $t_1$ $t_2$ =} 
\\ 
19 &amp; ~~\texttt{case ($t_1$, $t_2$)} 
\\ 
20 &amp; ~~\texttt{| (Leaf,_) $\Rightarrow$ Leaf} 
\\ 
21 &amp; ~~\texttt{| (_,Leaf) $\Rightarrow$ $t_1$} 
\\ 
22 &amp; ~~\texttt{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$ } 
\\ 
23 &amp; ~~~~\texttt{let $(l_2,b,r_2)$ = split $t_2$ $k_1$} 
\\ 
24 &amp; ~~~~~~~~\texttt{$(l,r)$ = (difference $l_1$ $l_2$) || (difference $r_1$ $r_2$)} 
\\ 
25 &amp; ~~~~\texttt{in if $b$ then join $l$ $r$ else joinM $L$ $k_1$ $r$ end} 
\\ 
&amp; 
\\ 
26 &amp; \texttt{union $t_1$ $t_2$ =} 
\\ 
27 &amp; ~~\texttt{case ($t_1$,$t_2$)} 
\\ 
28 &amp; ~~\texttt{| (Leaf,_) $\Rightarrow$ $t_2$} 
\\ 
29 &amp; ~~\texttt{| (_,Leaf) $\Rightarrow$ $t_1$} 
\\ 
30 &amp; ~~\texttt{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$   } 
\\ 
31 &amp; ~~~~\texttt{let $(l_2,\_,r_2)$ = split $t_2$ $k_1$} 
\\ 
32 &amp; ~~~~~~~~\texttt{$(l,r)$ = (union $l_1$ $l_2$) || (union $r_1$ $r_2$)} 
\\ 
33 &amp; ~~~~\texttt{in joinM $l$ $k_1$ $r$ end    } 
\\ 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
\begin{array}{ll}
1 & \cd{type $\tttt$ = Leaf | Node of ($\tttt$ $\times$ $\kkk$ $\times$ $\tttt$)}
\\
&
\\
2 & \cd{split $t$ $k$ = ... (* as given *)}
\\
&
\\
3 & \cd{join $t_1$ $t_2$ = ... (* as given *)}
\\
&
\\
4 & \cd{joinM $t_1$ $k$ $t_2$ = join $t_1$ (join (singleton $k$) $t_2$)}
\\
&
\\
5 & \cd{empty = Leaf}
\\
&
\\
6 & \cd{singleton $(k)$ = Node(Leaf,$k$,Leaf)  }
\\
&
\\
7 & \cd{find $t$ $k$ = let (_,$v$,_) = split $t$ $k$  in $v$ end }
\\
&
\\
8 & \cd{delete $t$ $k$ = let $(l,\_,r)$ = split $t$ $k$ in join $l$ $r$ end}
\\
&
\\
9 & \cd{insert $t$ $k$ = let $(l,\_,r)$ = split $t$ $k$ in joinM $l$ $k$ $r$ end }
\\
&
\\
10 & \cd{intersect $t_1$ $t_2$ =}
\\
11 & ~~\cd{case ($t_1$,$t_2$) }
\\
12 & ~~\cd{| (Leaf,_) $\Rightarrow$ Leaf}
\\
13 & ~~\cd{| (_,Leaf) $\Rightarrow$ Leaf}
\\
14 & ~~\cd{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$ }
\\
15 & ~~~~\cd{let $(l_2,b,r_2)$ = split $t_2$ $k_1$}
\\
16 & ~~~~~~~\cd{$(l,r)$ = (intersect $l_1$ $l_2$) || (intersect $r_1$ $r_2$)}
\\
17 & ~~~~\cd{in if $b$ then joinM $l$ $k_1$ $r$ else join $l$ $r$ end}
\\
&
\\
18 & \cd{difference $t_1$ $t_2$ =}
\\
19 & ~~\cd{case ($t_1$, $t_2$)}
\\
20 & ~~\cd{| (Leaf,_) $\Rightarrow$ Leaf}
\\
21 & ~~\cd{| (_,Leaf) $\Rightarrow$ $t_1$}
\\
22 & ~~\cd{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$ }
\\
23 & ~~~~\cd{let $(l_2,b,r_2)$ = split $t_2$ $k_1$}
\\
24 & ~~~~~~~~\cd{$(l,r)$ = (difference $l_1$ $l_2$) || (difference $r_1$ $r_2$)}
\\
25 & ~~~~\cd{in if $b$ then join $l$ $r$ else joinM $L$ $k_1$ $r$ end}
\\
&
\\
26 & \cd{union $t_1$ $t_2$ =}
\\
27 & ~~\cd{case ($t_1$,$t_2$)}
\\
28 & ~~\cd{| (Leaf,_) $\Rightarrow$ $t_2$}
\\
29 & ~~\cd{| (_,Leaf) $\Rightarrow$ $t_1$}
\\
30 & ~~\cd{| (Node $(l_1,k_1,r_1)$,_) $\Rightarrow$   }
\\
31 & ~~~~\cd{let $(l_2,\_,r_2)$ = split $t_2$ $k_1$}
\\
32 & ~~~~~~~~\cd{$(l,r)$ = (union $l_1$ $l_2$) || (union $r_1$ $r_2$)}
\\
33 & ~~~~\cd{in joinM $l$ $k_1$ $r$ end    }
\\
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC5:UN5:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The implementation given above assumes that the implementation of <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> are supplied.</p>
<p>The implementation defines the tree type as consisting of leaves or internal nodes with left and right subtrees and a key.</p>
<p>The auxiliary function, <span class="math inline">\(\texttt{joinM}\)</span> takes two trees <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> and a “middle” key <span class="math inline">\(k\)</span> that is sandwiched between the two trees—that is <span class="math inline">\(k\)</span> is greater than all the keys in <span class="math inline">\(t_1\)</span> and less than all the keys in <span class="math inline">\(t_2\)</span>—and returns a tree that contains all the keys in <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> as well as <span class="math inline">\(k\)</span>.</p>
<p>The function <span class="math inline">\(\texttt{find}\)</span> is easily implementable with a <span class="math inline">\(\texttt{split}\)</span>, which indicates whether the key used for splitting is found in the tree or not. To implement <span class="math inline">\(\texttt{insert}\)</span> of a key <span class="math inline">\(k\)</span> into a tree, we first <span class="math inline">\(\texttt{split}\)</span> the tree at <span class="math inline">\(k\)</span> and then join the two returned trees along with key <span class="math inline">\(k\)</span> using <span class="math inline">\(\texttt{joinM}.\)</span> To implement <span class="math inline">\(\texttt{delete}\)</span> of a key <span class="math inline">\(k\)</span> from a tree, we first <span class="math inline">\(\texttt{split}\)</span> the tree at <span class="math inline">\(k\)</span> and then join the two returned trees with <span class="math inline">\(\texttt{join}\)</span>. If the key <span class="math inline">\(k\)</span> was found, this gives us a tree that does not contain the <span class="math inline">\(k\)</span>; otherwise we obtain a tree of the same set of keys (though the structure of the tree may be different internally depending on the implementation of <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>).</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The implementation given above assumes that the implementation of
$\cd{split}$ and $\cd{join}$ are supplied.
%
%\dsref{...}
%

The implementation defines the tree type as consisting of
leaves or internal nodes with left and right subtrees and a key.
%

The auxiliary function, $\cd{joinM}$ takes two trees $t_1$ and $t_2$
and a ``middle'' key $k$ that is sandwiched between the two
trees---that is $k$ is greater than all the keys in $t_1$ and less
than all the keys in $t_2$---and returns a tree that contains all the
keys in $t_1$ and $t_2$ as well as $k$.


The function $\cd{find}$ is easily implementable with a
$\cd{split}$, which indicates whether the key used for splitting is
found in the tree or not.
%
To implement $\cd{insert}$ of a key $k$ into a tree, we first
$\cd{split}$ the tree at $k$ and then join the two returned
trees along with key $k$ using $\cd{joinM}.$
%
To implement $\cd{delete}$ of a key $k$ from a tree, we first
$\cd{split}$ the tree at $k$ and then join the two returned
trees with $\cd{join}$. 
%
If the key $k$ was found, this gives us a tree that does not contain
the $k$; otherwise we obtain a tree of the same set of keys (though
the structure of the tree may be different internally depending on the
implementation of $\cd{split}$ and $\cd{join}$).

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC5:UN5:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Union
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Union
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The implementation of <span class="math inline">\(\texttt{union}\)</span> uses divide and conquer. The idea is to split both trees at some key <span class="math inline">\(k\)</span>, recursively union the two parts with keys less than <span class="math inline">\(k\)</span>, and the two parts with keys greater than <span class="math inline">\(k\)</span> and then join them. There are different ways to select the key <span class="math inline">\(k\)</span> used to split the tree. One way is to use the key at the root of one of the two trees, for example the first tree, and split the second tree with it; this is the approach take in the parametric implementation.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The implementation of $\cd{union}$ uses divide and conquer.  The idea is
to split both trees at some key $k$, recursively union the two parts
with keys less than $k$, and the two parts with keys greater than $k$
and then join them.  
%
There are different ways to select the key $k$ used to split the tree.
%
One way is to use the key at the root of one of the two trees, for
example the first tree, and split the second tree with it; this is the
approach take in the parametric implementation.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR3:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR3:AT2:example:tree-union
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The union of tree <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> illustrated.</p>
<p><img src="/media/210/bsts/union-dia1.jpg" alt="image" style="width:14cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The union of tree $t_1$ and $t_2$ illustrated.

\begin{center}
  \includegraphics[width=14cm]{/media/210/bsts/union-dia1.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC5:UN5:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Intersection
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Intersection
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The implementation of <span class="math inline">\(\texttt{intersection}\)</span> uses a divide-and-conquer approach similar to that of <span class="math inline">\(\texttt{union}\)</span>. As in <span class="math inline">\(\texttt{union}\)</span>, we split both trees by using the key <span class="math inline">\(k_1\)</span> at the root of the first tree, and compute intersections recursively. We then compute the result by joining the results from the recursive calls and including the key <span class="math inline">\(k_1\)</span> if it is found in both trees.</p>
<p>How does the implementation accounts for all possible shared keys when we divide the input trees into two and calculate intersections recursively? What if a key on the left matches a key on the right half of the other tree?</p>
<p>Note that since the trees are BSTs, checking for the intersections of left and right subtrees recursively and is guaranteed to find all shared keys because the <span class="math inline">\(\texttt{split}\)</span> operation places all keys less than and greater than the given key to two separate trees.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The implementation of $\cd{intersection}$ uses a divide-and-conquer
approach similar to that  of $\cd{union}$.  
%
As in $\cd{union}$, we split both trees by using the key $k_1$ at the
root of the first tree, and compute intersections recursively.
%
We then compute the result by joining the results from the recursive
calls and including the key $k_1$ if it is found in both trees.
%
\begin{teachask}
How does the implementation accounts for all possible shared keys when
we divide the input trees into two and calculate intersections
recursively?  What if a key on the left matches a key on the right
half of the other tree?
\end{teachask}
%
Note that since the trees are BSTs, checking for the intersections of
left and right subtrees recursively and is guaranteed to find all
shared keys because the $\cd{split}$ operation places all keys less
than and greater than the given key to two separate trees.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC5:UN5:GR4:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC5:UN5:GR4:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Prove correct the functions <span class="math inline">\(\texttt{intersection}\)</span>, <span class="math inline">\(\texttt{difference}\)</span>, and <span class="math inline">\(\texttt{union}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Prove correct the functions $\cd{intersection}$, $\cd{difference}$, and
  $\cd{union}$.

\end{dilFieldBodyDex}
\end{dilAtomExercise}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Cost Specification
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Cost Specification
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC6:sec:bst::cost
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>...NO.INTRO...</p>

\end{dilIntro}
\begin{dilIntroDex}


...NO.INTRO...
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC6:UN6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN6:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN6:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>There are many ways to implement an efficient data structure that matches our BST ADT, many of these implementation more or less match the same cost specification, with the main difference being whether the bounds are worst-case, expected case (probabilistic), or amortized. These implementations all use balancing techniques to ensure that the depth of the BST remains <span class="math inline">\(O(\lg{n})\)</span>, where <span class="math inline">\(n\)</span> is the number of keys in the tree. For the purposes specifying the costs, we don’t distinguish between worst-case, amortized, and probabilistic bounds, because we can always rely on the existence of an implementation that matches the desired cost specification. When using specific data structures that match the specified bounds in an amortized or randomized sense, we will try to be careful when specifying the bounds.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
There are many ways to implement an efficient data structure that
matches our BST ADT, many of these implementation more or less match
the same cost specification, with the main difference being whether
the bounds are worst-case, expected case (probabilistic), or
amortized.  
%
These implementations all use balancing techniques to ensure that the
depth of the BST remains $O(\lg{n})$, where $n$ is the number of keys
in the tree.  
%
For the purposes specifying the costs, we don't distinguish between
worst-case, amortized, and probabilistic bounds, because we can always
rely on the existence of an implementation that matches the desired
cost specification.  
%
When using specific data structures that match the specified bounds in
an amortized or randomized sense, we will try to be careful when
specifying the bounds.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN6:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomCostSpec}
\begin{dilFieldTitle}
BSTs
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
BSTs
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN6:GR2:AT1:cost:bst::costs
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The  <span style="color: black"><span><strong><em>BST</em></strong></span></span> cost specification is defined as follows. The variables <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> are defined as <span class="math inline">\(n = \max{(|t_1|,|t_2|)}\)</span> and <span class="math inline">\(m = \min{(|t_1|,|t_2|)}\)</span> when applicable. <span class="math display">\[\begin{array}{l@{\qquad}c@{\qquad}c@{\qquad}} 
&amp; \mathbf{Work} &amp; \mathbf{Span} 
\\  
 
\texttt{empty} 
&amp; O\left({1}\right) 
&amp; O\left({1}\right) 
\\  
 
\texttt{singleton}~k 
&amp; O\left({1}\right) 
&amp; O\left({1}\right) 
\\  
 
\texttt{split}~t~k 
&amp; O\left({\lg{|t|}}\right) 
&amp; O\left({\lg{|t|}}\right) 
\\  
 
\texttt{join}~t_1~t_2 
&amp; O\left({\lg{\left(|t_1|+|t_2|\right)}}\right) 
&amp; O\left({\lg{\left(|t_1|+|t_2|\right)}}\right) 
\\  
 
\texttt{find}~t~k 
&amp; O\left({\lg{|t|}}\right) 
&amp; O\left({\lg{|t|}}\right) 
\\  
 
\texttt{insert}~t~k 
&amp; O\left({\lg{|t|}}\right) 
&amp; O\left({\lg{|t|}}\right) 
\\  
 
\texttt{delete}~t~k 
&amp; O\left({\lg{|t|}}\right) 
&amp; O\left({\lg{|t|}}\right) 
\\  
 
\texttt{intersect}~t_1~t_2 
&amp; O\left({m \cdot \lg{\frac{n+m}{m}}}\right) 
&amp; O\left({\lg{n}}\right) 
\\  
 
\texttt{difference}~t_1~t_2 
&amp; O\left({m \cdot \lg{\frac{n+m}{m}}}\right) 
&amp; O\left({\lg{n}}\right) 
\\  
 
\texttt{union}~t_1~t_2 
&amp; O\left({m \cdot \lg{\frac{n+m}{m}}}\right) 
&amp; O\left({\lg{n}}\right) 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The~\defn{BST} cost specification is defined as follows.  The
  variables $n$ and $m$ are defined as $n = \max{(|t_1|,|t_2|)}$ and
  $m = \min{(|t_1|,|t_2|)}$ when applicable.
%  \setlength{\extrarowheight}{1ex}
\[
\begin{array}{l@{\qquad}c@{\qquad}c@{\qquad}}
& \mathbf{Work} & \mathbf{Span}
\\ 

\cd{empty}
& \bigoh{1}
& \bigoh{1}
\\ 

\cd{singleton}~k
& \bigoh{1}
& \bigoh{1}
\\ 

\cd{split}~t~k
& \bigoh{\lg{|t|}}
& \bigoh{\lg{|t|}}
\\ 

\cd{join}~t_1~t_2
& \bigoh{\lg{\left(|t_1|+|t_2|\right)}}
& \bigoh{\lg{\left(|t_1|+|t_2|\right)}}
\\ 

\cd{find}~t~k
& \bigoh{\lg{|t|}}
& \bigoh{\lg{|t|}}
\\ 

\cd{insert}~t~k
& \bigoh{\lg{|t|}}
& \bigoh{\lg{|t|}}
\\ 

\cd{delete}~t~k
& \bigoh{\lg{|t|}}
& \bigoh{\lg{|t|}}
\\ 

\cd{intersect}~t_1~t_2
& \bigoh{m \cdot \lg{\frac{n+m}{m}}}
& \bigoh{\lg{n}}
\\ 

\cd{difference}~t_1~t_2
& \bigoh{m \cdot \lg{\frac{n+m}{m}}}
& \bigoh{\lg{n}}
\\ 

\cd{union}~t_1~t_2
& \bigoh{m \cdot \lg{\frac{n+m}{m}}}
& \bigoh{\lg{n}}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomCostSpec}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN6:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN6:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN6:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The cost specification above shows the costs for the BST ADT as can be realized by several balanced BST data structures such as Treaps (in expectation), red-black trees (in the worst case), and splay trees (amortized). As may be expected the cost of <span class="math inline">\(\texttt{empty}\)</span> and <span class="math inline">\(\texttt{singleton}\)</span> are constant.</p>
<p>For the rest of the operations, we justify the cost bounds by assuming the existence of logarithmic time <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations, and by using our parametric implementation described above. The work and span costs of <span class="math inline">\(\texttt{find}\)</span>, <span class="math inline">\(\texttt{insert},\)</span> and <span class="math inline">\(\texttt{delete}\)</span> are determined by the <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operation and are thus logarithmic in the size of the tree.</p>
<p>The cost bounds on <span class="math inline">\(\texttt{union}\)</span>, <span class="math inline">\(\texttt{intersection}\)</span>, and <span class="math inline">\(\texttt{difference}\)</span>, which are similar are more difficult to see.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The cost specification above shows the costs for the BST ADT as can be
realized by several balanced BST data structures such as Treaps (in
expectation), red-black trees (in the worst case), and splay trees
(amortized). As may be expected the cost of $\cd{empty}$ and
$\cd{singleton}$ are constant.
%

For the rest of the operations, we justify the cost bounds by assuming
the existence of logarithmic time $\cd{split}$ and $\cd{join}$ operations,
and by using our parametric implementation described above.
%
The work and span costs of $\cd{find}$, $\cd{insert},$ and
$\cd{delete}$ are determined by the $\cd{split}$ and $\cd{join}$
operation and are thus logarithmic in the size of the tree.
%

The cost bounds on $\cd{union}$, $\cd{intersection}$, and
$\cd{difference}$, which are similar are more difficult to see.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Cost of Union, Intersection, and Difference
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Cost of Union, Intersection, and Difference
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC6:UN7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Let’s analyze the cost for <span class="math inline">\(\texttt{union}\)</span> as implemented by the parametric implementation. It is easy to apply a similar analysis to <span class="math inline">\(\texttt{intersection}\)</span> and <span class="math inline">\(\texttt{difference}\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Let's analyze the cost for $\cd{union}$ as implemented by the parametric
implementation. It is easy to apply a similar analysis to
$\cd{intersection}$ and $\cd{difference}$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Figuring out the Recurrence
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Figuring out the Recurrence
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Consider now a call to <span class="math inline">\(\texttt{union}\)</span> with parameters <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span>. To simplify the analysis, we will make the following assumptions:</p>
<ol>
<li><p><span class="math inline">\(t_1\)</span> is perfectly balanced (i.e., the left and right subtrees of the root have size at most <span class="math inline">\(|t_1|/2\)</span>),</p></li>
<li><p>each time a key from <span class="math inline">\(t_1\)</span> splits <span class="math inline">\(t_2\)</span>, it splits the tree in exactly in half, and</p></li>
<li><p><span class="math inline">\(|t_1| &lt; |t_2|\)</span>.</p></li>
</ol>
<p>Later we will relax these assumptions.</p>
<p>Let us define <span class="math inline">\(m = |t_1|\)</span> and <span class="math inline">\(n = |t_2|\)</span> (recall the size of a tree is the number of keys in it). With these assumptions and examining the algorithm we can then write the following recurrence for the work of <span class="math inline">\(\texttt{union}\)</span>: <span class="math display">\[\begin{aligned}
  W_{\mbox{union}}(m, n) &amp;\leq 2W_{\mbox{union}}(m/2,n/2) + W_{\mbox{split}}(n) 
+ W_{\mbox{join}}(n+m) + O(1)\\ 
   &amp; \leq  2W_{\mbox{union}}(m/2, n/2) + O(\lg n)~. \end{aligned}\]</span></p>
<p>The size for join is the sum of the two sizes, <span class="math inline">\(m+n\)</span>, but since <span class="math inline">\(m \leq n\)</span>, <span class="math inline">\(O(\lg (n + m))\)</span> is equivalent to <span class="math inline">\(O(\lg n)\)</span>. We also have the base case <span class="math display">\[\begin{aligned}
  W_{\mbox{union}}(1, n) &amp; \leq 2W_{\mbox{union}}(0,n/2) + W_{\mbox{split}}(n) 
+ W_{\mbox{join}}(n) + O(1)\\ 
         &amp; \leq O(\lg n)~. \end{aligned}\]</span> The final inequality holds because <span class="math inline">\(2W_{\mbox{union}}(0,n) = O(1)\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Consider now a call to $\cd{union}$ with parameters
$t_1$ and $t_2$.  To simplify the analysis, we will make the following
assumptions:
\begin{enumerate}
\item $t_1$ is perfectly balanced (i.e., the left and right subtrees of
  the root have size at most $|t_1|/2$), 
\item each time a key from $t_1$ splits $t_2$, it splits the tree in
  exactly in half, and
\item $|t_1| < |t_2|$.
\end{enumerate}
%
Later we will relax these assumptions.  

Let us define $m = |t_1|$ and
$n = |t_2|$ (recall the size of a tree is the number of keys in it).
With these assumptions and examining the algorithm we can then write
the following recurrence for the work of $\cd{union}$:
\begin{align*}
  W_{\mbox{union}}(m, n) &\leq 2W_{\mbox{union}}(m/2,n/2) + W_{\mbox{split}}(n)
+ W_{\mbox{join}}(n+m) + O(1)\\
   & \leq  2W_{\mbox{union}}(m/2, n/2) + O(\lg n)~.
\end{align*}  

The size for join is the sum of the two sizes, $m+n$, but since 
$m \leq n$, $O(\lg (n + m))$ is equivalent to $O(\lg n)$.
We also have the base case
\begin{align*}
  W_{\mbox{union}}(1, n) & \leq 2W_{\mbox{union}}(0,n/2) + W_{\mbox{split}}(n)
+ W_{\mbox{join}}(n) + O(1)\\
         & \leq O(\lg n)~.
\end{align*}
The final inequality holds because $2W_{\mbox{union}}(0,n) = O(1)$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Solving the Recurrence
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Solving the Recurrence
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We can draw the recurrence tree showing the work performed by the splitting of <span class="math inline">\(t_2\)</span> and by the joining of the results as follows. For simplicity of the argument, let’s assume that the leaves of the tree correspond to the case for <span class="math inline">\(m = 1\)</span>.</p>
<p><img src="/media/210/bsts/recurtree2.jpg" alt="image" width="4" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We can draw the recurrence tree showing the work performed by the
splitting of $t_2$ and by the joining of the results as follows.  For
simplicity of the argument, let's assume that the leaves of the tree
correspond to the case for $m = 1$.

%This figure should be changed so "n" is replaced by "N" except the
%bottom level should be "each costs log (1 + n/m)"

\begin{center}
  \includegraphics[width=4.5]{/media/210/bsts/recurtree2.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Brick Method
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Brick Method
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Let’s analyze the structure of the recursion tree shown above.</p>
<p>We can find the number of leaves in the tree by examining the work recurrence. Notice that in the recurrence, the tree bottoms out when <span class="math inline">\(m = 1\)</span> and before that, <span class="math inline">\(m\)</span> always gets split in half (remember that <span class="math inline">\(t_1\)</span> is perfectly balanced). The tree <span class="math inline">\(t_2\)</span> does not affects the shape of the recursion tree or the stopping condition. Thus, there are exactly <span class="math inline">\(m\)</span> leaves in the tree. In fact, the recursion can be rewritten as a recursion of the form <span class="math inline">\(W(m) = 2W(m/2) + \ldots\)</span>, which means that there are <span class="math inline">\(m\)</span> leaves.</p>
<p>By the same reasoning, we can see that the leaves are <span class="math inline">\((1 + \lg m)\)</span> deep.</p>
<p>Let’s now determine the size of <span class="math inline">\(t_2\)</span> at the leaves. We have <span class="math inline">\(m\)</span> keys in <span class="math inline">\(t_1\)</span> to start with, and they split <span class="math inline">\(t_2\)</span> evenly all the way down to the level of the leaves (by assumption). Thus, the leaves have all the same size of <span class="math inline">\(\frac{n}{m}\)</span>. Therefore, each leaf adds a <span class="math inline">\(O(\lg (1+\frac{n}{m}))\)</span> term to the work (the <span class="math inline">\(1+\)</span> is needed to deal with the case that <span class="math inline">\(n = m\)</span>). Since there are <span class="math inline">\(m\)</span> leaves, the whole bottom level costs <span class="math display">\[O(m \lg (1+ \frac{n}{m})).\]</span></p>
<p>We will now prove that the cost at the bottom level is indeed asymptotically the same as the total work. In other words, the tree is leaves-dominated. It is possible to prove that the tree is leaves-dominated by computing the ratio of the work at adjacent levels, i.e., the ratio <span class="math display">\[\frac{2^{i-1}  \lg{n/2^{i-1}}}{2^i  
  \lg{n/2^{i}}} = \frac{1}{2} \frac{\lg{n} - i + 1 }{\lg{n} - i},\]</span> where <span class="math inline">\(i \le \lg{m} &lt; \lg{n}\)</span>. This ratio is less than <span class="math inline">\(1\)</span> for all levels except for the last level, where by taking <span class="math inline">\(i = \lg{n} - 1\)</span> we have <span class="math display">\[\frac{1}{2} \frac{\lg{n} - i +1 }{\lg{n} - i} 
 \le 
 \frac{1}{2} \frac{1}{\lg{n} - \lg{n} +1 + 1}{\lg{n} - \lg{n}+1} 
= \frac{1}{1}.\]</span> Thus the total work is asymptotically dominated by the total work of the leaves, which is <span class="math inline">\(O\left({m\lg{n/m}}\right)\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Let's analyze the structure of the recursion tree shown above.
%

We can find the number of leaves in the tree by examining the work
recurrence.  Notice that in the recurrence, the tree bottoms out when
$m = 1$ and before that, $m$ always gets split in half (remember that
$t_1$ is perfectly balanced).  The tree $t_2$ does not affects the
shape of the recursion tree or the stopping condition. Thus, there are
exactly $m$ leaves in the tree.  
%
In fact, the recursion can be rewritten as a recursion of the form
$W(m) = 2W(m/2) + \ldots $, which means that there are $m$ leaves.
%


By the same reasoning, we can see that the leaves are $(1 + \lg m)$
deep.

Let's now determine the size of $t_2$ at the leaves.  
%
We have $m$ keys in $t_1$ to start with, and they split $t_2$ evenly
all the way down to the level of the leaves (by assumption). Thus, the
leaves have all the same size of $\frac{n}{m}$.
%
Therefore, each leaf adds a $O(\lg (1+\frac{n}{m}))$ term to the work
(the $1+$ is needed to deal with the case that $n = m$).  Since there
are $m$ leaves, the whole bottom level costs 
%
\[
O(m \lg (1+ \frac{n}{m})).
\]  

We will now prove that the cost at the bottom level is indeed
asymptotically the same as the total work.  In other words, the tree
is leaves-dominated.  It is possible to prove that the tree is
leaves-dominated by computing the ratio of the work at adjacent
levels, i.e., the ratio
\[
\frac{2^{i-1}  \lg{n/2^{i-1}}}{2^i 
  \lg{n/2^{i}}} = \frac{1}{2} \frac{\lg{n} - i + 1 }{\lg{n} - i},
\]
where $i \le \lg{m} < \lg{n}$. This ratio is less than $1$ for all
levels except for the last level, where by taking $i = \lg{n} - 1$ we
have
\[
 \frac{1}{2} \frac{\lg{n} - i +1 }{\lg{n} - i}
 \le
 \frac{1}{2} \frac{1}{\lg{n} - \lg{n} +1 + 1}{\lg{n} - \lg{n}+1}
= \frac{1}{1}.
\]
Thus the total work is asymptotically dominated by the total work of
the leaves, which is $\bigoh{m\lg{n/m}}$.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Direct Derivation
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Direct Derivation
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We can establish the same fact more precisely. Let’s start by writing the total cost by summing over all levels, omitting for simplicity the constant factors, and assuming that <span class="math inline">\(n = 2^a\)</span> and <span class="math inline">\(m = 2^b\)</span>, <span class="math display">\[W(n,m) = \sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}}.\]</span> We can rewrite this sum as <span class="math display">\[\sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}} =  
\lg{n}\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i}. 
= a\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i}.\]</span> Let’s now focus on the second term. Note that <span class="math display">\[\sum_{i = 0}^{b}{i\,2^i}  
= 
\sum_{i = 0}^{b}{\sum_{j=i}^{b}2^j}  
= 
\sum_{i = 0}^{b}{\left(\sum_{j=0}^{b}{2^j} - \sum_{k=0}^{i-1}2^k\right). }\]</span> Substituting the closed form for each inner summation and simplifying leads to <span class="math display">\[\begin{array}{ll} 
= &amp; \sum_{i = 0}^{b}{\left( (2^{b+1}-1) - (2^{i}-1) \right)}. 
\\[2mm] 
= &amp;  (b+1) (2^{b+1}-1) - \sum_{i = 0}^{b}{(2^{i}-1)} 
\\[2mm] 
= &amp;  (b+1) (2^{b+1}-1) - \left( 2^{b+1}-1 - (b+1) \right) 
\\[2mm] 
= &amp;  (b+1) (2^{b+1}-1) - \left( 2^{b+1}-1 - (b+1) \right) 
\\[2mm] 
= &amp;  b\,2^{b+1} + 1. 
\end{array}\]</span></p>
<p>Let’s now go back and plug this into the original work bound and simplify <span class="math display">\[\begin{array}{lll} 
W(n,m) &amp; = &amp;\sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}} 
\\[2mm] 
&amp; = &amp; a\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i} 
\\[2mm] 
&amp; = &amp; a\,(2^{b+1}-1) -  (b\,2^{b+1} + 1) 
\\[2mm] 
&amp; = &amp; a\,2^{b+1}-a - b\,2^{b+1} -1 
%\\ 
= 2m (a-b) - a -1 
\\[2mm] 
&amp; = &amp; 2m (\lg{n}-\lg{m}) - a -1 
%\\ 
= 2m \lg{\frac{n}{m}} - a -1 
\\[2mm] 
&amp; = &amp; O\left({m \, \lg{\frac{n}{m}}}\right). 
\end{array}\]</span></p>
<p>While the direct method may seem complicated, it is more robust than the brick method, because it can be applied to analyze essentially any algorithm, whereas the Brick method requires establishing a geometric relationship between the cost terms at the levels of the tree.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We can establish the same fact more precisely.  Let's start by writing
the total cost by summing over all levels, omitting for simplicity the
constant factors, and assuming that $n = 2^a$ and $m = 2^b$,
\[
W(n,m) = \sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}}.
\]
We can rewrite this sum as 
\[
\sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}} = 
\lg{n}\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i}.
= a\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i}.
\]
Let's now focus on the second term. Note that 
\[
\sum_{i = 0}^{b}{i\,2^i} 
=
\sum_{i = 0}^{b}{\sum_{j=i}^{b}2^j} 
=
\sum_{i = 0}^{b}{\left(\sum_{j=0}^{b}{2^j} - \sum_{k=0}^{i-1}2^k\right). }
\]
Substituting the closed form for each inner summation and simplifying
leads to
\[
\begin{array}{ll}
= & \sum_{i = 0}^{b}{\left( (2^{b+1}-1) - (2^{i}-1) \right)}.
\\[2mm]
= &  (b+1) (2^{b+1}-1) - \sum_{i = 0}^{b}{(2^{i}-1)}
\\[2mm]
= &  (b+1) (2^{b+1}-1) - \left( 2^{b+1}-1 - (b+1) \right)
\\[2mm]
= &  (b+1) (2^{b+1}-1) - \left( 2^{b+1}-1 - (b+1) \right)
\\[2mm]
= &  b\,2^{b+1} + 1.
\end{array}
\]

Let's now go back and plug this into the original work bound and simplify
\[
\begin{array}{lll}
W(n,m) & = &\sum_{i = 0}^{b}{2^i \lg{\frac{n}{2^i}}}
\\[2mm]
& = & a\sum_{i = 0}^{b}{2^i} - \sum_{i = 0}^{b}{i\,2^i}
\\[2mm]
& = & a\,(2^{b+1}-1) -  (b\,2^{b+1} + 1)
\\[2mm]
& = & a\,2^{b+1}-a - b\,2^{b+1} -1
%\\
= 2m (a-b) - a -1
\\[2mm]
& = & 2m (\lg{n}-\lg{m}) - a -1
%\\
= 2m \lg{\frac{n}{m}} - a -1
\\[2mm]
& = & \bigoh{m \, \lg{\frac{n}{m}}}.
\end{array}
\]

While the direct method may seem complicated, it is more robust than
the brick method, because it can be applied to analyze essentially any
algorithm, whereas the Brick method requires establishing a geometric
relationship between the cost terms at the levels of the tree.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC6:UN7:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Removing the Assumptions
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Removing the Assumptions
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC6:UN7:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC6:UN7:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Of course, in reality, our keys in <span class="math inline">\(t_1\)</span> won’t split subtrees of <span class="math inline">\(t_2\)</span> in half every time. But it turns out that any unevenness in the splitting only helps reduce the work—i.e., the perfect split is the worst case. We won’t go through a rigorous argument, but if we keep the assumption that <span class="math inline">\(t_1\)</span> is perfectly balanced, then the shape of the recursion tree stays the same. What is now different is the cost at each level. Let us try to analyze the cost at level <span class="math inline">\(i\)</span>. At this level, there are <span class="math inline">\(k = 2^i\)</span> nodes in the recursion tree. Say the sizes of <span class="math inline">\(t_2\)</span> at these nodes are <span class="math inline">\(n_1, \dots, n_k\)</span>, where <span class="math inline">\(\sum_j n_j = 
n\)</span>. Then, the total cost for this level is <span class="math display">\[c \cdot \sum_{j=1}^k \lg (n_j) \;\;\leq\;\; c \cdot \sum_{j=1}^k \lg (n/k) = 
c\cdot 2^i \cdot \lg (n/2^i),\]</span> where we used the fact that the logarithm function is concave<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>. Thus, the tree remains leaf-dominated and the same reasoning shows that the total work is <span class="math inline">\(O(m \lg (1 + \frac{n}{m}))\)</span>.</p>
<p>Still, in reality, <span class="math inline">\(t_1\)</span> doesn’t have to be perfectly balanced as we assumed. To generalize the analysis, we just need a tree with <span class="math inline">\(O(\lg{m})\)</span> height. Thus, we only need <span class="math inline">\(t_1\)</span> to be approximately balanced.</p>
<p>Finally, we assumed that <span class="math inline">\(t_1\)</span> is larger that <span class="math inline">\(t_2\)</span>. If it is smaller, then we can reverse the order of arguments, so in this case, there is no loss of generality. If they are the same size, we need to be a bit more precise in our handling of the base case in our summation but this is all.</p>
<p>We end by remarking that as described, the span of <span class="math inline">\(\texttt{union}\)</span> is <span class="math inline">\(O(\lg^2 n)\)</span>, but this can be improved to <span class="math inline">\(O(\lg n)\)</span> by changing the algorithm slightly.</p>
<p>In summary, <span class="math inline">\(\texttt{union}\)</span> can be implemented in <span class="math display">\[O(m \lg (1 + \tfrac{n}m))\]</span> work and <span class="math display">\[O(\lg n)\]</span> span.</p>
<p>Essentially the same analysis applies to the functions <span class="math inline">\(\texttt{intersection}\)</span> and <span class="math inline">\(\texttt{difference}\)</span>, whose structures are the same as <span class="math inline">\(\texttt{union}\)</span>, except for an additional constant work and span for the conditional (<span class="math inline">\(\texttt{if}\)</span>) expression.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This is also known as Jensen’s inequality.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Of course, in reality, our keys in $t_1$ won't split subtrees of $t_2$
in half every time.  But it turns out that any unevenness in the
splitting only helps reduce the work---i.e., the perfect split is the
worst case.  We won't go through a rigorous argument, but if we keep
the assumption that $t_1$ is perfectly balanced, then the shape of the
recursion tree stays the same.  What is now different is the cost at
each level.  Let us try to analyze the cost at level~$i$.  At this
level, there are $k = 2^i$ nodes in the recursion tree. Say the sizes
of $t_2$ at these nodes are $n_1, \dots, n_k$, where $\sum_j n_j =
n$. Then, the total cost for this level is
\[
c \cdot \sum_{j=1}^k \lg (n_j) \;\;\leq\;\; c \cdot \sum_{j=1}^k \lg (n/k) =
c\cdot 2^i \cdot \lg (n/2^i),
\]
where we used the fact that the logarithm function is
concave\footnote{This is also known as Jensen's inequality.}.  Thus,
the tree remains leaf-dominated and the same reasoning shows that the
total work is $O(m \lg (1 + \frac{n}{m}))$.

Still, in reality, $t_1$ doesn't have to be perfectly balanced as we
assumed. To generalize the analysis, we just need a tree with
$O(\lg{m})$ height.  Thus, we only need $t_1$ to be approximately
balanced. 

Finally, we assumed that $t_1$ is larger that $t_2$.  If it is
smaller, then we can reverse the order of arguments, so in this case,
there is no loss of generality.  If they are the same size, we need to
be a bit more precise in our handling of the base case in our
summation but this is all.

We end by remarking that as described, the span of $\cd{union}$ is
$O(\lg^2 n)$, but this can be improved to $O(\lg n)$ by changing the
algorithm slightly.

In summary, $\cd{union}$ can be implemented in 
\[
O(m \lg (1 + \tfrac{n}m))
\]
work and 
\[
O(\lg n)
\]
span.  

Essentially the same analysis applies to the functions
$\cd{intersection}$ and $\cd{difference}$, whose structures are the same
as $\cd{union}$, except for an additional constant work and span for
the conditional ($\cd{if}$) expression.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Treaps
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Treaps
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC7:sec:bst::treaps
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>Our parametric implementation established an interesting fact: to implement the BST ADT efficiently, we only need to provide efficient <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations. In this section, we present a data structure called  <span style="color: black"><span><strong><em>Treaps</em></strong></span></span> that can support <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> operations in expected logarithmic work and span. Treaps achieve their efficiency by maintaining BSTs that are probabilistically balanced. Of the many balanced BST data structures, Treaps are likely the simplest, but, since they are randomized, they only guarantee approximate balance with high probability.</p>

\end{dilIntro}
\begin{dilIntroDex}


Our parametric implementation established an interesting fact: to
implement the BST ADT efficiently, we only need to provide efficient
$\cd{split}$ and $\cd{join}$ operations.  In this section, we
present a data structure called~\defn{Treaps} that can support
$\cd{split}$ and $\cd{join}$ operations in expected logarithmic work
and span.
%
Treaps achieve their efficiency by maintaining BSTs that are
probabilistically balanced. Of the many balanced BST data structures,
Treaps are likely the simplest, but, since they are randomized, they
only guarantee approximate balance with high probability.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC7:UN8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To see the idea behind Treaps, let’s first discuss how we can map a sequence of keys to a BST. Given <span class="math inline">\(S\)</span>, a sequence of unique keys, let’s start with an empty BST and insert the keys in <span class="math inline">\(S\)</span> into the BST one by one starting from left to right. To insert a key <span class="math inline">\(k\)</span>, we perform a search for <span class="math inline">\(k\)</span> in the current BST and let <span class="math inline">\(u\)</span> be the leaf where the (unsuccessful) search terminates. To insert <span class="math inline">\(k\)</span> into the tree, we replace <span class="math inline">\(u\)</span> with a new node with key <span class="math inline">\(k\)</span>.</p>
<p>We can map the sequence <span class="math inline">\(\left\langle\, 8,9,5,6,1,7 \,\right\rangle\)</span> to a BST by inserting the keys from left to right.</p>
<p><img src="/media/210/bsts/bst5-build.jpg" alt="image" style="width:14cm" /></p>
<p>What can we say about the height of such a tree?</p>
<p>Note now that the height of the BST will be directly determined by the input sequence. Specifically, the specific order—or permutation—in which the keys are inserted will determine the height. For most permutations, the tree will be reasonably well balanced because we get an unbalanced tree only in cases where an element partitions the following keys unevenly. Since we have many more even partitions for a given set of keys (many “middle” keys), many permutations create balanced trees.</p>
<p>Can we take advantage of this observation somehow?</p>
<p>Recall that the BST ADT does not care about the specific structure of the BST but only the set of keys in the tree. We can take advantage of this observation by selecting a (uniformly) random permutation of the keys and constructing the BST based on this permutation. Since most permutations give us reasonably balanced trees, this approach should give us a balanced tree.</p>
<p>Suppose that we were given the keys in the sequence one by one instead of all at once. Can you think of a way to select a uniformly random permutation?</p>
<p>Observe now that we can select a uniformly random permutation even if we don’t have all the keys by assigning a random priority to each key as it arrives and building our BST by considering the keys in the priority order. By assigning priorities randomly, we essentially guarantee that we always build our tree on a uniformly randomly selected permutation. This is one of the main ideas behind Treaps: Treaps can be viewed as maintaining a BST on a uniformly random permutation of the keys in the tree. To achieve this “imitation of randomly ordered insertions” we associate a priority with each key and require the BST to be “heap ordered” with respect to priorities.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To see the idea behind Treaps, let's first discuss how we can map a
  sequence of keys to a BST. Given $S$, a sequence of unique keys,
  let's start with an empty BST and insert the keys in $S$ into the
  BST one by one starting from left to right.  To insert a key $k$, we
  perform a search for $k$ in the current BST and let $u$ be the leaf
  where the (unsuccessful) search terminates.  To insert $k$ into the
  tree, we replace $u$ with a new node with key $k$.



We can map the sequence $\cseq{8,9,5,6,1,7}$ to a BST by inserting the keys from
left to right.

\begin{center}
\includegraphics[width=14cm]{/media/210/bsts/bst5-build.jpg}
\end{center}


What can we say about the height of such a tree? 


Note now that the height of the BST will be directly determined by the
input sequence.  Specifically, the specific order---or
permutation---in which the keys are inserted will determine the
height.  For most permutations, the tree will be reasonably well
balanced because we get an unbalanced tree only in cases where an
element partitions the following keys unevenly.  Since we have
many more even partitions for a given set of keys (many ``middle''
keys), many permutations create balanced trees.


Can we take advantage of this observation somehow? 

%
Recall that the BST ADT does not care about the specific structure of
the BST but only the set of keys in the tree. We can take advantage of
this observation by selecting a (uniformly) random permutation of the keys and
constructing the BST based on this permutation.  Since most
permutations give us reasonably balanced trees, this approach should
give us a balanced tree.



Suppose that we were given the keys in the sequence one by one instead
of all at once.  Can you think of a way to select a uniformly random
permutation?


Observe now that we can select a uniformly random permutation even if
we don't have all the keys by assigning a random priority to each key
as it arrives and building our BST by considering the keys in the
priority order.  By assigning priorities randomly, we essentially
guarantee that we always build our tree on a uniformly randomly
selected permutation.
%
This is one of the main ideas behind Treaps: Treaps can be viewed as
maintaining a BST on a uniformly random permutation of the keys in the
tree. To achieve this ``imitation of randomly ordered insertions''
we associate a priority with each key and require the BST to be ``heap
ordered'' with respect to priorities.

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Idea behind Treaps
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Idea behind Treaps
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The idea behind Treaps is to associate a uniformly randomly selected priority to each key and maintain a priority order between keys in addition to the binary-search-tree order. The priority order between keys resemble the order used in binary heaps, leading to the name “Tree Heap” or “Treap.”</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The idea behind Treaps is to associate a uniformly randomly selected
priority to each key and maintain a priority order between keys in
addition to the binary-search-tree order.  The priority order between
keys resemble the order used in binary heaps, leading to the name
``Tree Heap'' or ``Treap.''

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomDefinition}
\begin{dilFieldTitle}
Treap
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Treap
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A Treap is a binary search tree over a set <span class="math inline">\(K\)</span> along with a  <span style="color: black"><span><strong><em>priority</em></strong></span></span> for each key given by <span class="math display">\[p : {\mathbb{K}}\rightarrow  \mathbb{Z}\]</span> that in addition to satisfying the BST property on the keys <span class="math inline">\(K\)</span>, satisfies the heap property on the priorities <span class="math inline">\(p(k), k \in 
  K\)</span>, i.e., for every internal node <span class="math inline">\(v\)</span> with left and right children <span class="math inline">\(u\)</span> and <span class="math inline">\(w\)</span>: <span class="math display">\[p(k(v)) \geq p(k(u)) \mbox{ and } p(k(v)) \geq p(k(w)),\]</span> where <span class="math inline">\(k(v)\)</span> denotes the key of a node.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A Treap is a binary search tree over a set $K$ along with
  a~\defn{priority} for each key given by
%
  \[
  p : \kkk \rightarrow  \tyint
  \]
%
  that in addition to satisfying the BST property on the
  keys $K$, satisfies the heap property on the priorities $p(k), k \in
  K$, i.e., for every internal node $v$ with left and right children
  $u$ and $w$:
\[
p(k(v)) \geq p(k(u)) \mbox{ and } p(k(v)) \geq p(k(w)),
\]
where $k(v)$ denotes the key of a node.

\end{dilFieldBodyDex}
\end{dilAtomDefinition}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following key-priority pairs <span class="math inline">\((k,p(k))\)</span>, <span class="math display">\[(a,3), (b,9), (c, 2), (e,6), (f, 5)~,\]</span> where the keys are ordered alphabetically, form the following Treap:</p>
<p><img src="/media/210/bsts/treap-examp.jpg" alt="image" style="width:2in" /></p>
<p>since <span class="math inline">\(9\)</span> is larger than <span class="math inline">\(3\)</span> and <span class="math inline">\(6\)</span>, and <span class="math inline">\(6\)</span> is larger than <span class="math inline">\(2\)</span> and <span class="math inline">\(5\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following key-priority pairs $(k,p(k))$,
\[ (a,3), (b,9), (c, 2), (e,6), (f, 5)~,\] where the keys are ordered
alphabetically, form the following Treap:
\begin{center}
  \includegraphics[width=2.0in]{/media/210/bsts/treap-examp.jpg}
\end{center}
since $9$ is larger than $3$ and $6$, and $6$ is larger than $2$ and
$5$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExercise}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Prove that if the priorities are unique, then there is exactly one tree structure that satisfies the Treap properties.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Prove that if the priorities are unique, then there is exactly one tree
structure that satisfies the Treap properties.

\end{dilFieldBodyDex}
\end{dilAtomExercise}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Assigning Priorities
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Assigning Priorities
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>So how do we assign priorities? As we briefly suggested in the informal discussion above, it turns out that if the priorities are selected uniformly randomly then the tree is guaranteed to be near balanced, i.e. <span class="math inline">\(O(\lg |S|)\)</span> height, with high probability. We will show this shortly.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
So how do we assign priorities?  As we briefly suggested in the
informal discussion above, it turns out that if the priorities are
selected uniformly randomly then the tree is guaranteed to be near
balanced, i.e. $O(\lg |S|)$ height, with high probability.  We will
show this shortly.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>How can we maintain the heap order as we modify the tree?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
How can we maintain the heap order as we modify the tree?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR8
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR8:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR8:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Based on our parametrized implementation, we can implement the BST ADT with Treaps simply by implementing the <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> functions. The SPARC code for such an implementation is given below. For the implementation we assume, without loss of generality, that the priorities are integers. We present only the code for <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>; the rest of the implementation is essentially the same as in the parametric implementation. The only exception that since the nodes now carry priorities, we will need to account for them as we pattern match on nodes and create new ones. In implementing the rest of the functions, there are no interesting operations on priorities: they simply follow the key that they belong to.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Based on our parametrized implementation, we can implement the BST ADT
with Treaps simply by implementing the $\cd{split}$ and $\cd{join}$
functions.  
%
%\dsref{bst::treaps} shows such an implementation.  
The \pml{} code for such an implementation is given below.
%
For the implementation we assume, without loss of generality, that the
priorities are integers.  We present only the code for $\cd{split}$
and $\cd{join}$; the rest of the implementation is essentially the
same as in the parametric implementation.
% \dsref{bst::parametric}
%
The only exception that since the nodes now carry priorities, we will
need to account for them as we pattern match on nodes and create new
ones.  In implementing the rest of the functions, there are no
interesting operations on priorities: they simply follow the key that
they belong to.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR9
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Implementing <span><span class="sans-serif">BST</span></span> with Treaps
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Implementing \adt{BST} with Treaps
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR9:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR9:AT1:ds:bst::treaps
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; \texttt{type ${\mathbb{T}}$ = Leaf | Node of (${\mathbb{T}}$ $\times$ ${\mathbb{K}}$ $\times$ $\mathbb{Z}$ $\times$ ${\mathbb{T}}$)} 
\\ 
~&amp;~ 
\\ 
2 &amp; \texttt{empty = Leaf} 
\\ 
&amp;\\ 
3 &amp; \texttt{singleton $k$ = Node(Leaf, $k$, randomInt(), Leaf)} 
\\ 
&amp;\\ 
4 &amp; \texttt{split $t$ $k$ = } 
\\ 
5 &amp; ~~\texttt{case $t$ } 
\\ 
6 &amp; ~~\texttt{| Leaf $\Rightarrow$ (Leaf, False, Leaf)} 
\\ 
7 &amp; ~~\texttt{| Node $(l, k&#39;, p&#39;, r)$ =} 
\\ 
8 &amp; ~~~~~~\texttt{case compare $(k, k&#39;)$} 
\\ 
9 &amp; ~~~~~~\texttt{| LESS $\Rightarrow$} %\label{line:bst::treaps::split-less} 
\\ 
10 &amp; ~~~~~~~~~~\texttt{let $(l&#39;, x, r&#39;)$ = split $l$ $k$} 
\\ 
11 &amp; ~~~~~~~~~~\texttt{in $(l&#39;, x, \texttt{Node}(r&#39;, k&#39;, p&#39;, r))$ end}% \label{line:bst::treaps::splitnode1}} 
\\ 
12 &amp; ~~~~~~\texttt{| EQUAL $\Rightarrow$ $($$l$, true, $r$$)$} 
\\ 
13 &amp; ~~~~~~\texttt{| GREATER $\Rightarrow$} %\label{line:bst::treaps::split-greater} 
\\ 
14 &amp; ~~~~~~~~~~\texttt{let $(l&#39;, x, r&#39;)$ = split $r$ $k$} 
\\ 
15 &amp; ~~~~~~~~~~\texttt{in (Node $(l, k&#39;, p&#39;, l&#39;), x, r&#39;$) end} %\label{line:bst::treaps::splitnode2} 
\\ 
&amp;\\ 
16 &amp; \texttt{join $t_1$ $t_2$ =} 
\\ 
17 &amp; ~~\texttt{case $(t_1, t_2)$} 
\\ 
18 &amp; ~~\texttt{| (Leaf,  _) $\Rightarrow$ $t_2$} 
\\ 
19 &amp; ~~\texttt{| (_ ,  Leaf) $\Rightarrow$ $t_1$} 
\\ 
20 &amp; ~~\texttt{| (Node $(l_1, k_1, p_1, r_1)$,  Node $(l_2, k_2, p_2, r_2)$) $\Rightarrow$} 
\\ 
21 &amp; ~~~~~~\texttt{if ($p_1 &gt; p_2$) then}  %\label{line:bst::treaps::cpri} 
\\ 
22 &amp; ~~~~~~~~\texttt{Node ($l_1$, $k_1$, $p_1$,  join $r_1$ $t_2$)} 
\\ 
23 &amp; ~~~~~~\texttt{else} 
\\ 
24 &amp; ~~~~~~~~\texttt{Node (join $t_1$ $l_2$,  $k_2$, $p_2$, $r_2$)} 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
\begin{array}{ll}
1 & \cd{type $\tttt$ = Leaf | Node of ($\tttt$ $\times$ $\kkk$ $\times$ $\tyint$ $\times$ $\tttt$)}
\\
~&~
\\
2 & \cd{empty = Leaf}
\\
&\\
3 & \cd{singleton $k$ = Node(Leaf, $k$, randomInt(), Leaf)}
\\
&\\
4 & \cd{split $t$ $k$ = }
\\
5 & ~~\cd{case $t$ }
\\
6 & ~~\cd{| Leaf $\Rightarrow$ (Leaf, False, Leaf)}
\\
7 & ~~\cd{| Node $(l, k', p', r)$ =}
\\
8 & ~~~~~~\cd{case compare $(k, k')$}
\\
9 & ~~~~~~\cd{| LESS $\Rightarrow$} %\label{line:bst::treaps::split-less}
\\
10 & ~~~~~~~~~~\cd{let $(l', x, r')$ = split $l$ $k$}
\\
11 & ~~~~~~~~~~\cd{in $(l', x, \cd{Node}(r', k', p', r))$ end}% \label{line:bst::treaps::splitnode1}}
\\
12 & ~~~~~~\cd{| EQUAL $\Rightarrow$ $($$l$, true, $r$$)$}
\\
13 & ~~~~~~\cd{| GREATER $\Rightarrow$} %\label{line:bst::treaps::split-greater}
\\
14 & ~~~~~~~~~~\cd{let $(l', x, r')$ = split $r$ $k$}
\\
15 & ~~~~~~~~~~\cd{in (Node $(l, k', p', l'), x, r'$) end} %\label{line:bst::treaps::splitnode2}
\\
&\\
16 & \cd{join $t_1$ $t_2$ =}
\\
17 & ~~\cd{case $(t_1, t_2)$}
\\
18 & ~~\cd{| (Leaf,  _) $\Rightarrow$ $t_2$}
\\
19 & ~~\cd{| (_ ,  Leaf) $\Rightarrow$ $t_1$}
\\
20 & ~~\cd{| (Node $(l_1, k_1, p_1, r_1)$,  Node $(l_2, k_2, p_2, r_2)$) $\Rightarrow$}
\\
21 & ~~~~~~\cd{if ($p_1 > p_2$) then}  %\label{line:bst::treaps::cpri}
\\
22 & ~~~~~~~~\cd{Node ($l_1$, $k_1$, $p_1$,  join $r_1$ $t_2$)}
\\
23 & ~~~~~~\cd{else}
\\
24 & ~~~~~~~~\cd{Node (join $t_1$ $l_2$,  $k_2$, $p_2$, $r_2$)}
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR10
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR10:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR10:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To implement the function <span class="math inline">\(\texttt{singleton},\)</span> we rely on a function <span class="math inline">\(\texttt{randomInt},\)</span> which when called returns a (pseudo-)random number. Such functions are broadly provided by programming languages.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To implement the function $\cd{singleton},$ we rely on a function
$\cd{randomInt},$ which when called returns a (pseudo-)random number.
Such functions are broadly provided by programming languages.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR11
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Split
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Split
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR11:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR11:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The <span class="math inline">\(\texttt{split}\)</span> algorithm recursively traverses the tree from the root to the key <span class="math inline">\(k\)</span> splitting along the path, and then when returning from the recursive calls, it puts the subtrees back together. When putting back the trees along the path being split through, the function does not have to compare priorities the priority <span class="math inline">\(p&#39;\)</span> is the highest priority in the input tree <span class="math inline">\(T\)</span> and is therefore larger than the priorities of either of the subtrees on the left and right. Hence <span class="math inline">\(\texttt{split}\)</span> maintains the heap property of treaps.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The $\cd{split}$ algorithm recursively traverses the tree from the
root to the key $k$ splitting along the path, and then when returning
from the recursive calls, it puts the subtrees back together.  When
putting back the trees along the path being split through, the
function does not have to compare priorities 
%because $\cd{Node}$ on
%\linereftwo{bst::treaps::splitnode1}{bst::treaps::splitnode2},
the priority $p'$ is the highest priority in the input tree $T$ and is
therefore larger than the priorities of either of the subtrees on the
left and right.  Hence $\cd{split}$ maintains the heap property of
treaps.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR11:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR11:AT2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>A <span class="math inline">\(\texttt{split}\)</span> operation on a Treap and key <span class="math inline">\(c\)</span>, which is not in the Treap. The <span class="math inline">\(\texttt{split}\)</span> traverses the path <span class="math inline">\(\left\langle\, a,e,b,d \,\right\rangle\)</span> turning right at <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> of the Data Structure and turning left at <span class="math inline">\(e\)</span> and <span class="math inline">\(d\)</span>. The pieces are put back together into the two resulting trees on the way back up the recursion.</p>
<p><img src="/media/210/bsts/bstsplit.jpg" alt="image" style="width:5.7in" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
A $\cd{split}$ operation on a Treap and key~$c$, which is not in the
Treap.  The $\cd{split}$ traverses the path $\cseq{a,e,b,d}$ turning
right at $a$ and $b$ 
%(\lineref{bst::treaps::split-greater} 
of the Data Structure
%~\ref{atom:15210:S18:CH12:SEC7:UN8:GR9:AT1:ds:bst::treaps}) 
and turning left at $e$ and $d$.
%
%(\lineref{bst::treaps::split-less}).  
%
The pieces are put back together into the two
resulting trees on the way back up the recursion.
\begin{center}
  \includegraphics[width=5.7in]{/media/210/bsts/bstsplit.jpg}
\end{center}
%The actual way the trees will be put back together will depend on the
%balancing scheme.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
Join
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Join
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR12
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR12:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR12:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Unlike the implementation of <span class="math inline">\(\texttt{split}\)</span>, the implementation of <span class="math inline">\(\texttt{join}\)</span> operates on priorities in order to ensure that the resulting Treap satisfies the heap priority of Treaps. Specifically, given two trees, <span class="math inline">\(\texttt{join}\)</span> first compares the priorities of the two roots, making the larger priority the new root. It then recursively joins the Treaps consisting of the other tree and the appropriate side of the new root.</p>
<p>The path from the root to the leftmost node in a BST is called the  <span style="color: black"><span><strong><em>left spine</em></strong></span></span>, and the path from the root to the rightmost node is called the  <span style="color: black"><span><strong><em>right spine</em></strong></span></span>. The function <span class="math inline">\(\texttt{join}~t_1~t_2\)</span> merges the right spine of <span class="math inline">\(t_1\)</span> with the left spine of <span class="math inline">\(t_2\)</span> based on the priority order. This ensures that the priorities are in decreasing order down the path.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Unlike the implementation of $\cd{split}$, the implementation of
$\cd{join}$ operates on priorities in order to ensure that the
resulting Treap satisfies the heap priority of Treaps.  Specifically,
given two trees, $\cd{join}$ first compares the priorities of the two
roots, making the larger priority the new root. It then recursively
joins the Treaps consisting of the other tree and the appropriate side
of the new root.
%

The path from the root to the leftmost node in a BST is called
the~\defn{left spine}, and the path from the root to the rightmost
node is called the~\defn{right spine}.  The function
$\cd{join}~t_1~t_2$ merges the right spine of $t_1$ with the left
spine of $t_2$ based on the priority order.  This ensures that the
priorities are in decreasing order down the path.

\end{dilFieldBodyDex}
\end{dilAtomGram}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR12:AT2
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR12:AT2:ex:bst::treap-join
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An illustration of <span class="math inline">\(\texttt{join}~t_1~t_2\)</span> on Treaps. If <span class="math inline">\(p(k_1) &gt; p(k_2)\)</span>, then the function recurs with <span class="math inline">\(\texttt{join}~R_1~t_2\)</span> and the result becomes the right child of <span class="math inline">\(k_1\)</span>.</p>
<p><img src="/media/210/bsts/treap-join.jpg" alt="image" style="width:15cm" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An illustration of $\cd{join}~t_1~t_2$ on Treaps.  
%
If $p(k_1) > p(k_2)$, then the function recurs with
$\cd{join}~R_1~t_2$ and the result becomes the right child of
$k_1$.
\begin{center}
  \includegraphics[width=15cm]{/media/210/bsts/treap-join.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR12:AT3
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR12:AT3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An illustration of <span class="math inline">\(\texttt{join}\)</span> for Treaps applied to <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> in more detail. The right spine of <span class="math inline">\(t_1\)</span> consisting of <span class="math inline">\((b,9)\)</span>, <span class="math inline">\((d,6)\)</span> and <span class="math inline">\((e,5)\)</span> is merged by priority with the left spine of <span class="math inline">\(t_2\)</span> consisting of <span class="math inline">\((h,8)\)</span> and <span class="math inline">\((g,4)\)</span>. Note that splitting the result with the key <span class="math inline">\(f\)</span> will return the original two trees.</p>
<p><img src="/media/210/bsts/treap-examp-join.jpg" alt="image" style="width:5.8in" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An illustration of $\cd{join}$ for Treaps applied to $t_1$ and $t_2$ in
  more detail.  The right spine of $t_1$ consisting of $(b,9)$,
  $(d,6)$ and $(e,5)$ is merged by priority with the left spine of
  $t_2$ consisting of $(h,8)$ and $(g,4)$.  Note that splitting the
  result with the key $f$ will return the original two trees.
\begin{center}
  \includegraphics[width=5.8in]{/media/210/bsts/treap-examp-join.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR13
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR13
\end{dilLabel}
\begin{dilNo}
13
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR13:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR13:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span id="thm:treapuniqueness" label="thm:treapuniqueness">[thm:treapuniqueness]</span> For a set of keys <span class="math inline">\(S\)</span>, if their priorities <span class="math inline">\(p(s) : s \in S\)</span> are unique, then there is exactly one Treap (i.e. shape) for <span class="math inline">\(S\)</span>.</p>
<p>(By induction on size) An empty tree is a leaf (base case). Otherwise, the unique key <span class="math inline">\(k\)</span> with the highest priority in <span class="math inline">\(S\)</span> must be at the root. This fixes the keys to the left (<span class="math inline">\(\left\{ k&#39; \in S \;|\; k&#39; &lt; k \right\}\)</span>) and to the right (<span class="math inline">\(\left\{ k&#39; \in S \;|\; k&#39; &gt; k \right\}\)</span>). By induction these are unique, so the whole tree is unique.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\begin{lemma}
\label{thm:treapuniqueness}
  For a set of keys $S$, if their priorities $p(s) : s \in S$ are unique,
  then there is exactly one Treap (i.e. shape) for $S$.

\begin{proof} (By induction on size)
An empty tree is a leaf (base case).  Otherwise, the unique key $k$
with the highest priority in $S$ must be at the root.  This fixes the
keys to the left ($\csetf{k' \in S}{k' < k}$) and to the right
($\csetf{k' \in S}{k' > k}$).  By induction these are unique, so the
whole tree is unique.
\end{proof}
\end{lemma}

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR14
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN8:GR14
\end{dilLabel}
\begin{dilNo}
14
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
Work of Split and Join
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Work of Split and Join
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN8:GR14:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN8:GR14:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Let’s bound now the work for <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span>. Each one does constant work on each recursive call. For <span class="math inline">\(\texttt{split}\)</span> each recursive call goes to one of the children, so the number of recursive calls is at most the height of <span class="math inline">\(t\)</span>. For <span class="math inline">\(\texttt{join}\)</span> each recursive call either goes down one level in <span class="math inline">\(t_1\)</span> or one level in <span class="math inline">\(t_2\)</span>. Therefore the number of recursive calls is bounded by the sum of the heights of the two trees. Hence the work of <span class="math inline">\(\texttt{split}\)</span> <span class="math inline">\(t\)</span> <span class="math inline">\(k\)</span> is <span class="math inline">\(O(h(t))\)</span> and the work of <span class="math inline">\(\texttt{join}\)</span><span class="math inline">\((t_1,m,t_2)\)</span> is <span class="math inline">\(O(h(t_1)+h(t_2))\)</span>. Thus all that is left to do is to bound the height of a Treap.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Let's bound now the work for $\cd{split}$ and $\cd{join}$.  
%
Each one does constant work on each recursive call.  
%
For $\cd{split}$ each recursive call goes to one of the children, so the
number of recursive calls is at most the height of $t$.  
%
For $\cd{join}$ each recursive call either goes down one level in $t_1$
or one level in $t_2$.  
%
Therefore the number of recursive calls is bounded by the sum of the
heights of the two trees.  
%
Hence the work of $\cd{split}$ $t$ $k$ is $O(h(t))$ and the work of
$\cd{join}$$(t_1,m,t_2)$ is $O(h(t_1)+h(t_2))$.  
%
Thus all that is left to do is to bound the height of a Treap.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Height Analysis of Treaps
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Height Analysis of Treaps
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC7:UN9
\end{dilLabel}
\begin{dilNo}
9
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN9:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN9:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We can analyze the height of a Treap by relating it to quicksort, which we analyzed before.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We can analyze the height of a Treap by relating it to quicksort,
 which we analyzed before.
%
% in \chref{randomized}.
%

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN9:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Treap Generating Quicksort
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Treap Generating Quicksort
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN9:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following variant of quick sort generates a treap. This algorithm is almost identical to our previous quicksort except that it uses <span class="math inline">\(\texttt{Node}\)</span> instead of <span class="math inline">\(\texttt{append},\)</span> and <span class="math inline">\(\texttt{Leaf}\)</span> instead of an empty sequence in the base case. Because it is generating a treap consisting of unique keys, the algorithm retains only one key equaling the pivot.</p>
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; \texttt{qsTree $a$ =} 
\\ 
2 &amp; ~~\texttt{if $|a| = 0$ then Leaf} 
\\ 
3 &amp; ~~\texttt{else} 
\\ 
4 &amp; ~~~~\texttt{let} 
\\ 
5 &amp; ~~~~~~\texttt{$x$ = the key $k \in a$ for which $p(k)$ is the largest} 
\\ 
6 &amp; ~~~~~~\texttt{$b$ = $\left\langle\, y \in a \;|\; y &lt; x \,\right\rangle$} 
\\ 
7 &amp; ~~~~~~\texttt{$c$ = $\left\langle\, y \in a \;|\; y &gt; x \,\right\rangle$} 
\\ 
8 &amp; ~~~~~~\texttt{$(l,r)$ = (qsTree $b$ ) || (qsTree $c$)} 
\\ 
9 &amp; ~~~~\texttt{in} 
\\ 
10 &amp; ~~~~~~\texttt{Node $(l, x, r)$} %\label{line:bst::qsnode} 
\\ 
11 &amp; ~~~~\texttt{end} 
\\ 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following variant of quick sort generates a treap.
%
This algorithm is almost identical to our previous quicksort except that it
uses $\cd{Node}$ instead of $\cd{append},$ and
% on \lineref{bst::qsnode},
%
$\cd{Leaf}$ instead of an empty sequence in the base case.
%
Because it is generating a treap consisting of unique keys, the
algorithm retains only one key equaling the pivot.
%

\[
\begin{array}{ll}
1 & \cd{qsTree $a$ =}
\\
2 & ~~\cd{if $|a| = 0$ then Leaf}
\\
3 & ~~\cd{else}
\\
4 & ~~~~\cd{let}
\\
5 & ~~~~~~\cd{$x$ = the key $k \in a$ for which $p(k)$ is the largest}
\\
6 & ~~~~~~\cd{$b$ = $\cseqf{y \in a}{y < x}$}
\\
7 & ~~~~~~\cd{$c$ = $\cseqf{y \in a}{y > x}$}
\\
8 & ~~~~~~\cd{$(l,r)$ = (qsTree $b$ ) || (qsTree $c$)}
\\
9 & ~~~~\cd{in}
\\
10 & ~~~~~~\cd{Node $(l, x, r)$} %\label{line:bst::qsnode}
\\
11 & ~~~~\cd{end}
\\
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC7:UN9:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC7:UN9:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC7:UN9:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The tree generated by <span class="math inline">\(\texttt{qsTree}(a)\)</span> is the Treap for the sequence <span class="math inline">\(a\)</span>. This can be seen by induction. It is true for the base case. Now assume by induction it is true for the trees returned by the two recursive calls. The tree returned by the main call is then also a Treap since the pivot <span class="math inline">\(x\)</span> has the highest priority, and therefore is correctly placed at the root, the subtrees and in heap order by induction, and because the keys in <span class="math inline">\(l\)</span> are less than the pivot, and the keys in <span class="math inline">\(r\)</span> are greater than the pivot, the tree has the BST property.</p>
<p>Based on this isomorphism, we can bound the height of a Treap by the recursion depth of quicksort. Recall that we proved that if we pick the priorities at random, the recursion depth is <span class="math inline">\(O(\lg{n})\)</span> with high probability. Therefore we know that the height of a Treap is <span class="math inline">\(O(\lg{n})\)</span> with high probability.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The tree generated by $\cd{qsTree}(a)$ is the Treap for the sequence
$a$.  
%
This can be seen by induction.  
%
It is true for the base case.
%
Now assume by induction it is true for the trees returned by the two
recursive calls.  
%
The tree returned by the main call is then also a Treap since the
pivot $x$ has the highest priority, and therefore is correctly placed
at the root, the subtrees and in heap order by induction, and because
the keys in $l$ are less than the pivot, and the keys in $r$ are
greater than the pivot, the tree has the BST property.

Based on this isomorphism, we can bound the height of a Treap by the
recursion depth of quicksort.
%  In \chref{randomized}, 
% 
Recall that we proved that if we pick the priorities at random, the
recursion depth is $O(\lg{n})$ with high probability.  Therefore we
know that the height of a Treap is $O(\lg{n})$ with high probability.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilSection}
\begin{dilFieldTitle}
Augmenting Trees
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Augmenting Trees
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8
\end{dilFieldUnique}
\begin{dilLabel}
section:15210:S18:CH12:SEC8
\end{dilLabel}
\begin{dilNo}
8
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilIntro}
<p>Thus far in this chapter, the only interesting information that we stored in BSTs were keys. While such trees can be useful, we sometimes wish to augment trees with more information. In this section, we describe how we might augment BSTs with additional information such as key-value pairs, subtree sizes, and reduced values in general.</p>

\end{dilIntro}
\begin{dilIntroDex}


Thus far in this chapter, the only interesting information that we
stored in BSTs were keys. While such trees can be useful, we
sometimes wish to augment trees with more information. 
%
In this section, we describe how we might augment BSTs with
additional information such as key-value pairs, subtree sizes, and
reduced values in general.
\end{dilIntroDex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Augmenting with Key-Value Pairs
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Augmenting with Key-Value Pairs
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN10
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC8:UN10
\end{dilLabel}
\begin{dilNo}
10
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN10:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN10:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachNote}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN10:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN10:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Can you think of an application where we would want to associate a value with each key?</p>
<p>For example, you might want to maintain an address book as a BST keyed by the names of your friends and associate each name with a phone number or email. Such a BST would allow you to locate the phone number of your friend quickly, while also allowing you to do other operations such as joining two address books, and updating entries.</p>
<p>How can we change a BST data structure to associate values with keys?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Can you think of an application where we would want to associate a
value with each key?

For example, you might want to maintain an address book as a BST keyed
by the names of your friends and associate each name with a phone
number or email.  Such a BST would allow you to locate the phone
number of your friend quickly, while also allowing you to do other
operations such as joining two address books, and updating entries.

%
How can we change a BST data structure to associate values with keys?

\end{dilFieldBodyDex}
\end{dilAtomTeachNote}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN10:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN10:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN10:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN10:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Perhaps the simplest form of augmentation involves storing in the BST a key-value pair instead of just a key. Implementing BSTs augmented with key-value pairs is relatively straightforward by updating the relevant parts of the ADT. For example, to accommodate the key, we can change the BST data type to a key-value pair, and update the implementation of the functions to pass the value around with the key as needed, making sure that a key-value pair is never separated. For functions such as <span class="math inline">\(\texttt{find}\)</span> and <span class="math inline">\(\texttt{split}\)</span> that may return the value, we make sure to do so.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Perhaps the simplest form of augmentation involves storing in the BST
a key-value pair instead of just a key.
%
Implementing BSTs augmented with key-value pairs is relatively
straightforward by updating the relevant parts of the ADT.
%
For example, to accommodate the key, we can change the BST data type
to a key-value pair, and update the implementation of the functions to
pass the value around with the key as needed, making sure that a
key-value pair is never separated.  For functions such as $\cd{find}$
and $\cd{split}$ that may return the value, we make sure to do so.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Augmenting with Size
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Augmenting with Size
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC8:UN11
\end{dilLabel}
\begin{dilNo}
11
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>As a more complex augmentation, we might want to associate with each node in the tree a size field that tells us how large the subtree rooted at that node is. As a motivating example for this form of augmentation, suppose that we wish to extend the BST ADT with the following additional functions.</p>
<ul>
<li><p>Function <span class="math inline">\(\texttt{rank}~t~k\)</span> returns the rank of the key <span class="math inline">\(k\)</span> in the tree, i.e., the number of keys in <span class="math inline">\(t\)</span> that are less than or equal to <span class="math inline">\(k\)</span>.</p></li>
<li><p>Function <span class="math inline">\(\texttt{select}~T~i\)</span> returns the key with the rank <span class="math inline">\(i\)</span> in <span class="math inline">\(t\)</span>.</p></li>
</ul>
<p>Such functions arise in many applications. For example, we can use them to implement sequences.</p>
<p>If we have a way to count the number of nodes in a subtree, then we can easily implement these functions. The algorithm below shows such an implementation by using a size operation for computing the size of a tree, written <span class="math inline">\(|t|\)</span> for tree <span class="math inline">\(t\)</span>. With balanced trees such as Treaps, the <span class="math inline">\(\texttt{rank}\)</span> and <span class="math inline">\(\texttt{select}\)</span> functions require logarithmic span but linear work, because computing the size of a subtree takes linear time in the size of the subtree.</p>
<p>If, however, we augment the tree so that at each node, we store the size of the subtree rooted at that node, then work becomes logarithmic, because we can find the size of a subtree in constant work.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
As a more complex augmentation, we might want to associate with each
node in the tree a size field that tells us how large the subtree
rooted at that node is.
%
As a motivating example for this form of augmentation, suppose that we
wish to extend the BST ADT
% (\adtref{bst::adt}) 
with the following
additional functions.
%
\begin{itemize}
\item Function $\cd{rank}~t~k$ returns the rank of the key $k$ in
  the tree, i.e., the number of keys in $t$ that are less than or
  equal to $k$.

\item Function $\cd{select}~T~i$ returns the key with the rank $i$ in $t$.

\end{itemize}
%
Such functions arise in many applications.  For example, we can use
them to implement sequences.
%
% the sequence interface discussed in \chref{sequences}. 

If we have a way to count the number of nodes in a subtree, then we
can easily implement these functions.
%
%\algref{bst::augment::size} 
%
The algorithm below shows such an implementation by using a size
operation for computing the size of a tree, written $|t|$ for tree
$t$.
%
%
With balanced trees such as Treaps, the $\cd{rank}$ and $\cd{select}$
functions require logarithmic span but linear work, because computing
the size of a subtree takes linear time in the size of the subtree.
%

%
If, however, we augment the tree so that at each node, we store the
size of the subtree rooted at that node, then work becomes
logarithmic, because we can find the size of a subtree in constant
work.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Rank
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Rank
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; \texttt{rank $t$ $k$ =} 
\\ 
2 &amp; ~~\texttt{case $t$ } 
\\ 
3 &amp; ~~\texttt{| Leaf $\Rightarrow$ $0$} 
\\ 
4 &amp; ~~\texttt{| Node $(l,k&#39;,r)$ $\Rightarrow$} 
\\ 
5 &amp; ~~~~~~\texttt{case compare $(k,k&#39;)$ } 
\\ 
6 &amp; ~~~~~~\texttt{| LESS $\Rightarrow$ rank $l$ $k$} 
\\ 
7 &amp; ~~~~~~\texttt{| EQUAL $\Rightarrow$ $|l|$} 
\\ 
8 &amp; ~~~~~~\texttt{| GREATER $\Rightarrow$ $|l| + 1 +$ rank $r$ $k$} 
\\ 
~&amp;~ 
\\ 
9 &amp; \texttt{select $t$ $i$ =} 
\\ 
10 &amp; ~~\texttt{case $t$ } 
\\ 
11 &amp; ~~\texttt{| Leaf $\Rightarrow$ raise exception OutOfRange} 
\\ 
12 &amp; ~~\texttt{| Node $(l,k,r)$ $\Rightarrow$} 
\\ 
13 &amp; ~~~~~~\texttt{case compare $(i,|l|)$ of} 
\\ 
14 &amp; ~~~~~~~~\texttt{LESS $\Rightarrow$ select $l$ $i$} 
\\ 
15 &amp; ~~~~~~~~\texttt{EQUAL $\Rightarrow$ $k$} 
\\ 
16 &amp; ~~~~~~~~\texttt{GREATER $\Rightarrow$ select $r$ $(i-|l|-1)$} 
\\ 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
\begin{array}{ll}
1 & \cd{rank $t$ $k$ =}
\\
2 & ~~\cd{case $t$ }
\\
3 & ~~\cd{| Leaf $\Rightarrow$ $0$}
\\
4 & ~~\cd{| Node $(l,k',r)$ $\Rightarrow$}
\\
5 & ~~~~~~\cd{case compare $(k,k')$ }
\\
6 & ~~~~~~\cd{| LESS $\Rightarrow$ rank $l$ $k$}
\\
7 & ~~~~~~\cd{| EQUAL $\Rightarrow$ $|l|$}
\\
8 & ~~~~~~\cd{| GREATER $\Rightarrow$ $|l| + 1 +$ rank $r$ $k$}
\\
~&~
\\
9 & \cd{select $t$ $i$ =}
\\
10 & ~~\cd{case $t$ }
\\
11 & ~~\cd{| Leaf $\Rightarrow$ raise exception OutOfRange}
\\
12 & ~~\cd{| Node $(l,k,r)$ $\Rightarrow$}
\\
13 & ~~~~~~\cd{case compare $(i,|l|)$ of}
\\
14 & ~~~~~~~~\cd{LESS $\Rightarrow$ select $l$ $i$}
\\
15 & ~~~~~~~~\cd{EQUAL $\Rightarrow$ $k$}
\\
16 & ~~~~~~~~\cd{GREATER $\Rightarrow$ select $r$ $(i-|l|-1)$}
\\
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR3:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>Can you implement these functions by using a BST?</p>
<p>What is the work and span of these functions?</p>
<p>Can we compute size of subtrees more efficiently?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
Can you implement these functions by using a BST? 

What is the work and span of these functions?

Can we compute size of subtrees more efficiently?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>An example BST, where keys are ordered lexicographically and the nodes are augmented with the sizes of subtrees. The path explored by <span class="math inline">\(\texttt{rank (T,n)}\)</span> and <span class="math inline">\(\texttt{select (T,4)}\)</span> is highlighted.</p>
<p><img src="/media/210/bsts/rankSelect.jpg" alt="image" style="width:2.5in" /></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
An example BST, where keys are ordered lexicographically and the nodes
are augmented with the sizes of subtrees.
%
The path explored by $\cd{rank (T,n)}$ and $\cd{select (T,4)}$ is
highlighted.

\begin{center}
  \includegraphics[width=2.5in]{/media/210/bsts/rankSelect.jpg}
\end{center}

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomTeachAsk}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>But how can we maintain the sizes of the subtrees as we perform various operations on the BST such as possibly aggregate insertions, deletions, splits, and joins?</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
But how can we maintain the sizes of the subtrees as we perform
  various operations on the BST such as possibly aggregate insertions,
  deletions, splits, and joins?

\end{dilFieldBodyDex}
\end{dilAtomTeachAsk}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN11:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN11:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN11:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To implement a size-augmented tree, we need to keep <span class="math inline">\(\texttt{size}\)</span> field at each node and compute the size of the nodes as they are created. In our parametric implementation, we can incorporate the <span class="math inline">\(\texttt{size}\)</span> field by changing the definition of a node and initializing it to <span class="math inline">\(1\)</span>, when a singleton tree is created. When <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> functions create a new node, they can compute its size by summing the sizes of its children.</p>
<p>In addition to the <span class="math inline">\(\texttt{rank}\)</span> and <span class="math inline">\(\texttt{select}\)</span> functions, we can also define the function <span class="math inline">\(\texttt{splitRank}(T,i)\)</span>, which splits the tree into two by returning the trees <span class="math inline">\(t_1\)</span> and <span class="math inline">\(t_2\)</span> such that <span class="math inline">\(t_1\)</span> contains all keys with rank less than <span class="math inline">\(i\)</span> and <span class="math inline">\(t_2\)</span> contains all keys with rank is greater or equal to <span class="math inline">\(i\)</span>. Such a function can be used for example to write divide-and-conquer algorithms on imperfectly balanced trees.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To implement a size-augmented tree, we need to keep $\cd{size}$ field at
each node and compute the size of the nodes as they are created.
%
In our parametric implementation, we can incorporate the $\cd{size}$
field by changing the definition of a node and initializing it to $1$,
when a singleton tree is created. 
%
When $\cd{split}$ and $\cd{join}$ functions create a new node, they
can compute its size by summing the sizes of its children.
%

In addition to the $\cd{rank}$ and $\cd{select}$ functions, we can
also define the function $\cd{splitRank}(T,i)$, which splits the
tree into two by returning the trees $t_1$ and $t_2$ such that $t_1$
contains all keys with rank less than $i$ and $t_2$ contains all keys
with rank is greater or equal to $i$. 
%
Such a function can be used for example to write divide-and-conquer
algorithms on imperfectly balanced trees.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}

\end{dilUnit}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilUnit}
\begin{dilFieldTitle}
Augmenting with Reduced Values
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Augmenting with Reduced Values
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12
\end{dilFieldUnique}
\begin{dilLabel}
unit:15210:S18:CH12:SEC8:UN12
\end{dilLabel}
\begin{dilNo}
12
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR1
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR1:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR1:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>To compute rank-based properties of keys in a BST, we augmented the BST so that each node stores the size of its subtree. More generally, we might want to associate with each node a  <span style="color: black"><span><strong><em>reduced value</em></strong></span></span> that is computed by reducing over the subtree rooted at the node by a user specified function. In general, there is no restriction on how the reduced values may be computed, they can be based on keys or additional values that the tree is augmented with. To compute reduced values, we simply store with every node <span class="math inline">\(u\)</span> of a binary search tree, the reduced value of its subtree (i.e. the sum of all the reduced values that are descendants of <span class="math inline">\(u\)</span>, possibly also the value at <span class="math inline">\(u\)</span> itself).</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
To compute rank-based properties of keys in a BST, we augmented the
BST so that each node stores the size of its subtree.  More generally,
we might want to associate with each node a~\defn{reduced value} that
is computed by reducing over the subtree rooted at the node by a user
specified function.  In general, there is no restriction on how the
reduced values may be computed, they can be based on keys or
additional values that the tree is augmented with.
%
To compute reduced values, we simply store with every node $u$ of a
binary search tree, the reduced value of its subtree (i.e. the sum of
all the reduced values that are descendants of $u$, possibly also the
value at $u$ itself).

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR2
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR2
\end{dilLabel}
\begin{dilNo}
2
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR2:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR2:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following drawing shows a tree with key-value pairs on the left, and the augmented tree on the right, where each node additionally maintains the sum of it subtree.</p>
<p><img src="/media/210/bsts/augtree.jpg" alt="image" style="width:4in" /></p>
<p>The sum at the root (<span class="math inline">\(13\)</span>) is the sum of all values in the tree (<span class="math inline">\(3 + 
1 + 2 + 2 + 5\)</span>). It is also the sum of the reduced values of its two children (<span class="math inline">\(6\)</span> and <span class="math inline">\(5\)</span>) and its own value <span class="math inline">\(2\)</span>.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following drawing shows a tree with key-value pairs on the left,
  and the augmented tree on the right, where each node additionally
  maintains the sum of it subtree.
\begin{center}
  \includegraphics[width=4in]{/media/210/bsts/augtree.jpg}
\end{center}
The sum at the root ($13$) is the sum of all values in the tree ($3 +
1 + 2 + 2 + 5$).    It is also the sum of the reduced values of its
two children ($6$ and $5$) and its own value $2$.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR3
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR3
\end{dilLabel}
\begin{dilNo}
3
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomAlgorithm}
\begin{dilFieldTitle}
Treaps with Reduced Values
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
Treaps with Reduced Values
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR3:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR3:AT1:fig:bst::reducedjoin
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; \texttt{(* type of the reduced value, as specified. *)} 
\\ 
2 &amp; \texttt{type rv = ...                   } 
\\ 
~&amp;~ 
\\ 
3 &amp; \texttt{(* associative reducer function, as specified. *)} 
\\ 
4 &amp; \texttt{$f$(x: rv, y: val, z: rv): rv = ...  } 
\\ 
~&amp;~ 
\\ 
5 &amp; \texttt{(* identity for the reducer function, as specified. *)} 
\\ 
6 &amp; \texttt{$id_f$ : rv = ...                 } 
\\ 
~&amp;~ 
\\ 
7 &amp; \texttt{type treap = } 
\\ 
8 &amp; ~~~\texttt{Leaf } 
\\ 
9 &amp; ~\texttt{| Node of (Treap $\times$ key $\times$ priority  $\times$ (val $\times$ rv) $\times$ Treap) } 
\\ 
~&amp;~ 
\\ 
10 &amp; \texttt{rvOf $t$ =} 
\\ 
11 &amp; ~~\texttt{case $t$} 
\\ 
12 &amp; ~~\texttt{| Leaf $\Rightarrow$ $id_f$} 
\\ 
13 &amp; ~~\texttt{| Node (_,_,_(_,w),_) $\Rightarrow$ w} 
\\ 
~&amp;~ 
\\ 
14 &amp; \texttt{mkNode $(l,k,p,v,r)$ = Node ($l$,$k$,$p$,($v$,$f$ (rvOf $l$,$v$,rvOf $r$)),$r$) } 
\\ 
~&amp;~ 
\\ 
15 &amp; \texttt{split $t$ $k$ = } 
\\ 
16 &amp; ~~\texttt{case t } 
\\ 
17 &amp; ~~\texttt{| Leaf $\Rightarrow$ (Leaf,false,Leaf)} 
\\ 
18 &amp; ~~\texttt{| Node $(l,k&#39;,p&#39;,(v&#39;,w&#39;),r)$ =} 
\\ 
19 &amp; ~~~~~~\texttt{case compare $(k,k&#39;)$} 
\\ 
20 &amp; ~~~~~~\texttt{| LESS $\Rightarrow$ } 
\\ 
21 &amp; ~~~~~~~~~~\texttt{let $(l&#39;,x,r&#39;)$ = split $l$ $k$} 
\\ 
22 &amp; ~~~~~~~~~~\texttt{in $(l&#39;,x,\texttt{mkNode}~(r&#39;,k&#39;,p&#39;,v&#39;,r))$ end } 
\\ 
23 &amp; ~~~~~~\texttt{| EQUAL $\Rightarrow$ $($$l$,true,$r$$)$} 
\\ 
24 &amp; ~~~~~~\texttt{| GREATER $\Rightarrow$} 
\\ 
25 &amp; ~~~~~~~~~~\texttt{let $(l&#39;,x,r&#39;)$ = split $r$ $k$} 
\\ 
26 &amp; ~~~~~~~~~~\texttt{in (mkNode $(l,k&#39;,p&#39;,v&#39;,l&#39;),x,r&#39;$) end } 
\\ 
~&amp;~ 
\\ 
27 &amp; \texttt{join $t_1$ $t_2$ =} 
\\ 
28 &amp; ~~\texttt{case $(t_1,t_2)$ of} 
\\ 
29 &amp; ~~~~\texttt{(Leaf, _) $\Rightarrow$ $t_2$} 
\\ 
30 &amp; ~~\texttt{| (_, Leaf) $\Rightarrow$ $t_1$} 
\\ 
31 &amp; ~~\texttt{| (Node $(l_1,k_1,p_1,(v_1,w_1),r_1)$, Node $(l_2,k_2,p_2,(v_2,w_2),r_2)$) $\Rightarrow$} 
\\ 
32 &amp; ~~~~~~\texttt{if $p_1$ &gt; $p_2$) then mkNode 
  ($l_1$,$k_1$,$p_1$,$v_1$,join $r_1$ $t_2$)       } %  \label{line:bst::reducedjoin::cpri}  
\\ 
33 &amp; ~~~~~~\texttt{else mkNode (join $t_1$ $l_2$,$k_2$,$v_2$,$r_2$)} 
\\ 
\end{array}\]</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
\[
\begin{array}{ll}
1 & \cd{(* type of the reduced value, as specified. *)}
\\
2 & \cd{type rv = ...                   }
\\
~&~
\\
3 & \cd{(* associative reducer function, as specified. *)}
\\
4 & \cd{$f$(x: rv, y: val, z: rv): rv = ...  }
\\
~&~
\\
5 & \cd{(* identity for the reducer function, as specified. *)}
\\
6 & \cd{$id_f$ : rv = ...                 }
\\
~&~
\\
7 & \cd{type treap = }
\\
8 & ~~~\cd{Leaf }
\\
9 & ~\cd{| Node of (Treap $\times$ key $\times$ priority  $\times$ (val $\times$ rv) $\times$ Treap) }
\\
~&~
\\
10 & \cd{rvOf $t$ =}
\\
11 & ~~\cd{case $t$}
\\
12 & ~~\cd{| Leaf $\Rightarrow$ $id_f$}
\\
13 & ~~\cd{| Node (_,_,_(_,w),_) $\Rightarrow$ w}
\\
~&~
\\
14 & \cd{mkNode $(l,k,p,v,r)$ = Node ($l$,$k$,$p$,($v$,$f$ (rvOf $l$,$v$,rvOf $r$)),$r$) }
\\
~&~
\\
15 & \cd{split $t$ $k$ = }
\\
16 & ~~\cd{case t }
\\
17 & ~~\cd{| Leaf $\Rightarrow$ (Leaf,false,Leaf)}
\\
18 & ~~\cd{| Node $(l,k',p',(v',w'),r)$ =}
\\
19 & ~~~~~~\cd{case compare $(k,k')$}
\\
20 & ~~~~~~\cd{| LESS $\Rightarrow$ }
\\
21 & ~~~~~~~~~~\cd{let $(l',x,r')$ = split $l$ $k$}
\\
22 & ~~~~~~~~~~\cd{in $(l',x,\cd{mkNode}~(r',k',p',v',r))$ end }
\\
23 & ~~~~~~\cd{| EQUAL $\Rightarrow$ $($$l$,true,$r$$)$}
\\
24 & ~~~~~~\cd{| GREATER $\Rightarrow$}
\\
25 & ~~~~~~~~~~\cd{let $(l',x,r')$ = split $r$ $k$}
\\
26 & ~~~~~~~~~~\cd{in (mkNode $(l,k',p',v',l'),x,r'$) end }
\\
~&~
\\
27 & \cd{join $t_1$ $t_2$ =}
\\
28 & ~~\cd{case $(t_1,t_2)$ of}
\\
29 & ~~~~\cd{(Leaf, _) $\Rightarrow$ $t_2$}
\\
30 & ~~\cd{| (_, Leaf) $\Rightarrow$ $t_1$}
\\
31 & ~~\cd{| (Node $(l_1,k_1,p_1,(v_1,w_1),r_1)$, Node $(l_2,k_2,p_2,(v_2,w_2),r_2)$) $\Rightarrow$}
\\
32 & ~~~~~~\cd{if $p_1$ > $p_2$) then mkNode
  ($l_1$,$k_1$,$p_1$,$v_1$,join $r_1$ $t_2$)       } %  \label{line:bst::reducedjoin::cpri} 
\\
33 & ~~~~~~\cd{else mkNode (join $t_1$ $l_2$,$k_2$,$v_2$,$r_2$)}
\\
\end{array}
\]

\end{dilFieldBodyDex}
\end{dilAtomAlgorithm}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR4
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR4
\end{dilLabel}
\begin{dilNo}
4
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR4:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR4:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The value of each reduced value in a tree can be calculated as the sum of its two children plus the value stored at the node. This means that we can maintain these reduced values by simply taking the “sum” of three values whenever creating a node. We can thus change a data structure to support reduced values by changing the way we create nodes. In such a data structure, if the function that we use for reduction performs constant work, then the work and the span bound for the data structure remains unaffected.</p>
<p>As an example, the data structure above describes an extension of the parametric implementation of Treaps to support reduced values. The description is parametric in the values paired with keys and the function <span class="math inline">\(\texttt{f}\)</span> used for reduction. The type for Treaps is extended to store the value paired with the key as well as the reduced value. Specifically, in a <span class="math inline">\(\texttt{Node},\)</span> the first data entry is the value paired by the key and the second is the reduced value.</p>
<p>To compute reduced values as the structure of the tree changes, the implementation relies on an auxiliary function <span class="math inline">\(\texttt{mkNode}\)</span> (read “make node”) that takes the key-value pair as well as the left and right subtrees and computes the reduced value by applying reducer function to the values of the left and right subtrees as well as the value. The only difference in the implementation of <span class="math inline">\(\texttt{split}\)</span> and <span class="math inline">\(\texttt{join}\)</span> functions from the parametric implementations is the use of <span class="math inline">\(\texttt{mkNode}\)</span> instead of <span class="math inline">\(\texttt{Node}.\)</span></p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The value of each reduced value in a tree can be calculated as the sum
of its two children plus the value stored at the node.  This means
that we can maintain these reduced values by simply taking the
``sum'' of three values whenever creating a node.  We can thus change
a data structure to support reduced values by changing the way we
create nodes.  In such a data structure, if the function that we use
for reduction performs constant work, then the work and the span bound
for the data structure remains unaffected.

As an example, the data structure above
%
%\figref{bst::reducedjoin} 
%
describes an extension of the parametric implementation of Treaps to
support reduced values.  The description is parametric in the values
paired with keys and the function $\cd{f}$ used for reduction.
%
The type for Treaps is extended to store the value paired with the key
as well as the reduced value.  Specifically, in a $\cd{Node},$ the
first data entry is the value paired by the key and the second is the
reduced value.
%


To compute reduced values as the structure of the tree changes, the
implementation relies on an auxiliary function $\cd{mkNode}$ (read
``make node'') that takes the key-value pair as well as the left and
right subtrees and computes the reduced value by applying reducer
function to the values of the left and right subtrees as well as the
value.
%
The only difference in the implementation of $\cd{split}$ and
$\cd{join}$ functions from the parametric implementations is the use
of $\cd{mkNode}$ instead of $\cd{Node}.$

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR5
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR5
\end{dilLabel}
\begin{dilNo}
5
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomExample}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR5:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR5:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>The following diagram shows an example of splitting an augmented tree.</p>
<p><img src="/media/210/bsts/augtree-split.jpg" alt="image" style="width:5in" /></p>
<p>The tree is split by the key <span class="math inline">\(c\)</span>, and the reduced values on the internal nodes need to be updated. This only needs to happen along the path that created the split, which in this case is <span class="math inline">\(e\)</span>, <span class="math inline">\(b\)</span>, and <span class="math inline">\(d\)</span>. The node for <span class="math inline">\(d\)</span> does not have to be updated since it is a leaf. The <span class="math inline">\(\texttt{makeNode}\)</span> for <span class="math inline">\(e\)</span> and <span class="math inline">\(b\)</span> are what will update the reduced values for those nodes.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
The following diagram shows an example of splitting an augmented tree.
\begin{center}
  \includegraphics[width=5in]{/media/210/bsts/augtree-split.jpg}
\end{center}
The tree is split by the key $c$, and the reduced values on the
internal nodes need to be updated.  This only needs to happen along
the path that created the split, which in this case is $e$, $b$, and
$d$.  The node for $d$ does not have to be updated since it is a leaf.
The $\cd{makeNode}$ for $e$ and $b$ are what will update the reduced
values for those nodes.

\end{dilFieldBodyDex}
\end{dilAtomExample}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR6
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR6
\end{dilLabel}
\begin{dilNo}
6
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomGram}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR6:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR6:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>We note that this idea can be used with any binary search tree, not just Treaps. We only need to replace the function for creating a node so that as it creates the node, it also computes a reduced value for the node by summing the reduced values of the children and the value of the node itself.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
We note that this idea can be used with any binary search tree, not
just Treaps.  We only need to replace the function for creating a node
so that as it creates the node, it also computes a reduced value for
the node by summing the reduced values of the children and the value
of the node itself.

\end{dilFieldBodyDex}
\end{dilAtomGram}
\end{dilGroup}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilGroup}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR7
\end{dilFieldUnique}
\begin{dilLabel}
group:15210:S18:CH12:SEC8:UN12:GR7
\end{dilLabel}
\begin{dilNo}
7
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{dilAtomRemark}
\begin{dilFieldTitle}
...NO.TITLE...
\end{dilFieldTitle}
\begin{dilFieldTitleDex}
...NO.TITLE...
\end{dilFieldTitleDex}
\begin{dilFieldUnique}
15210:S18:CH12:SEC8:UN12:GR7:AT1
\end{dilFieldUnique}
\begin{dilLabel}
atom:15210:S18:CH12:SEC8:UN12:GR7:AT1
\end{dilLabel}
\begin{dilNo}
1
\end{dilNo}
\begin{dilParents}
...NO.PARENTS...
\end{dilParents}
\begin{dilFieldBody}
<p>In an imperative implementation of binary search trees, when a child node is side affected, the reduced values for the nodes on the path from the modified node to the root must be recomputed.</p>

\end{dilFieldBody}
\begin{dilFieldBodyDex}
In an imperative implementation of binary search trees, when a child
  node is side affected, the reduced values for the nodes on the path
  from the modified node to the root must be recomputed.

\end{dilFieldBodyDex}
\end{dilAtomRemark}
\end{dilGroup}

\end{dilUnit}
\end{dilSection}
\end{dilChapter}
\end{dilBook}
\end{dilCourse}
