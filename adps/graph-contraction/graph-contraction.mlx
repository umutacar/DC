<?xml version = "1.0"?>
<mlxCourse>
<mlxFieldTitle>
Parallel and Sequential Algorithms
</mlxFieldTitle>
<mlxFieldTitleDex>
Parallel and Sequential Algorithms
</mlxFieldTitleDex>
<mlxFieldUnique>
15210
</mlxFieldUnique>
<mlxLabel>
15210
</mlxLabel>
<mlxNo>
15210
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldCourseNumber>
15210
</mlxFieldCourseNumber>
<mlxFieldPicture>
/210/course/air-pavilion.jpg
</mlxFieldPicture>
<mlxFieldSemester>
Spring 2018
</mlxFieldSemester>
<mlxFieldWebsite>
http://www.cs.cmu.edu/~15210
</mlxFieldWebsite>
<mlxFieldProvidesBook>
S18
</mlxFieldProvidesBook>
<mlxFieldProvidesChapter>
101
</mlxFieldProvidesChapter>
<mlxFieldProvidesSection>
1
</mlxFieldProvidesSection>
<mlxFieldProvidesUnit>
1
</mlxFieldProvidesUnit>
<mlxFieldProvidesAssignment>
1
</mlxFieldProvidesAssignment>
<mlxIntro>
<p>15-210 aims to teach methods for designing, analyzing, and programming sequential and parallel algorithms and data structures. The emphasis is on teaching fundamental concepts applicable across a wide variety of problem domains, and transferable across a reasonably broad set of programming languages and computer architectures. This course also includes a significant programming component in which students will program concrete examples from domains such as engineering, scientific computing, graphics, data mining, and information retrieval (web search).</p>
<p>Unlike a traditional introduction to algorithms and data structures, this course puts an emphasis on parallel thinking — i.e., thinking about how algorithms can do multiple things at once instead of one at a time. The course follows up on material learned in 15-122 and 15-150 but goes into significantly more depth on algorithmic issues.</p>

</mlxIntro>
<mlxIntroDex>
15-210 aims to teach methods for designing, analyzing, and programming
sequential and parallel algorithms and data structures. The emphasis
is on teaching fundamental concepts applicable across a wide variety
of problem domains, and transferable across a reasonably broad set of
programming languages and computer architectures. This course also
includes a significant programming component in which students will
program concrete examples from domains such as engineering, scientific
computing, graphics, data mining, and information retrieval (web
search).

Unlike a traditional introduction to algorithms and data structures,
this course puts an emphasis on parallel thinking — i.e., thinking
about how algorithms can do multiple things at once instead of one at
a time. The course follows up on material learned in 15-122 and 15-150
but goes into significantly more depth on algorithmic issues.
</mlxIntroDex>

<mlxBook>
<mlxFieldTitle>
Algorithm Design: Parallel and Sequential
</mlxFieldTitle>
<mlxFieldTitleDex>
Algorithm Design: Parallel and Sequential
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18
</mlxFieldUnique>
<mlxLabel>
book:15210:S18
</mlxLabel>
<mlxNo>
0
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldAuthors>
Umut A. Acar and Guy Blelloch
</mlxFieldAuthors>

<mlxChapter>
<mlxFieldTitle>
Graph Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Graph Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101
</mlxFieldUnique>
<mlxLabel>
chapter:15210:S18:CH101:ch:graph-search
</mlxLabel>
<mlxNo>
101
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldPicture>
./media/stary-night.jpg
</mlxFieldPicture>
<mlxIntro>
<p>In earlier chapters, we have mostly covered techniques for solving problems on graphs that were developed in the context of sequential algorithms. Some of them are easy to parallelize while others are not. For example, we saw that BFS has some parallelism since each level can be explored in parallel, but there was no parallelism in DFS. There was limited parallelism in Dijkstra’s algorithm, but there was plenty of parallelism in the Bellman-Ford algorithm. In this chapter we cover a technique called “graph contraction” that was specifically designed to be used in parallel algorithms and that allows obtaining poly-logarithmic span for certain graph problems.</p>

</mlxIntro>
<mlxIntroDex>





In earlier chapters, we have mostly covered techniques for solving
problems on graphs that were developed in the context of sequential
algorithms.  Some of them are easy to parallelize while others are
not.  For example, we saw that BFS has some parallelism since each
level can be explored in parallel, but there was no parallelism in
DFS.
%% Umut: this is unclear to me also sounds forced.  We are ok with 
%% sequential algorithms anyway.  We want to cover them.
%%
% \footnote{In
%   reality, there is parallelism in DFS when graphs are dense---in
%   particular, although vertices need to visited sequentially, with
%   some care, the edges
%   can be processed in parallel.}  
%%
There was limited parallelism in Dijkstra's algorithm, but there was
plenty of parallelism in the Bellman-Ford algorithm.
%
In this chapter we cover a technique called ``graph contraction''
that was specifically designed to be used in parallel algorithms and
that allows obtaining poly-logarithmic span for certain graph problems.
</mlxIntroDex>

<mlxSection>
<mlxFieldTitle>
Preliminaries
</mlxFieldTitle>
<mlxFieldTitleDex>
Preliminaries
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC1:UN1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Please review the material on graphs () before proceeding with the rest of this chapter, especially the sections on subgraphs and connectivity.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Please review the material on graphs (\secref{graph-theory}) before
  proceeding with the rest of this chapter, especially the sections on
  subgraphs and connectivity.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>This chapter relies on graph terminology presented is an earlier chapter: <a href="http://diderot-cmu.appspot.com/chapters/10/#anchor-section-17" class="uri">http://diderot-cmu.appspot.com/chapters/10/#anchor-section-17</a> One important concept used in this chapter is the notion of graph partition, which is a collection of graphs defined as vertex-induced graphs of a set partition of its vertices.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
This chapter relies on graph terminology presented is an
earlier chapter:
%
\url{http://diderot-cmu.appspot.com/chapters/10/#anchor-section-17}
%

%% We review here the definition of graph partition.
%% %
%% Recall that a partition of a set $A$ is a set $P$ of non-empty subsets
%% of $A$ such that each element of $A$ is in exactly one subset $B \in
%% P$; each susbet $B \in P$ is called a~\defn{part} or~\defn{block.}
%% %
One important concept used in this chapter is the notion of graph
partition, which is a collection of graphs defined as vertex-induced
graphs of a set partition of its vertices.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Given a graph <span class="math inline">\(G\)</span>, a <span> </span> of <span class="math inline">\(G\)</span> is a collection of graphs <span class="math inline">\(H_0 = (V_0, E_0), \ldots, H_{k-1} = (V_{k_1}, E_{k-1})\)</span> such that <span class="math inline">\(\{V_0, \ldots, V_{k-1}\}\)</span> is a set partition of <span class="math inline">\(V\)</span> and <span class="math inline">\(H_0, \ldots, H_{k-1}\)</span> are vertex-induced subgraphs of <span class="math inline">\(G\)</span> with respect to <span class="math inline">\(V_0, \ldots, V_{k-1}\)</span>. Each subgraph <span class="math inline">\(H_i\)</span> is called a <span> </span> or <span> </span> of <span class="math inline">\(G\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Given a graph $G$, 
%
a~\defn{graph partition} of $G$ is a collection of graphs 
%
$H_0 = (V_0, E_0), \ldots, H_{k-1} = (V_{k_1}, E_{k-1})$
%
such that 
%
% $\bigcup_{i=0}{V_i} =V$, $\forall i. 0 \le i,j < k, V_i \not= \emptyset$
% and  $i \not= j \implies V_i \cap V_j = \emptyset$, 
%
$\{V_0, \ldots, V_{k-1}\}$ is a set partition of $V$
and 
%
$H_0, \ldots, H_{k-1}$ 
%
are vertex-induced subgraphs of $G$ with respect to $V_0, \ldots, V_{k-1}$.
%
Each subgraph $H_i$ is called a~\defn{block} or~\defn{part} of $G$.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Internal and Cut Edges
</mlxFieldTitle>
<mlxFieldTitleDex>
Internal and Cut Edges
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>In a graph partition, we can distinguish between two kinds of edges: internal edges and cut edges. We call an edge <span class="math inline">\(\{v_1,v_2\}\)</span> an <span> </span>, if <span class="math inline">\(v_1\in V_i\)</span> and <span class="math inline">\(v_2 \in V_i\)</span>, and by construction <span class="math inline">\(\{v_1,v_2\} \in E_i\)</span>. We call an edge <span class="math inline">\(\{v_1,v_2\}\)</span> a <span> </span>, if <span class="math inline">\(v_1\in V_i\)</span> and <span class="math inline">\(v_2 \in V_j\)</span> and <span class="math inline">\(i \not= j\)</span>. One way to partition a graph is to make each connected component a block. In such a partition, there are no cut edges between the partitions.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
In a graph partition, we can distinguish between two kinds of edges:
internal edges and cut edges. 
%
We call an edge $\{v_1,v_2\}$ an~\defn{internal edge}, if $v_1\in V_i$
and $v_2 \in V_i$, and by construction $\{v_1,v_2\} \in E_i$.
%
We call an edge $\{v_1,v_2\}$ a~\defn{cut edge}, if $v_1\in V_i$
and $v_2 \in V_j$  and $i \not= j$.
%
One way to partition a graph is to make each connected component a
block. In such a partition, there are no cut edges between the
partitions.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
Partition Map
</mlxFieldTitle>
<mlxFieldTitleDex>
Partition Map
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR5:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Sometimes it is useful to give a name or a label to each block in a graph partition. A graph partition can then be described as a set of labels for the blocks and <span> </span> that maps each vertex to the label of its block. The labels can be chosen arbitrarily but sometimes it is conceptually and computationally easier to use a vertex inside a block as a name (representative) for that block.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Sometimes it is useful to give a name or a label to each block in a
graph partition.  
%
A graph partition can then be described as a set of labels for the
blocks and~\defn{partition map} that maps each vertex to the label of
its block.  
%
The labels can be chosen arbitrarily but sometimes it is conceptually
and computationally easier to use a vertex inside a block as a name
(representative) for that block.
%
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC1:UN1:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC1:UN1:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC1:UN1:GR6:AT1:ex:preliminaries::partition1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The partition <span class="math inline">\({\left\{ {\left\{ {{\texttt{a}}},{{\texttt{b}}},{{\texttt{c}}} \right\}},{\left\{ {{\texttt{d}}} \right\}},{\left\{ {{\texttt{e}}},{{\texttt{f}}} \right\}} \right\}}\)</span> of the vertices <span class="math inline">\({\left\{ {{\texttt{a}}},{{\texttt{b}}},{{\texttt{c}}},{{\texttt{d}}},{{\texttt{e}}},{{\texttt{f}}} \right\}}\)</span>, defines three blocks as vertex-induced subgraphs.</p>
<p><img src="./media/contract-example8.jpg" alt="image" width="480" /></p>
<p>The edges <span class="math inline">\({\left\{ {{\texttt{a}}},{{\texttt{b}}} \right\}}\)</span>, <span class="math inline">\({\left\{ {{\texttt{a}}},{{\texttt{c}}} \right\}}\)</span>, and <span class="math inline">\({\left\{ {{\texttt{e}}},{{\texttt{f}}} \right\}}\)</span> are internal edges, and the edges <span class="math inline">\({\left\{ {{\texttt{c}}},{{\texttt{d}}} \right\}}\)</span>, <span class="math inline">\({\left\{ {{\texttt{b}}},{{\texttt{d}}} \right\}}\)</span>, <span class="math inline">\({\left\{ {{\texttt{b}}},{{\texttt{e}}} \right\}}\)</span> and <span class="math inline">\({\left\{ {{\texttt{d}}},{{\texttt{f}}} \right\}}\)</span> are cut edges.</p>
<p>By labeling the blocks <span class="math inline">\({{\text{&#39;}\,{{\texttt{abc}}}\,\text{&#39;}}},{{\text{&#39;}\,{{\texttt{d}}}\,\text{&#39;}}}\)</span> and <span class="math inline">\({{\text{&#39;}\,{{\texttt{ef}}}\,\text{&#39;}}}\)</span>, we can specify the graph partition with following partition map:<br />
<span class="math inline">\( ({\left\{ {{\texttt{abc}}}, {{\texttt{d}}}, {{\texttt{ef}}} \right\}}, ~{\left\{ {{\texttt{a}}} \mapsto 
  {{\texttt{abc}}}, {{\texttt{b}}} \mapsto {{\texttt{abc}}}, {{\texttt{c}}} \mapsto 
  {{\texttt{abc}}}, {{\texttt{d}}} \mapsto {{\texttt{d}}}, {{\texttt{e}}} \mapsto 
  {{\texttt{ef}}}, {{\texttt{f}}} \mapsto {{\texttt{ef}}} \right\}}).\)</span></p>
<p>Instead of assigning a fresh label to each block, we can choose a representative vertex. For example, by picking <span class="math inline">\({{\texttt{a}}}, {{\texttt{d}}}\)</span>, and <span class="math inline">\({{\texttt{c}}}\)</span> as representatives, we can represent the partition above using the following partition map <span class="math display">\[({\left\{ {{\texttt{a}}},{{\texttt{d}}},{{\texttt{e}}} \right\}},  
 {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}}, {{\texttt{b}}} \mapsto {{\texttt{a}}},  
       {{\texttt{c}}} \mapsto {{\texttt{a}}}, {{\texttt{d}}} \mapsto {{\texttt{d}}},  
       {{\texttt{e}}} \mapsto {{\texttt{e}}}, {{\texttt{f}}} \mapsto {{\texttt{e}}} \right\}}).\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The partition 
%
$\cset{\cset{\vname{a},\vname{b},\vname{c}},\cset{\vname{d}},\cset{\vname{e},\vname{f}}}$
%
of the vertices
%
$\cset{\vname{a},\vname{b},\vname{c},\vname{d},\vname{e},\vname{f}}$, 
%
defines three blocks as vertex-induced subgraphs.
\begin{center}
  \includegraphics[width=5in]{./media/contract-example8.jpg}
\end{center}
The edges $\cset{\vname{a},\vname{b}}$, $\cset{\vname{a},\vname{c}}$,
and $\cset{\vname{e},\vname{f}}$ are internal edges, and the edges
$\cset{\vname{c},\vname{d}}$, $\cset{\vname{b},\vname{d}}$,
$\cset{\vname{b},\vname{e}}$ and $\cset{\vname{d},\vname{f}}$ are
cut edges.

By labeling the blocks $\cstr{abc},\cstr{d}$ and
$\cstr{ef}$, we can specify the graph partition with following partition map:
\\
%
$ (\cset{\vname{abc}, \vname{d}, \vname{ef}}, ~\cset{\vname{a} \mapsto
  \vname{abc}, \vname{b} \mapsto \vname{abc}, \vname{c} \mapsto
  \vname{abc}, \vname{d} \mapsto \vname{d}, \vname{e} \mapsto
  \vname{ef}, \vname{f} \mapsto \vname{ef}}).$

Instead of assigning a fresh label to each block, we can choose a
representative vertex.
%
For example, by picking $\vname{a}, \vname{d}$, and $\vname{c}$ as
representatives, we can represent the partition above using the
following partition map
\[
(\cset{\vname{a},\vname{d},\vname{e}}, 
 \cset{\vname{a} \mapsto \vname{a}, \vname{b} \mapsto \vname{a}, 
       \vname{c} \mapsto \vname{a}, \vname{d} \mapsto \vname{d}, 
       \vname{e} \mapsto \vname{e}, \vname{f} \mapsto \vname{e}}).
\]
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Graph Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Graph Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC2:UN2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Graph contraction is a technique for computing properties of graphs in parallel. As a contraction technique, it is used to solve a problem instance by reducing it to a smaller instance of the same problem. Graph contraction is an important technique, because divide-and-conquer can be difficult to apply in graph problems efficiently. Divide-and-conquer techniques usually require partitioning graphs into smaller graphs in a balanced fashion such that the number of cut edges is minimized. Because graphs can be highly irregular, however, they can be difficult to partition. In fact, graph partitioning problems are typically NP-hard.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Graph contraction is a technique for computing properties of graphs in
parallel.  
%
As a contraction technique, it is used to solve a problem
instance by reducing it to a smaller instance of the same problem.
%
%% \begin{teachask}
%% Can we solve graph problems using divide-and-conquer? 
%% \end{teachask}
%
Graph contraction is an important technique, because
divide-and-conquer can be difficult to apply in graph problems
efficiently.  
%
Divide-and-conquer techniques usually require partitioning graphs into
smaller graphs in a balanced fashion such that the number of cut edges
is minimized.  
%
Because graphs can be highly irregular, however, they can be difficult
to partition. In fact, graph partitioning problems are typically
NP-hard.
%
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Quotient Graph
</mlxFieldTitle>
<mlxFieldTitleDex>
Quotient Graph
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The key idea behind graph contraction is to contract the input graph to a smaller <span> </span>, solve the problem on the quotient graph, and then use that solution to construct the solution for the input graph. We can specify this technique as an inductive algorithm-design technique () as follows.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The key idea behind graph contraction is to contract the input graph
to a smaller~\defn{quotient graph}, solve the problem on the quotient
graph, and then use that solution to construct the solution for the
input graph.  
%
We can specify this technique as an inductive algorithm-design
technique (\dtref{gc::gc-technique}) as follows.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Graph Contraction Design Technique
</mlxFieldTitle>
<mlxFieldTitleDex>
Graph Contraction Design Technique
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR3:AT1:dt:gc::gc-technique
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<dl>
<dt>Base case:</dt>
<dd><p>If the graph is small (e.g., it has no edges), then compute the desired result.</p>
</dd>
<dt>Inductive case:</dt>
<dd><p> </p>
<ul>
<li><p>Contract the graph into a smaller quotient graph.</p>
<ul>
<li><p>Partition the graph into blocks.</p></li>
<li><p>Contract each block to a single super-vertex.</p></li>
<li><p>Drop internal edges.</p></li>
<li><p>Reroute cut edges to corresponding super-vertices.</p></li>
</ul></li>
<li><p>Recursively solve the problem for the quotient graph.</p></li>
<li><p>By using the result for the quotient graph, compute the result for the input graph.</p></li>
</ul>
</dd>
</dl>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
\begin{description}
\item[Base case:] If the graph is small (e.g., it has no edges), then compute
  the desired result.
\item[Inductive case:]~
\begin{itemize}
\item Contract the graph into a smaller quotient graph.
\begin{itemize}
\item Partition the graph into blocks.
\item Contract each block to a single super-vertex.
\item Drop internal edges.
\item Reroute cut edges to corresponding super-vertices.  
\end{itemize}

\item Recursively solve the problem for the quotient graph.
\item By using the result for the quotient graph, compute the result
  for the input graph.
\end{itemize}
\end{description}
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The key step of graph contraction is the construction of the quotient. To this end, we partition the graph and construct a quotient graph, where each block in the partition is represented by a vertex in the quotient graph. We can construct the quotient graph by creating a <span> </span> for each partition We then consider each edge <span class="math inline">\((u,v)\)</span> in the graph. If the edge is an internal edge, then we skip it. Otherwise, we create a new edge between the super-vertices representing the blocks containing <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>. Since there can be many cut edges between two blocks, we may create multiple edges between two super-vertices. We can remove such edges or leave them in the graph, in which case we would be working with multigraphs. In this chapter, we shall remove duplicate edges, because this is simpler for our purposes. The process of identifying a partition and updating the edges is called a <span> </span>. In a graph contraction, rounds are repeated until there are no edges left.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The key step of graph contraction is the construction of the quotient.
%
To this end, we partition the graph and construct a quotient
graph, where each block in the partition is represented by a
vertex in the quotient graph.
%
We can construct the quotient graph by creating a~\defn{super-vertex} for each partition
%
We then consider each edge $(u,v)$ in the graph.  If the edge is an internal
edge, then we skip it.
%
Otherwise,  we create a new edge between the
super-vertices representing the blocks containing $u$ and $v$.
%
Since there can be many
cut edges between two blocks, we may create multiple edges between
two super-vertices.  We can remove such edges or leave them in the graph, in
which case we would be working with multigraphs.  In this chapter, we
shall remove duplicate edges, because this is simpler for our
purposes.
%
The process of identifying a partition and updating the edges is
called a~\defn{round of graph contraction}. 
%
In a graph contraction, rounds are repeated until there are no edges
left.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR5:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>An important property of graph contraction is that it is guided by a graph partition. Since blocks in a graph partition are disjoint, each vertex in the graph is mapped to one unique vertex in the quotient graph.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
An important property of graph contraction is that it is guided by a
graph partition.  Since blocks in a graph partition are disjoint, each
vertex in the graph is mapped to one unique vertex in the quotient
graph.
%
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR6:AT1:ex:gc::contract-example
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>One round of graph contraction:</p>
<p><img src="./media/contract-example5.jpg" alt="image" width="624" /></p>
<p>Contracting a graph down to a single vertex in three rounds:</p>
<p><img src="./media/graph-contraction-example-1.jpg" alt="image" width="480" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
One round of graph contraction:
\begin{center}
  \includegraphics[width=6.5in]{./media/contract-example5.jpg}
\end{center}

Contracting a graph down to a single vertex in three rounds:
\begin{center}
\includegraphics[width=5in]{./media/graph-contraction-example-1.jpg}
\end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR7
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC2:UN2:GR7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC2:UN2:GR7:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC2:UN2:GR7:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>As described, the graph-contraction technique is generic in the kind of graph partition used for constructing the quotient graph. In the rest of this chapter, we will consider two techniques, edge partitioning and star partitioning, and the resulting graph-contraction algorithms. The rest of this chapter describes the graph-contraction design technique and two approaches to graph-contraction: edge contraction and star contraction.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
As described, the graph-contraction technique is generic in the kind
of graph partition used for constructing the quotient graph.  In the
rest of this chapter, we will consider two techniques, edge
partitioning and star partitioning, and the resulting
graph-contraction algorithms.
%
The rest of this chapter describes the graph-contraction design
technique and two approaches to graph-contraction: edge contraction
and star contraction.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Edge Partition and Edge Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Edge Partition and Edge Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC3:sec:gc::edge-partition
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC3:UN3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
Edge Partition and Edge Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Edge Partition and Edge Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Edge partitioning is a graph-partitioning technique. In an <span> </span>, each block is either a single vertex or two vertices connected by an edge. We use the term <span> </span> to refer to a graph contraction performed by using edge partitions.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Edge partitioning is a graph-partitioning technique.  In an~\defn{edge
  partition}, each block is either a single vertex or two vertices
connected by an edge.  We use the term~\defn{edge contraction} to
refer to a graph contraction performed by using edge partitions.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR2:AT1:ex:gc::ep::circle
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>An example edge partition in which every block consists of two vertices and an edge between them. Contracting the graph based on this partition yields a quotient graph with half as many vertices and edges.</p>
<p><img src="./media/edge-contraction-example-1.jpg" alt="image" width="432" /></p>
<p>Note that in general, blocks cannot be just pairs of vertices, because the graph might not have an even number of vertices, but even if it does (no pun intended), it is likely that it cannot be partitioned into a set of pairs joined by edges.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
An example edge partition in which every block consists of two
vertices and an edge between them.  Contracting the graph based on
this partition yields a quotient graph with half as many vertices
and edges.
\begin{center}
\includegraphics[width=4.5in]{./media/edge-contraction-example-1.jpg}
\end{center}

Note that in general, blocks cannot be just pairs of vertices, because
the graph might not have an even number of vertices, but even if it
does (no pun intended), it is likely that it cannot be partitioned
into a set of pairs joined by edges.
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Edge Partitions and Vertex Matching
</mlxFieldTitle>
<mlxFieldTitleDex>
Edge Partitions and Vertex Matching
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We can construct an edge partition by selecting an <span> </span>, or <span> </span>, where no two edges share a vertex, and placing all the remaining vertices that are not incident an a selected edges into singleton sets. The problem of finding a vertex matching is called the <span> </span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We can construct an edge partition by selecting an~\defn{independent
  edge set}, or~\defn{vertex matching},
where no two edges share a vertex, and placing all the
remaining vertices that are not incident an a selected edges into singleton
sets.
%
The problem of
finding a vertex matching is called the~\defn{vertex-matching
  problem}.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A <span> </span> for an undirected graph <span class="math inline">\(G = (V,E)\)</span> is a subset of edges <span class="math inline">\(M \subseteq E\)</span> such that no two edges in <span class="math inline">\(M\)</span> share a vertex.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A~\defn{vertex matching} for an undirected graph $G = (V,E)$
is a subset of edges $M \subseteq E$ such that no two edges in $M$
share a vertex.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR5:AT1:ex:gc::ec::matching
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A vertex matching for a graph (highlighted edges) and the corresponding blocks.</p>
<p><img src="./media/matching-example.jpg" alt="image" width="192" /> <img src="./media/matching-example-partitioned.jpg" alt="image" width="192" /></p>
<p>The vertex matching defines four blocks (circled), two of them defined by the edges in the matching, <span class="math inline">\({\left\{ {{\texttt{a}}},{{\texttt{b}}} \right\}}\)</span> and <span class="math inline">\({\left\{ {{\texttt{d}}},{{\texttt{f}}} \right\}}\)</span>, and two of them are the unmatched vertices <span class="math inline">\({{\texttt{c}}}\)</span> and <span class="math inline">\({{\texttt{e}}}.\)</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A vertex matching for a graph (highlighted edges) and the
corresponding blocks.
\begin{center}
  \includegraphics[width=2in]{./media/matching-example.jpg}
\hspace{1in}
  \includegraphics[width=2in]{./media/matching-example-partitioned.jpg}
\end{center}
The vertex matching defines four blocks (circled), two of them defined
by the edges in the matching, $\cset{\vname{a},\vname{b}}$ and
$\cset{\vname{d},\vname{f}}$, and two of them are the unmatched
vertices $\vname{c}$ and $\vname{e}.$
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Maximal Vertex Matching
</mlxFieldTitle>
<mlxFieldTitleDex>
Maximal Vertex Matching
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR6:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The problem of finding the largest vertex matching for a graph is called the <span> </span> problem. Many algorithms for this well-studied problem have been proposed, including one that can solve the problem in <span class="math inline">\(O(\sqrt{|V|}|E|)\)</span> work. For graph contraction, we do not need a maximum matching but one that it is sufficiently large. For example, we can use a greedy algorithm to construct a vertex matching by going through the edges one by one maintaining an initially empty set <span class="math inline">\(M\)</span> and for each edge, if no edge in <span class="math inline">\(M\)</span> is already incident on its endpoints then add it to <span class="math inline">\(M\)</span>, otherwise toss it. The problem with this approach is that it is sequential since each decision depends on previous decisions. To find the vertex matching in parallel, we will need to make local decisions at each vertex. One possibility is for each vertex to select one of its neighbors to match with. Such a selection can be made in parallel but there is one problem: multiple vertices might select the same vertex to match with. We therefore need a way to <em>break the symmetry</em> that arises when two vertices try to match with the same vertex. We can use randomization to break the symmetry. For example, we can flip a coin for each edge <span class="math inline">\((u,v)\)</span> in parallel and select the edge, effectively matching <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, if the coin for the edge comes up heads and all the edges incident on <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> flip tails. This guarantees that a vertex is matched with at most one other vertex.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The problem of finding the largest vertex matching for a graph is
called the~\defn{maxima/ vertex matching} problem.  Many algorithms
for this well-studied problem have been proposed, including one that
can solve the problem in $O(\sqrt{|V|}|E|)$ work.  For graph
contraction, we do not need a maximum matching but one that it is
sufficiently large.
%
%% \begin{teachask}
%% Describe an algorithm for finding a vertex matching.
%% \end{teachask}
%

For example, we can use a greedy algorithm to construct a vertex
matching by going through the edges one by one maintaining an
initially empty set $M$ and for each edge, if no edge in $M$ is
already incident on its endpoints then add it to $M$, otherwise toss
it.  The problem with this approach is that it is sequential since
each decision depends on previous decisions.
%% %
%% \begin{teachask}
%% Describe a parallel algorithm for  vertex matching?
%% \end{teachask}
%% %

To find the vertex matching in parallel, we will need to make local
decisions at each vertex.  One possibility is for each vertex to
select one of its neighbors to match with.
%
Such a selection can be made in parallel but 
%
%% \begin{teachask}
%% What is the problem with this approach? 
%% \end{teachask}
%% %
there is one problem:  multiple vertices might select
the same vertex to match with.  
%
We therefore need a way
to \emph{break the symmetry} that arises when two vertices try to match with the same vertex.
%% %
%% \begin{teachask}
%% Can you use randomization to break the symmetry? 
%% \end{teachask}
%% %
We can use randomization to break the symmetry.   For example,
we can  flip a coin for each
edge $(u,v)$ in parallel and 
select the edge, effectively matching $u$ and $v$,  if the coin
for the edge comes up heads and all the edges incident on
$u$ and $v$ flip tails.  This guarantees that a vertex is matched with
at most one other vertex.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR7
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
Edge contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Edge contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR7:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR7:AT1:ex:gc::edge-contract-example
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>An example edge contraction illustrated.</p>
<p><img src="./media/edge-contraction-example.jpg" alt="image" width="480" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
An example edge contraction illustrated.

\begin{center}
\includegraphics[width=5in]{./media/edge-contraction-example.jpg}
\end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR8
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR8
</mlxLabel>
<mlxNo>
8
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR8:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR8:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Let us analyze how effective this approach is in selecting a reasonably large matching. As an example, we first consider cycle graphs, consisting of a single cycle and no other edges. In such a graph every vertex has exactly two neighbors.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Let us analyze how effective this approach is in selecting a
reasonably large matching. As an example, we first consider cycle
graphs, consisting of a single cycle and no other edges.  In such a
graph every vertex has exactly two neighbors.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR9
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR9
</mlxLabel>
<mlxNo>
9
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR9:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR9:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A graph consisting of a single cycle.</p>
<p><img src="./media/cycle-graph.jpg" alt="image" width="144" /></p>
<p>Each edge flips a coin that comes up either heads (<span class="math inline">\(H\)</span>) or tails (<span class="math inline">\(T\)</span>). We select an edge if it turns up heads and all other edges incident on its endpoints are tails. In the example the edges <span class="math inline">\({\left\{ {{\texttt{c}}},{{\texttt{d}}} \right\}}\)</span> and <span class="math inline">\({\left\{ {{\texttt{b}}},{{\texttt{f}}} \right\}}\)</span> are selected.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A graph consisting of a single cycle.    
  \begin{center}
  \includegraphics[width=1.5in]{./media/cycle-graph.jpg}
  \end{center}
Each edge flips a coin that comes up either heads ($H$) or tails
($T$).  We select an edge if it turns up heads and all other edges
incident on its endpoints are tails.  In the example the edges
$\cset{\vname{c},\vname{d}}$ and $\cset{\vname{b},\vname{f}}$ are
selected.
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR10
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR10
</mlxLabel>
<mlxNo>
10
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR10:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR10:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We want to determine the probability that an edge is selected in such a graph. Since the coins are flipped independently at random, and each vertex has degree two, the probability that an edge picks heads and its two adjacent edges pick tails is <span class="math inline">\(\frac{1}{2} \cdot 
\frac{1}{2} \cdot \frac{1}{2} = \frac{1}{8}\)</span>. To analyze the number of edges selected in expectation, let <span class="math inline">\(R_e\)</span> be an indicator random variable denoting whether <span class="math inline">\(e\)</span> is selected or not, that is <span class="math inline">\(R_e = 1\)</span> if <span class="math inline">\(e\)</span> is selected and <span class="math inline">\(0\)</span> otherwise. Recall that the expectation of indicator random variables is the same as the probability it has value <span class="math inline">\(1\)</span> (true). Therefore we have <span class="math inline">\(E[R_e] = 1/8\)</span>. Thus summing over all edges, we conclude that expected number of edges deleted is <span class="math inline">\(\frac{m}{8}\)</span> (note, <span class="math inline">\(m=n\)</span> in a cycle graph).</p>
<p>In the chapter on randomized algorithms, we argued that if each round of an algorithm reduces the size by a constant fraction in expectation, and if the random choices in the rounds are independent, then the algorithm will finish in <span class="math inline">\(O(\lg n)\)</span> rounds with high probability. Recall that all we needed to do is multiply the expected fraction that remain across rounds and then use Markov’s inequality to show that after some <span class="math inline">\(k \lg n\)</span> rounds the probability that the problem size is a least 1 is very small. For a cycle graph, this technique leads to an algorithm for graph contraction with linear work and <span class="math inline">\(O(\lg^2{n})\)</span> span.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We want to determine the probability that an edge is selected in such
a graph.  Since the coins are flipped independently at random, and
each vertex has degree two, the probability that an edge picks heads
and its two adjacent edges pick tails is $\frac{1}{2} \cdot
\frac{1}{2} \cdot \frac{1}{2} = \frac{1}{8}$.  To analyze the number
of edges selected in expectation, let $R_e$ be an indicator random
variable denoting whether $e$ is selected or not, that is $R_e = 1$ if
$e$ is selected and $0$ otherwise.  Recall that the expectation of
indicator random variables is the same as the probability it has value
$1$ (true).  Therefore we have $E[R_e] = 1/8$.
%
Thus summing over all edges, we conclude that expected number of edges
deleted is $\frac{m}{8}$ (note, $m=n$ in a cycle graph). 


%% \begin{todo}
%% We need to state this as a theorem.  It is not quite stated in this way.
%% \end{todo}

In the chapter on randomized algorithms,
% (\secref{kthsmallest})
we argued that if each round of an algorithm reduces the size by a
constant fraction in expectation, and if the random choices in the
rounds are independent, then the algorithm will finish in $O(\lg n)$
rounds with high probability.  Recall that all we needed to do is
multiply the expected fraction that remain across rounds and then use
Markov's inequality to show that after some $k \lg n$ rounds the
probability that the problem size is a least 1 is very small.  For a
cycle graph, this technique leads to an algorithm for graph
contraction with linear work and $O(\lg^2{n})$ span.
%
%---left as an exercise.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR11
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR11
</mlxLabel>
<mlxNo>
11
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachAsk>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR11:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR11:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Can you think of a way to improve the expected number of edges deleted?</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Can you think of a way to improve the expected number of edges
  deleted?
]]>
</mlxFieldBodyDex>
</mlxAtomTeachAsk>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR12
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR12
</mlxLabel>
<mlxNo>
12
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR12:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR12:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>There are several ways to improve the number of deleted edges. One way is for each vertex to pick one of its neighbors and to select an edge <span class="math inline">\((u,v)\)</span> if it was picked by both <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>. In the case of a circle, this increases the expected number of deleted edges to <span class="math inline">\(\frac{m}{4}\)</span>. Another way is let each edge pick a random number in some range and then select and edge if it is the local maximum, i.e., it picked the highest number among all the edges incident on its end points. This increases the expected number of edges contracted in a circle to <span class="math inline">\(\frac{m}{3}\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
There are several ways to improve the number of deleted edges.  One
way is for each vertex to pick one of its neighbors and to select an
edge $(u,v)$ if it was picked by both $u$ and $v$.  In the case of a
circle, this increases the expected number of deleted edges to
$\frac{m}{4}$. 
%
Another way is let each edge pick a random number in some range and
then select and edge if it is the local maximum, i.e., it picked the
highest number among all the edges incident on its end points. This
increases the expected number of edges contracted in a circle to
$\frac{m}{3}$.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR13
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR13
</mlxLabel>
<mlxNo>
13
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR13:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR13:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Although edge contraction works quite well with cycle graphs, it does not work well for arbitrary graphs. The problem is in edge contraction, only one edge incident on a vertex can be contracted in each round. Therefore vertices with high degrees, will have to contract their neighbors one at a time. The example below illustrates a particularly difficult graph, called a star graph, for edge contraction.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Although edge contraction works quite well with cycle graphs, 
%or sequentially with the appropriate data structures, 
it does not work well for arbitrary graphs.  The problem is in edge
contraction, only one edge incident on a vertex can be contracted in
each round.  Therefore vertices with high degrees, will have to
contract their neighbors one at a time.  The example below illustrates
a particularly difficult graph, called a star graph, for edge
contraction.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR14
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR14
</mlxLabel>
<mlxNo>
14
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR14:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR14:AT1:ex:gc::star
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A star graph with center <span class="math inline">\(v\)</span> and eight satellites.</p>
<p><img src="./media/star-graph1.jpg" alt="image" width="144" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A star graph with center $v$ and eight satellites.
  \begin{center}
  \includegraphics[width=1.5in]{./media/star-graph1.jpg}
  \end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR15
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR15
</mlxLabel>
<mlxNo>
15
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
Star Graph
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Graph
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR15:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR15:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A <span> </span> graph <span class="math inline">\(G = (V,E)\)</span> is an undirected graph with a  <span> </span> vertex <span class="math inline">\(v \in V\)</span>, and a set of edges <span class="math inline">\(E\)</span> that attach <span class="math inline">\(v\)</span> directly to the rest of the vertices, called  <span> </span>, i.e. <span class="math inline">\(E = {\left\{ {\left\{ v,u \right\}} : u 
    \in V \setminus {\left\{ v \right\}} \right\}}\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A~\defn{star} graph $G = (V,E)$ is an undirected graph with a
 ~\defn{center} vertex $v \in V$, and a set of edges $E$ that attach
  $v$ directly to the rest of the vertices, called
 ~\defn{satellites}, i.e. $E = \cset{\cset{v,u} : u
    \in V \setminus \cset{v}}$.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR15:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR15:AT2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The following are star graphs:</p>
<ul>
<li><p>a single vertex, and</p></li>
<li><p>a single edge.</p></li>
</ul>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The following are star graphs:
\begin{itemize}
\item a single vertex, and
\item a single edge.
\end{itemize}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR16
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR16
</mlxLabel>
<mlxNo>
16
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR16:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR16:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>It is not difficult to convince ourselves that on a star graph with <span class="math inline">\(n\)</span> vertices (<span class="math inline">\(1\)</span> center and <span class="math inline">\(n-1\)</span> satellites) any edge partitioning algorithm will take <span class="math inline">\(\Omega(n)\)</span> rounds. To fix this problem we need to be able to form blocks that consist of more than just edges.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
It is not difficult to convince ourselves that on a star graph with
$n$ vertices ($1$ center and $n-1$ satellites) any edge partitioning
algorithm will take $\Omega(n)$ rounds.  To fix this problem we need
to be able to form blocks that consist of more than just edges.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR17
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR17
</mlxLabel>
<mlxNo>
17
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR17:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR17:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>I (Umut) find the remark below quite confusing.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
I (Umut) find the remark below quite confusing.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR18
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC3:UN3:GR18
</mlxLabel>
<mlxNo>
18
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomRemark>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC3:UN3:GR18:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC3:UN3:GR18:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>An abstract data type called disjoint sets is often used to contract graphs sequentially. Disjoint sets supply two functions:  <span> </span>, which joins two components, and <span> </span>, which finds what component a vertex is in. In our framework, the union operation is simply edge contraction across a single edge, and the find is just a lookup in the partition map. Semantically for a partition map <span class="math inline">\(P\)</span> we can define <span class="math inline">\({\texttt{union}}\)</span> as:</p>
<p><span class="math display">\[\begin{array}{lcl} 
~~{\texttt{union}}~(P,u,v) &amp; = &amp; \{ u&#39; \mapsto~{\texttt{if}}~(v&#39; = u)~{\texttt{then}}~v~{\texttt{else}}~v&#39; 
\\ 
  
                 &amp; &amp; ~: (u&#39; \mapsto v&#39;) \in P \} 
\end{array}\]</span></p>
<p>where here we have made <span class="math inline">\(v\)</span> the new representative of the super-vertex <span class="math inline">\({\left\{ u,v \right\}}\)</span>, and have updated all vertices that used to point to <span class="math inline">\(u\)</span> to now point to <span class="math inline">\(v\)</span>. Implementing the <span class="math inline">\({\texttt{union}}\)</span> this way, however, is inefficient since it can require updating a lot of vertices. It turns out that the operations can be can be implemented much more efficiently. Indeed one can implement a data structure that only requires amortized <span class="math inline">\(O(\alpha(n))\)</span> work per operation, where <span class="math inline">\(\alpha(n)\)</span> (the inverse Ackermann function) is a function that is very close ot <span class="math inline">\(O(1)\)</span>, and <span class="math inline">\(n\)</span> is the number of operations.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
An abstract data type called disjoint sets is often used to contract
  graphs sequentially.  Disjoint sets supply two functions:
 ~\defn{union}, which joins two components, and~\defn{find}, which
  finds what component a vertex is in.  In our framework, the union
  operation is simply edge contraction across a single edge, and the
  find is just a lookup in the partition map.  Semantically for a
  partition map $P$ we can define $\cd{union}$ as:


\[
\begin{array}{lcl}
~~\cd{union}~(P,u,v) & = & \{ u' \mapsto~\cd{if}~(v' = u)~\cd{then}~v~\cd{else}~v'
\\
 
                 & & ~: (u' \mapsto v') \in P \}
\end{array}
\]

where here we have made $v$ the new representative of the super-vertex
$\cset{u,v}$, and have updated all vertices that used to point to $u$
to now point to $v$.
Implementing the $\cd{union}$ this way, however, is inefficient since
it can require updating a lot of vertices.  It turns out that the
operations can be can be implemented much more efficiently.  Indeed
one can implement a data structure that only requires amortized
$O(\alpha(n))$ work per operation, where $\alpha(n)$ (the inverse
Ackermann function) is a function that is very close ot $O(1)$, and
$n$ is the number of operations.
]]>
</mlxFieldBodyDex>
</mlxAtomRemark>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Star Partition and Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Partition and Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC4:sec:gc::star-partitioning
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC4:UN4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN4:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>In an edge partition, if there is an edge incident on a vertex <span class="math inline">\(v\)</span> is selected as a block, then none of the other edges incident on <span class="math inline">\(v\)</span> can be their own block. This limits the effectiveness of edge partitioning, because it is unable to contract significantly graphs with high-degree vertices. In this section, we describe an alternative technique: star partition.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
In an edge partition, if there is an edge incident on a vertex~$v$ is
selected as a block, then none of the other edges incident on $v$ can be their own
block. This limits the effectiveness of edge partitioning, because it
is unable to contract significantly graphs with high-degree vertices.
%
In this section, we describe an alternative technique: star
partition.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN4:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A <span> </span> of a graph <span class="math inline">\(G\)</span> is a partition where each block is a star graph.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A~\defn{star partition} of a graph $G$ is a partition where each block
is a  star graph.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR2:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR2:AT2:ex:gc::star-partition
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Consider star graph with center <span class="math inline">\(v\)</span> and eight satellites.</p>
<p><img src="./media/star-graph1.jpg" alt="image" width="144" /></p>
<p>A partition consisting of the whole graph is a star partition, where the only block is the (star) graph itself.</p>
<p>Similarly, a partition where each block is an isolated vertex is a star partition, because each block is a vertex-induced subgraph of the vertices of a star graph.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Consider star graph with center $v$ and eight satellites.
  \begin{center}
  \includegraphics[width=1.5in]{./media/star-graph1.jpg}
  \end{center}

A partition consisting of the whole graph is a star partition, where 
the only block is the (star) graph itself.

Similarly, a partition where each block is an isolated vertex is a
star partition, because each block is a vertex-induced subgraph of the
vertices of a star graph.
]]>
</mlxFieldBodyDex>
</mlxAtomExample>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR2:AT3
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR2:AT3:ex:gc::star
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>In the graph shown below on the left, we first find two disjoint stars. We then partition the graph into two blocks, each defined as the vertex-induced subgraphs of the two stars.</p>
<p><img src="./media/star-decomposition-1.jpg" alt="image" style="width:90.0%" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
In the graph shown below on the left, we first find two disjoint stars. We
  then partition the graph into two blocks, each defined as the
  vertex-induced subgraphs of the two stars.

\begin{center}
\includegraphics[width=0.9\textwidth]{./media/star-decomposition-1.jpg}
\end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN4:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Finding a Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Finding a Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>As with an edge partition, it is possible to construct a star partition sequentially. One approach proceeds by adding start incrementally as follows.</p>
<ul>
<li><p>Choose an arbitrary vertex <span class="math inline">\(v\)</span> in the graph and make <span class="math inline">\(v\)</span> the center of a star.</p></li>
<li><p>Attach as satellites all the neighbors of <span class="math inline">\(v\)</span>.</p></li>
<li><p>Remove <span class="math inline">\(v\)</span> and its satellites from the graph.</p></li>
<li><p>Recursively repeat the same process with the remaining graph.</p></li>
</ul>
<p>Towards the end of this process, we might end up with some vertices that are isolated vertices with no edges attached to them. Such vertices can all be chosen as <span> </span></p>
<p>We can also construct a star partition in parallel by making local independent decisions at each vertex. As with edge partitions, we use randomization to break symmetry. One approach proceeds as follows.</p>
<ul>
<li><p>Flip a coin for each vertex.</p></li>
<li><p>If a vertex flips heads, then it becomes the center of a star.</p></li>
<li><p>If a vertex flips tails, then there are two cases.</p>
<ul>
<li><p>The vertex is isolated. In this case, it becomes a center.</p></li>
<li><p>The vertex has a neighbor. In this case, the vertex looks for a neighbor that flipped heads. If there is such a neighbor, then it chooses one arbitrarily, and becomes a satellite for that neighbor. Otherwise, all neighbors have flipped tails and the vertex becomes a center.</p></li>
</ul></li>
</ul>
<p>This approach is not optimal in the sense that it might not always create the smallest number of stars. As we shall see, suboptimality is acceptable, because we only need to reduce the size of the graph by a constant factor.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
As with an edge partition, it is possible to construct a star partition
sequentially.  
%
One approach proceeds by adding start incrementally as follows.
\begin{itemize}

\item Choose an arbitrary vertex $v$ in the graph and make $v$ the
  center of a star.

\item Attach as satellites all the neighbors of $v$.

\item Remove $v$ and its satellites from the graph.

\item Recursively repeat the same process with the remaining graph.
\end{itemize}
%

Towards the end of this process, we might end up with some vertices
that are isolated vertices with no edges attached to them.
%
Such vertices can all be chosen as \defn{singleton stars.}



%% \begin{teachask}
%% How can we star partition a graph in parallel? 
%% \end{teachask} 
%
We can also construct a star partition in parallel by making local
independent decisions at each vertex.  As with edge partitions, we use
randomization to break symmetry.
%
%% \begin{teachask}
%% Can you think of a randomized approach for selecting stars?
%% \end{teachask}
%
One approach proceeds as follows. 
%
\begin{itemize}
\item Flip a coin for each vertex.

\item If a vertex flips heads, then it becomes the center of a star. 

%% \item If a vertex flips tails, then it attempts to become a satellite
%%   by finding a neighbor that has flipped heads.  If no such neighbor
%%   exists (all neighbors have flipped tails or the vertex is isolated),
%%   then the vertex becomes a center.
%%%% TODO: The following seems to be a better explanation
\item If a vertex flips tails, then there are two cases.
\begin{itemize}
\item The vertex is isolated.  In this case, it becomes a center.
\item The vertex has a neighbor.  In this case, the vertex looks for a
  neighbor that flipped heads.  If there is such a neighbor, then it
  chooses one arbitrarily, and becomes a satellite for that
  neighbor. Otherwise, all neighbors have flipped tails and the
  vertex becomes a center.
\end{itemize}
\end{itemize}

%
%% \begin{teachask}
%% Is this algorithm guaranteed to create the smallest number of stars?
%% \end{teachask}
%
This approach is not optimal in the sense that it might not always
create the smallest number of stars.
%
As we shall see, suboptimality is acceptable, because we only need to
reduce the size of the graph by a constant factor.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN4:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
Randomized Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Randomized Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR4:AT1:ex:startpartition
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>An example star partition. Vertices <span class="math inline">\({{\texttt{a}}}\)</span> and <span class="math inline">\({{\texttt{b}}}\)</span>, which flip heads, become centers. Vertices <span class="math inline">\({{\texttt{c}}}\)</span> and <span class="math inline">\({{\texttt{e}}}\)</span>, which flipped tails, attempt to become satellites by finding a center among their neighbors, breaking ties arbitrarily. If a vertex does not have a neighbor that is a center (flipped heads), then it becomes a singleton star (e.g., vertex <span class="math inline">\(d\)</span>). We end up with three stars: the star with center <span class="math inline">\({{\texttt{a}}}\)</span> (with no satellites), the star with center <span class="math inline">\({{\texttt{b}}}\)</span> (with two satellites), and the singleton star <span class="math inline">\({{\texttt{d}}}\)</span>. The star partition thus yields three blocks, which are defined by the subgraphs induced by each star.</p>
<p><img src="./media/star-find0.jpg" alt="image" width="576" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
An example star partition. Vertices $\vname{a}$ and $\vname{b}$, which
flip heads, become centers. Vertices $\vname{c}$ and $\vname{e}$,
which flipped tails, attempt to become satellites by finding a center
among their neighbors, breaking ties arbitrarily.
%
If a vertex does not have a neighbor that is a center (flipped heads),
then it becomes a singleton star (e.g., vertex $d$).
%
We end up with three stars: the star with center $\vname{a}$ (with no
satellites), the star with center $\vname{b}$ (with two satellites),
and the singleton star $\vname{d}$.
%
The star partition thus yields three blocks, which are defined by the
subgraphs induced by each star.

\begin{center}
  \includegraphics[width=6in]{./media/star-find0.jpg}
\end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN4:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomAlgorithm>
<mlxFieldTitle>
Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR5:AT1:alg:gc::starPartition
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>To specify the star-partition algorithm, we need a source of randomness. We assume that each vertex is given a (potentially infinite) sequence of random and independent coin flips. The <span class="math inline">\(i^{th}\)</span> element of the sequence can be accessed via the function <span class="math display">\[{{\texttt{heads}}}(v,i) : V \times \mathbb{Z} \to \mathbb{B},\]</span> which returns <span class="math inline">\({\texttt{true}}\)</span> if the <span class="math inline">\(i^{th}\)</span> flip on vertex <span class="math inline">\(v\)</span> is heads and false otherwise. Since most machines don’t have true sources of randomness, in practice this can be implemented with a pseudorandom number generator or even with a good hash function. <span class="math display">\[\begin{array}{ll} 
1 &amp; {\texttt{starPartition}}~(G=(V,E),i) = 
\\ 
2 &amp; ~~~{\texttt{let}} 
\\ 
3 &amp; ~~~~~~{\texttt{(* Find the arcs from satellites to centers. *)}} 
\\ 
4 &amp; ~~~~~~\mathit{TH} = {\left\{ (u,v) \in E \;|\; \neg {{\texttt{heads}}}(u,i) \land {{\texttt{heads}}}(v,i) \right\}}$ \\ 
5 &amp; ~~~~~~{\texttt{(* Partition map from satellites to centers *)}} 
\\ 
6 &amp; ~~~~~~P_S = \bigcup_{(u,v) \in \mathit{TH}} {\left\{ u \mapsto v \right\}} 
\\ 
7 &amp; ~~~~~~{\texttt{(* Centers are non-satellite vertices *)}} 
\\ 
8 &amp; ~~~~~~V_c = V \setminus {\texttt{domain}}(P_s) 
\\ 
9 &amp; ~~~~~~{\texttt{(* Map centers to themselves *)}} 
\\ 
10 &amp; ~~~~~~~P_c = {\left\{ u \mapsto u : u \in V_c \right\}} \\ 
11 &amp; ~~~{\texttt{in}} 
\\ 
12 &amp; ~~~~~~(V_c, P_s \cup P_c) 
\\ 
13 &amp; ~~~{\texttt{end}} 
\end{array}\]</span></p>
<p>The pseudo-code above shows the code for star partitioning. The function <span class="math inline">\({\texttt{starPartition}}\)</span> takes as argument a graph and a round number, and returns a graph partition specified by a set of centers and a partition map from all vertices to centers. The algorithm starts by flipping a coin for each vertex and selecting the directed edges that point from tails to heads—this gives the set of edges <span class="math inline">\(\mathit{TH}\)</span>. In this set of edges, there can be multiple edges from the same non-center. Since we want to choose one center for each satellite, we remove duplicates in Line <span>6</span>, by creating a set of singleton tables and merging them. More specifically, the union is shorthand for the following code. <span class="math display">\[\begin{array}{ll} 
  {\texttt{Set.reduce}} 
  &amp; ({\texttt{Table.union}}~({\texttt{lambda}} (x,y) {\Rightarrow}x)) 
\\ 
&amp; \emptyset 
\\ 
&amp; {\left\{ {\left\{ u \mapsto v \right\}} : (u,v) \in \mathit{TH} \right\}} 
\end{array}\]</span> This completes the selection of satellites and their centers. Next, the algorithm determines the set of centers, which will become the vertices of the quotient graph in contraction, as all the vertices minus the satellites. To complete the process, the algorithm maps each center to itself (Line <span>10</span>). These operations effectively promote unmatched non-centers to centers, forming singleton stars, and matches all centers with themselves. Finally, the algorithm constructs the partition map by uniting the mapping for the satellites and the centers.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
To specify the star-partition algorithm, we need
a source of randomness.
%
We assume that each vertex is given a (potentially infinite) sequence
of random and independent coin flips. The $i^{th}$ element of the
sequence can be accessed via the function
\[
\cheads(v,i) : V \times \mathbb{Z} \to \mathbb{B}, 
\]
which returns $\cd{true}$ if the $i^{th}$ flip on vertex $v$ is heads
and false otherwise. Since most machines don't have true sources of
randomness, in practice this can be implemented with a pseudorandom
number generator or even with a good hash function. 
\[
\begin{array}{ll}
1 & \cd{starPartition}~(G=(V,E),i) =
\\
2 & ~~~\cd{let}
\\
3 & ~~~~~~\cd{(* Find the arcs from satellites to centers. *)}
\\
4 & ~~~~~~\mathit{TH} = \csetf{(u,v) \in E}{\neg \cheads(u,i) \land \cheads(v,i)}$ %@\label{line:flip}\vspace{.1in}@
\\
5 & ~~~~~~\cd{(* Partition map from satellites to centers *)}
\\
6 & ~~~~~~P_S = \bigcup_{(u,v) \in \mathit{TH}} \cset{u \mapsto v}
% \label{line:starmerge}
\\
7 & ~~~~~~\cd{(* Centers are non-satellite vertices *)}
\\
8 & ~~~~~~V_c = V \setminus \cd{domain}(P_s)
\\
9 & ~~~~~~\cd{(* Map centers to themselves *)}
\\
10 & ~~~~~~~P_c = \cset{u \mapsto u : u \in V_c} % \label{line:self}
\\
11 & ~~~\cd{in}
\\
12 & ~~~~~~(V_c, P_s \cup P_c)
\\
13 & ~~~\cd{end}
\end{array}
\]

The pseudo-code above shows the code for star partitioning.
%
The function $\cd{starPartition}$ takes as argument a graph and a round
number, and returns a graph partition specified by a set of centers and
a partition map from all vertices to centers.
%
The algorithm starts by flipping a coin for each vertex and selecting the directed
edges that point from tails to heads---this gives
the set of edges $\mathit{TH}$.
%
In this set of edges, there can be multiple edges from the same
non-center. Since we want to choose one center for each satellite, we
remove duplicates in Line~\linegcstarmerge{}, by creating a set of
singleton tables and merging them.
%
More specifically, the union is shorthand for the following code.
%
\[
\begin{array}{ll}
  \cd{Set.reduce}
  & (\cd{Table.union}~(\cd{lambda} (x,y) \dra x))
\\
& \emptyset
\\
& \cset{\cset{u \mapsto v} : (u,v) \in \mathit{TH}}
\end{array}
\]
%
This completes the selection of satellites and their centers. 
%

Next, the algorithm determines the set of centers, which
will become the vertices of the quotient graph in contraction, as all
the vertices minus the satellites.
%
To complete the process, the algorithm maps each center to itself
(Line~\linegcstarself{}).
%
These operations effectively promote unmatched non-centers to centers,
forming singleton stars, and matches all centers with themselves.
%
Finally, the algorithm constructs the partition map by  uniting the
mapping for the satellites and the centers.
]]>
</mlxFieldBodyDex>
</mlxAtomAlgorithm>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN4:GR5:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN4:GR5:AT2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Consider the star partition illustrated below.</p>
<p><img src="./media/star-find0.jpg" alt="image" width="576" /></p>
<p>The star-partition algorithm proceeds on this examplse as follows. First, it computes <span class="math display">\[\mathit{TH} = 
{\left\{ ({{\texttt{c}}},{{\texttt{a}}}),({{\texttt{c}}},{{\texttt{b}}}),({{\texttt{e}}},{{\texttt{b}}}) \right\}},\]</span> as the edges from satellites to centers. Now, it converts each edge into a singleton table, and merges all the tables into one table, which is going to become a part of the partition map: <span class="math display">\[P = {\left\{ {{\texttt{c}}} \mapsto {{\texttt{b}}},{{\texttt{e}}} \mapsto {{\texttt{b}}} \right\}}.\]</span> Note that the edge <span class="math inline">\(({{\texttt{c}}},{{\texttt{a}}})\)</span> has been removed since when uniting the tables, we selects only one element for each key in the domain. Now for all remaining vertices <span class="math inline">\(V&#39; = V \setminus {\texttt{domain}}(P) = {\left\{ {{\texttt{a}}},{{\texttt{b}}},{{\texttt{d}}} \right\}}\)</span> we map them to themselves, giving: <span class="math display">\[P&#39; = {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}}, {{\texttt{b}}} \mapsto {{\texttt{b}}}, 
  {{\texttt{d}}} \mapsto {{\texttt{d}}} \right\}}.\]</span> The vertices in <span class="math inline">\(P&#39;\)</span> are the centers. Finally we merge <span class="math inline">\(P\)</span> and <span class="math inline">\(P&#39;\)</span> to obtain the partition map <span class="math display">\[P&#39; \cup P = {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}}, {{\texttt{b}}} \mapsto {{\texttt{b}}}, {{\texttt{c}}} \mapsto {{\texttt{b}}}, {{\texttt{d}}} \mapsto 
    {{\texttt{d}}}, {{\texttt{e}}} \mapsto {{\texttt{b}}} \right\}}.\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Consider the star partition illustrated below.
\begin{center}
  \includegraphics[width=6in]{./media/star-find0.jpg}
\end{center}

The  star-partition algorithm proceeds on this examplse as follows.
%
First, it computes
%
\[
\mathit{TH} =
\cset{(\vname{c},\vname{a}),(\vname{c},\vname{b}),(\vname{e},\vname{b})},
\]
%
as the edges from satellites to centers.  
%
Now, it
converts each edge into a singleton table, and merges all the tables
into one
table, which is going to become a part of the partition map:
%
\[
P = \cset{\vname{c} \mapsto \vname{b},\vname{e} \mapsto \vname{b}}.
\]
%
Note that the edge $(\vname{c},\vname{a})$ has been removed since when
uniting the tables, we selects only one element for each key in the
domain.  
%
Now for all remaining vertices
%
$V' = V \setminus \cd{domain}(P) = \cset{\vname{a},\vname{b},\vname{d}}$
we map them to themselves, giving:
%
\[
P' = \cset{\vname{a} \mapsto \vname{a}, \vname{b} \mapsto \vname{b},
  \vname{d} \mapsto \vname{d}}.
\]
%
The vertices in $P'$ are the centers.
%
Finally we merge $P$ and $P'$ to obtain the partition map
%
\[
P' \cup P = \cset{\vname{a} \mapsto \vname{a}, \vname{b} \mapsto \vname{b}, \vname{c} \mapsto \vname{b}, \vname{d} \mapsto
    \vname{d}, \vname{e} \mapsto \vname{b}}.
\]
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

</mlxUnit>

<mlxUnit>
<mlxFieldTitle>
Analysis of Star Partitioning
</mlxFieldTitle>
<mlxFieldTitleDex>
Analysis of Star Partitioning
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC4:UN5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>By examining the algorithm, we can conclude the following work and span bounds for the star partition algorithm.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
By examining the algorithm, we can conclude the following work and
span bounds for the star partition algorithm.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTheorem>
<mlxFieldTitle>
Cost of Star Partition
</mlxFieldTitle>
<mlxFieldTitleDex>
Cost of Star Partition
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Based on the array-based cost specification for sequences and single-threaded sequences, the cost of <span class="math inline">\({\texttt{starPartition}}\)</span> is <span class="math display">\[O(n + m)\]</span> work and <span class="math display">\[O(\lg n)\]</span> span for a graph with <span class="math inline">\(n\)</span> vertices and <span class="math inline">\(m\)</span> edges.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Based on the array-based cost specification for sequences and
single-threaded sequences, the cost of $\cd{starPartition}$ is 
\[
O(n + m)
\]
work and 
\[
O(\lg n)
\]
span for a graph with $n$ vertices and $m$ edges.
]]>
</mlxFieldBodyDex>
</mlxAtomTheorem>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExercise>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Prove the theorem.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Prove the theorem.
]]>
</mlxFieldBodyDex>
</mlxAtomExercise>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachAsk>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>In expectation, how big is <span class="math inline">\(P\)</span>?</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
In expectation, how big is $P$?
]]>
</mlxFieldBodyDex>
</mlxAtomTeachAsk>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Number of Satellites
</mlxFieldTitle>
<mlxFieldTitleDex>
Number of Satellites
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR5:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Let us also bound the number of satellites found by <span class="math inline">\({\texttt{starPartition}}.\)</span> Note first that there is a one-to-one mapping between the satellites and the set <span class="math inline">\(P_s\)</span> computed by the algorithm. The following lemma establishes that on a graph with <span class="math inline">\({{n_\bullet}}\)</span> non-isolated vertices, the number of satellites is at least <span class="math inline">\({{n_\bullet}}/4\)</span> in expectation. As we will see this means that we can use star partitions to perform graph contraction with logarithmic span.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Let us also bound the number of satellites found by
$\cd{starPartition}.$
%
Note first that there is a one-to-one mapping between the satellites
and the set $P_s$ computed by  the algorithm.
%
%
The following lemma establishes that on a graph with
$\nn$~non-isolated vertices, the number of satellites is at least
$\nn/4$ in expectation.
%
As we will see this means that we can use star partitions to perform
graph contraction with logarithmic span.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomLemma>
<mlxFieldTitle>
Number of Satelites
</mlxFieldTitle>
<mlxFieldTitleDex>
Number of Satelites
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR6:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For a graph <span class="math inline">\(G\)</span> with <span class="math inline">\({{n_\bullet}}\)</span> non-isolated vertices, the expected number of satellites in a call to <span class="math inline">\({\texttt{starPartition}}~(G,i)\)</span> with any <span class="math inline">\(i\)</span> is at least <span class="math inline">\({{n_\bullet}}/4\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For a graph $G$ with $\nn$ non-isolated vertices, the expected
  number of satellites in a call to $\cd{starPartition}~(G,i)$ with
  any~$i$ is at least $\nn/4$.
]]>
</mlxFieldBodyDex>
</mlxAtomLemma>

<mlxAtomProof>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR6:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR6:AT2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For any vertex <span class="math inline">\(v\)</span>, let <span class="math inline">\(H_v\)</span> be the event that a vertex <span class="math inline">\(v\)</span> comes up heads, <span class="math inline">\(T_v\)</span> that it comes up tails, and <span class="math inline">\(R_v\)</span> that <span class="math inline">\(v \in 
  {\texttt{domain}}(P)\)</span> (i.e, it is a satellite). Consider any non-isolated vertex <span class="math inline">\(v \in V(G)\)</span>. By definition, we know that a non-isolated vertex <span class="math inline">\(v\)</span> has at least one neighbor <span class="math inline">\(u\)</span>. So, we know that <span class="math inline">\(T_v \land H_u\)</span> implies <span class="math inline">\(R_v\)</span>, since if <span class="math inline">\(v\)</span> is a tail and <span class="math inline">\(u\)</span> is a head <span class="math inline">\(v\)</span> must either join <span class="math inline">\(u\)</span>’s star or some other star. Therefore, <span class="math inline">\({\mathbf{P}\left[{R_v}\right]} \geq {\mathbf{P}\left[{T_v}\right]} {\mathbf{P}\left[{H_u}\right]} = 1/4\)</span>. By the linearity of expectation, the expected number of satellites is <span class="math display">\[\begin{aligned}
    {\mathbf{E}\left[{\sum_{v: v \text{ non-isolated}} {\mathbb{I}\left\{R_v\right\}}}\right]} &amp; = \sum_{v: v 
      \text{ non-isolated}} {\mathbf{E}\left[{{\mathbb{I}\left\{R_v\right\}}}\right]}  
\\[2mm] 
  &amp; \geq {{n_\bullet}}/4. 
  \end{aligned}\]</span> The final inequality follows because we have <span class="math inline">\({{n_\bullet}}\)</span> non-isolated vertices and because the expectation of an indicator random variable is equal to the probability that it takes the value <span class="math inline">\(1\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For any vertex $v$, let $H_v$ be the event that a vertex $v$ comes
  up heads, $T_v$ that it comes up tails, and $R_v$ that $v \in
  \cd{domain}(P)$ (i.e, it is a satellite).
%
  Consider any non-isolated vertex $v \in V(G)$.  By definition, we
  know that a non-isolated vertex $v$ has at least one neighbor $u$.
  So, we know that $T_v \land H_u$ implies $R_v$, since if $v$ is a
  tail and $u$ is a head $v$ must either join $u$'s star or some other
  star.  Therefore, $\prob{R_v} \geq \prob{T_v} \prob{H_u} = 1/4$.  By
  the linearity of expectation,  the expected number of satellites is
  \begin{align*}
    \expct{\sum_{v: v \text{ non-isolated}} \onef{R_v}} & = \sum_{v: v
      \text{ non-isolated}} \expct{\onef{R_v}} 
\\[2mm]
  & \geq \nn/4.
  \end{align*}
  The final inequality follows because we have $\nn$ non-isolated
  vertices and because the expectation of an indicator random variable
  is equal to the probability that it takes the value $1$.
]]>
</mlxFieldBodyDex>
</mlxAtomProof>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR7
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN5:GR7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN5:GR7:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN5:GR7:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Consider the random variable that a vertex becomes a satellite. This happens if the vertex flips tails and it has a neighbor that flips heads. A non-isolated vertex has at least one neighbor, therefore this probability is at least 1/4. The bound follows.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Consider the random variable that a vertex becomes a satellite.  This
happens if the vertex flips tails and it has a neighbor that flips
heads.  A non-isolated vertex has at least one neighbor, therefore
this probability is at least 1/4.  The bound follows.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

</mlxUnit>

<mlxUnit>
<mlxFieldTitle>
Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC4:UN6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomDefinition>
<mlxFieldTitle>
Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We refer to a graph contraction that uses star partitions only as a <span> </span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We refer to a graph contraction that uses star partitions only as
a~\defn{star contraction}.
]]>
</mlxFieldBodyDex>
</mlxAtomDefinition>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomAlgorithm>
<mlxFieldTitle>
Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR2:AT1:alg:gc::cc
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; {\texttt{starContract}}~{\texttt{base}}~{\texttt{expand}}~(G = (V,E)) = 
\\  
2 &amp; ~~~{\texttt{if}}~|E| = 0~{\texttt{then}} 
\\ 
3 &amp; ~~~~~~{\texttt{base}}~(V) 
\\ 
4 &amp; ~~~{\texttt{else}} 
\\  
5 &amp; ~~~~~~{\texttt{let}} 
\\  
6 &amp; ~~~~~~~~~(V&#39;,P) = {\texttt{starPartition}}~(V,E)~ \\ 
7 &amp; ~~~~~~~~~E&#39; = {\left\{ ({P[u]},{P[v]}) : (u,v) \in  E \;|\; {P[u]} \neq {P[v]} \right\}}  
\\ 
8 &amp; ~~~~~~~~~R = {\texttt{starContract}}~{\texttt{base}}~{\texttt{expand}}~(V&#39;,E&#39;) 
\\ 
9 &amp; ~~~~~~{\texttt{in}} 
\\ 
10 &amp; ~~~~~~~~~{\texttt{expand}}~(P, R) 
\\ 
11 &amp; ~~~~~~{\texttt{end}} 
\end{array}\]</span></p>
<p>The pseudo-code above illustrates a generic, higher-order star-contraction algorithm. The algorithm takes as arguments</p>
<ul>
<li><p>a function <span class="math inline">\({\texttt{base}}\)</span> that specifies the computation in the base case,</p></li>
<li><p>another function <span class="math inline">\({\texttt{expand}}\)</span> that computes the result for the larger graph from the smaller, contracted graph, and</p></li>
<li><p>the graph.</p></li>
</ul>
<p>Each contraction on Line <span>6</span> returns the set of (centers) super-vertices <span class="math inline">\(V&#39;\)</span> and a table <span class="math inline">\(P\)</span> mapping every <span class="math inline">\(v \in V\)</span> to a <span class="math inline">\(v&#39; \in V&#39;\)</span>. The set <span class="math inline">\(V&#39;\)</span> defines the super-vertices of the quotient graph. Line <span>7</span> completes the construction of the quotient graph:</p>
<ul>
<li><p>it computes the edges of the quotient graph by routing the end points of each edge to the corresponding super-vertices in <span class="math inline">\(V&#39;\)</span>, which is specified by the table <span class="math inline">\(P\)</span>;</p></li>
<li><p>it removes all self edges via the filter <span class="math inline">\({P[u]} 
\neq {P[v]}\)</span>.</p></li>
</ul>
<p>Having computed the quotient graph, the algorithm recurs. Recursion bottoms out when the graph contains no edges, in which case, the function <span class="math inline">\({\texttt{base}}\)</span> is applied to the remaining vertices. In the base case, each connected component has been contracted down to a singleton vertex, and thus the number of vertices in the contracted graph is equal to the number of components in the input graph.</p>
<p>The result of the recursive call <span class="math inline">\(R\)</span> is “expanded” to compute the result for the whole graph by calling the function <span class="math inline">\({\texttt{expand}}\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
\[
\begin{array}{ll}
1 & \cd{starContract}~\cd{base}~\cd{expand}~(G = (V,E)) =
\\ 
2 & ~~~\cd{if}~|E| = 0~\cd{then}
\\
3 & ~~~~~~\cd{base}~(V)
\\
4 & ~~~\cd{else}
\\ 
5 & ~~~~~~\cd{let}
\\ 
6 & ~~~~~~~~~(V',P) = \cd{starPartition}~(V,E)~ % @\label{line:gc::cc::partition}@
\\
7 & ~~~~~~~~~E' = \csetf{(\cget{P}{u},\cget{P}{v}) : (u,v) \in  E}{\cget{P}{u} \neq \cget{P}{v}} 
% @\label{line:gc::cc::edges}@
\\
8 & ~~~~~~~~~R = \cd{starContract}~\cd{base}~\cd{expand}~(V',E')
\\
9 & ~~~~~~\cd{in}
\\
10 & ~~~~~~~~~\cd{expand}~(P, R)
\\
11 & ~~~~~~\cd{end}
\end{array}
\]

The pseudo-code above illustrates a generic, higher-order
star-contraction algorithm.
%
The algorithm takes as arguments
\begin{itemize}
\item  a function $\cd{base}$ that specifies
the computation in the base case,

\item 
another function $\cd{expand}$ that computes the result for the larger
graph from the smaller, contracted graph, and 

\item
the graph.
\end{itemize}


Each contraction on Line~\linegcscpartition{} returns the set of
(centers) super-vertices $V'$ and a table $P$ mapping every $v \in V$
to a $v' \in V'$.
%
The set $V'$ defines the super-vertices of the quotient graph.
%

Line~\linegcscedges{} completes the construction of the quotient graph:
%
\begin{itemize}
\item it computes the edges of the quotient graph by 
routing the end points of each edge to the corresponding
super-vertices in $V'$, which is specified by the table $P$;
%
\item it  removes all self edges via the  filter $\cget{P}{u}
\neq \cget{P}{v}$.
%
\end{itemize}
%

Having computed the quotient graph, the algorithm recurs.
%
Recursion bottoms out when the graph contains no edges, in which case,
the function $\cd{base}$ is applied to the remaining vertices.
%
In the base case, each connected component has been contracted down to
a singleton vertex, and thus the number of vertices in the contracted
graph is equal to the number of components in the input graph.

The result of the recursive call $R$ is ``expanded'' to compute the result
for the whole graph by calling the function $\cd{expand}$.
]]>
</mlxFieldBodyDex>
</mlxAtomAlgorithm>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExercise>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>I did not work out the arguments for <span class="math inline">\({\texttt{base}}\)</span> and <span class="math inline">\({\texttt{expand}}\)</span> carefully. Discuss here what it should be by clicking on the “discuss” button on the right hand corner of this block.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
I did not work out the arguments for $\cd{base}$ and $\cd{expand}$
carefully.  Discuss here what it should be by clicking on the ``discuss''
button on the right hand corner of this block.
]]>
</mlxFieldBodyDex>
</mlxAtomExercise>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>TODO [this is somewhat resolved] This analysis is rather imprecise, because we have not written the pseudocode for graph contraction. How do we re-route edges and such. This should be done.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
TODO [this is somewhat resolved]
This analysis is rather imprecise, because we have not written the
pseudocode for graph contraction.  How do we re-route edges and such.
This should be done.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTheorem>
<mlxFieldTitle>
Work and Span of Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Work and Span of Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR5:AT1:thm:gc::star-contraction-cost
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For a graph <span class="math inline">\(G = (V,E)\)</span>, we can contract the graph into a number of isolated vertices in <span class="math inline">\(O(|V| + |E| \lg |V|)\)</span> work and <span class="math inline">\(O(\lg^2 |V|)\)</span> span.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For a graph $G = (V,E)$, we can contract the graph into a number of
  isolated vertices   in $O(|V| + |E| \lg |V|)$ work and $O(\lg^2 |V|)$ span.
]]>
</mlxFieldBodyDex>
</mlxAtomTheorem>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR5:AT2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For the proof, we will consider work and span separately and assume that</p>
<ul>
<li><p>function <span class="math inline">\({\texttt{base}}\)</span> has constant span and linear work in the number of vertices passed as argument, and</p></li>
<li><p>function <span class="math inline">\({\texttt{expand}}\)</span> has linear work and logarithmic span in the number of vertices and edges at the corresponding step of the contraction.</p></li>
</ul>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For the proof, we will consider work and span separately
%
and assume that
%
\begin{itemize}
   \item function $\cd{base}$ has constant span and linear work in the
     number of vertices passed as argument, and
\item function $\cd{expand}$ has linear work and logarithmic span in
  the number of vertices and edges at the corresponding step of the
  contraction.
  \end{itemize}
]]>
</mlxFieldBodyDex>
</mlxAtomGram>

<mlxAtomGram>
<mlxFieldTitle>
Span of Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Span of Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5:AT3
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR5:AT3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Let <span class="math inline">\({{n_\bullet}}\)</span> be the number of non-isolated vertices. In star contraction, once a vertex becomes isolated, it remains isolated until the final round, since contraction only removes edges. Let <span class="math inline">\({{n_\bullet}}&#39;\)</span> denote the number of non-isolated vertices after one round of star contraction. We can write the following recurrence for the span of star contraction. <span class="math display">\[\begin{array}{lll} 
S({{n_\bullet}})  &amp; = &amp; 
\left\{ 
\begin{array}{lll} 
S({{n_\bullet}}&#39;) + O(\lg n) &amp; \mbox{if} &amp; {{n_\bullet}}&gt; 0 
\\ 
1 &amp; \mbox{otherwise.} 
\end{array} 
\right. 
\end{array}\]</span> Observe that <span class="math inline">\({{n_\bullet}}&#39; = {{n_\bullet}}- X\)</span>, where <span class="math inline">\(X\)</span> is the number of satellites (as defined earlier in the lemma about <span class="math inline">\({\texttt{starPartition}}\)</span>), which are removed at a step of contraction. Since <span class="math inline">\({\mathbf{E}\left[{X}\right]} = {{n_\bullet}}/4\)</span>, <span class="math inline">\({\mathbf{E}\left[{{{n_\bullet}}&#39;}\right]} = 3n/4\)</span>. This is a familiar recurrence, which we know solves to <span class="math inline">\(O(\lg^2 
{{n_\bullet}})\)</span>, and thus <span class="math inline">\(O(\lg^2 n)\)</span>, in expectation.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Let $\nn$ be the number of non-isolated vertices.
%
In star contraction, once a vertex becomes isolated, it remains
isolated until the final round, since contraction only removes edges.
%
Let $\nn'$ denote the number of non-isolated vertices after one round of star
contraction.
%

We can write the following recurrence for the span of star contraction.
%
\[
\begin{array}{lll}
S(\nn)  & = &
\left\{
\begin{array}{lll}
S(\nn') + O(\lg n) & \mbox{if} & \nn > 0
\\
1 & \mbox{otherwise.}
\end{array}
\right.
\end{array}
\]
%

Observe that $\nn' = \nn - X$, where $X$ is the number of satellites
(as defined earlier in the lemma about $\cd{starPartition}$), which are
removed at a step of contraction. Since $\expct{X} = \nn/4$,
$\expct{\nn'} = 3n/4$.
%
This is a familiar recurrence, which we know solves to $O(\lg^2
\nn)$, and thus $O(\lg^2 n)$, in expectation.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>

<mlxAtomGram>
<mlxFieldTitle>
Work of Star Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Work of Star Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5:AT4
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR5:AT4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For work, we would like to show that the overall work is linear, because we might hope that the graph size is reduced by a constant fraction on each round. Unfortunately, this is not the case. Although we have shown that star contraction can remove a constant fraction of the non-isolated vertices in one round, we have not bounded the number of edges removed. Because removing a satellite also removes the edge that attaches it to its star’s center, each round removes at least as many edges as vertices. But this does not help us bound the number of edges removed by a linear function of <span class="math inline">\(m\)</span>, because there can be as many an <span class="math inline">\(n^2\)</span> edges in the graph. Thus, all we know is that there are no more than <span class="math inline">\(m-n\)</span> after one round of contraction.</p>
<p>To bound the work, we will consider non-isolated and isolated vertices separately. Let <span class="math inline">\({{n_\bullet}}&#39;\)</span> denote the number of non-isolated vertices after one round of star contraction. For the non-isolated vertices, we have the following work recurrence: <span class="math display">\[\begin{array}{lll} 
W({{n_\bullet}}, m)  
\leq  
\left\{ 
\begin{array}{lll} 
W({{n_\bullet}}&#39;, m) + O({{n_\bullet}}+m) &amp; \mbox{if} &amp; {{n_\bullet}}&gt; 1 
\\ 
1 &amp; \mbox{otherwise.} 
\end{array} 
\right. 
\end{array}\]</span> This recursion solves to <span class="math display">\[{\mathbf{E}\left[{W({{n_\bullet}},m)}\right]} = O({{n_\bullet}}+ m\lg {{n_\bullet}}) = O(n + m \lg{n}).\]</span></p>
<p>To bound the work on isolated vertices, we note that there at most <span class="math inline">\(n\)</span> of them at each round and thus, the additional work is <span class="math inline">\(O(n \lg{n}).\)</span></p>
<p>We thus conclude that the total work is <span class="math display">\[O(n + m\lg{n}).\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For work, we would like to show that the overall work is linear,
because we might hope that the graph size is reduced by a constant
fraction on each round.
%
Unfortunately, this is not the case.  Although we have shown that star
contraction can remove a constant fraction of the non-isolated
vertices in one round, we have not bounded the number of edges
removed.
%

%% \begin{teachask}
%% How many edges can we remove? 
%% \end{teachask}
%
Because removing a satellite also removes the edge that attaches it to
its star's center, each round  removes at least as many edges as vertices.  
%
But this does not help us bound
the number of edges removed by a linear function of $m$, because there
can be as many an $n^2$ edges in the graph.
%
Thus, all we know is that there are no more than $m-n$ after one
round of contraction.

To bound the work, we will consider non-isolated and isolated vertices
separately.
%
Let $\nn'$  denote the  number of non-isolated vertices after one
round of star contraction.
%
For the non-isolated vertices, we have the following work recurrence:
\[
\begin{array}{lll}
W(\nn, m) 
\leq 
\left\{
\begin{array}{lll}
W(\nn', m) + O(\nn+m) & \mbox{if} & \nn > 1
\\
1 & \mbox{otherwise.}
\end{array}
\right.
\end{array}
\]
%
This recursion solves to
\[
\expct{W(\nn,m)} = O(\nn + m\lg \nn) = O(n + m \lg{n}).
\]

To bound the work on isolated vertices, we note that there at most $n$
of them at each round and thus, the additional work is $O(n \lg{n}).$

We thus conclude that the total work is
\[
O(n + m\lg{n}).
\]
]]>
</mlxFieldBodyDex>
</mlxAtomGram>

<mlxAtomNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR5:AT5
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR5:AT5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Consider as an example a star contraction where <span class="math inline">\(n\)</span> and <span class="math inline">\(m\)</span> have the following values in each round. <span class="math display">\[\begin{array}{lll} 
\hline 
 \mbox{round} &amp; \mbox{vertices} &amp; \mbox{edges} 
\\ 
\hline 
 1 &amp; n &amp; m  
\\ 
 2 &amp; n/2 &amp; m - n/2  
\\ 
 3 &amp; n/4 &amp; m - 3n/4  
\\ 
 4 &amp; n/8 &amp; m - 7n/8  
\\ 
\hline 
 \end{array}\]</span> It is clear that the number of edges does not drop below <span class="math inline">\(m-n,\)</span> so if there are <span class="math inline">\(m &gt; 2n\)</span> edges to start with, the overall work will be <span class="math inline">\(O(m 
\lg n)\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Consider as an example a star contraction where $n$ and $m$ have the
following values in each round.
\[
\begin{array}{lll}
\hline
 \mbox{round} & \mbox{vertices} & \mbox{edges}
\\
\hline
 1 & n & m 
\\
 2 & n/2 & m - n/2 
\\
 3 & n/4 & m - 3n/4 
\\
 4 & n/8 & m - 7n/8 
\\
\hline
 \end{array}
\]
It is clear that the number of edges does not drop below $m-n,$ so if
there are $m > 2n$ edges to start with, the overall work will be $O(m
\lg n)$.
%
]]>
</mlxFieldBodyDex>
</mlxAtomNote>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR6:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Note that if the graph is complete, we do actually reduce the number of edges by a constant fraction be eliminating redundancy, because we can only have so many edges in the quotient graph. This brings up an interesting point about when this algorithm actually performs poorly. It might be interesting to study some real world instance.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Note that if the graph is complete, we do actually reduce the number
of edges by a constant fraction be eliminating redundancy, because we
can only have so many edges in the quotient graph. This brings up an
interesting point about when this algorithm actually performs poorly.
It might be interesting to study some real world instance.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR7
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC4:UN6:GR7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC4:UN6:GR7:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC4:UN6:GR7:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Idea: Consider a contraction along with the randomness function. Consider each round and the blocks contracted in that round. Add just as many edges as possible (without leading to duplicates) between those blocks. Make sure that you don’t generate duplicates in following rounds. Since each block is nested inside a logarithmic number of other blocks. It is possible to construct such a graph that also has a large number of edges.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Idea: Consider a contraction along with the randomness function.
Consider each round and the blocks contracted in that round.
Add just as many edges as possible (without leading to duplicates)
between those blocks.  Make sure that you don't generate duplicates
in following rounds.  Since each block is nested inside a
logarithmic number of other blocks.  It is possible to construct
such a graph that also has a large number of edges.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachNote>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Connectivity via Graph Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Connectivity via Graph Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC5:UN7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomProblem>
<mlxFieldTitle>
The Graph Connectivity (GC) Problem
</mlxFieldTitle>
<mlxFieldTitleDex>
The Graph Connectivity (GC) Problem
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Given an undirected graph <span class="math inline">\(G = (V,E)\)</span>, the <span> </span> requires finding all of the connected components of <span class="math inline">\(G\)</span> by specifying the set of vertices in each component.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Given an undirected graph $G = (V,E)$, the \defn{graph-connectivity
  problem} requires finding all of the connected components of $G$ by
specifying the set of vertices in each component.
]]>
</mlxFieldBodyDex>
</mlxAtomProblem>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomTeachAsk>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Solve the graph-connectivity problem by using one of the techniques recently covered earlier in the course.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Solve the graph-connectivity problem by using one of the
  techniques recently covered earlier in the course.
]]>
</mlxFieldBodyDex>
</mlxAtomTeachAsk>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Sequential Algorithms for Connectivity
</mlxFieldTitle>
<mlxFieldTitleDex>
Sequential Algorithms for Connectivity
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The graph connectivity problem can be solved by using graph search as follows.</p>
<ul>
<li><p>Start at any vertex and find, using DFS or BFS, all vertices reachable from that vertex and mark them visited. This creates the first connected component.</p></li>
<li><p>Select another vertex, and if it has not already been visited, then search from that vertex to create the second component. Repeat until all the vertices are considered.</p></li>
</ul>
<p>This approach leads to a perfectly sensible sequential algorithms for graph connectivity, but they are not good parallel algorithms. DFS for example is a purely sequential algorithm. Using BFS for each component can yield some parallelism but still the span of BFS is lower-bounded by the diameter of the graph. Note that the diameter of a component can be as large as <span class="math inline">\(n-1\)</span>. A “chain” of <span class="math inline">\(n\)</span> vertices will have diameter <span class="math inline">\(n-1\)</span>. Even if the diameter of the graph is small, we still have to iterate over the components sequentially one by one. Thus the span in the worst case can be linear in the number of components, which can be large.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The graph connectivity problem can be solved by using graph search as
follows. 
\begin{itemize}
\item Start at any vertex and find, using DFS or BFS, all vertices
  reachable from that vertex and mark them visited. This creates the
  first connected component.

\item 
Select another vertex, and if it has not already been visited, then
search from that vertex to create the second component. 
%
Repeat until all the vertices are considered.
%
%
\end{itemize}

This approach leads to a perfectly sensible sequential algorithms for
graph connectivity, but they are not good parallel algorithms.
%
DFS for example is a purely sequential algorithm.
%
Using BFS for each component can yield some parallelism but still the
span of BFS is lower-bounded by the diameter of the graph.
%
Note that the diameter of a component can be as large as~$n-1$.  A
``chain'' of $n$ vertices will have diameter $n-1$.
%

Even if the diameter of the graph is small, we still have to iterate
over the components sequentially one by one.  Thus the span in the
worst case can be linear in the number of components, which can be
large.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We would like to find a parallel algorithm for connectivity that has a small span an all graphs. To this end, we use the graph-contraction technique with star partitions. To specify the algorithm, we use an edge-set representation for graphs, where every edge is represented as a pair of vertices, in both orders. This is effectively equivalent to a directed graph representation of undirected graphs with two arcs per edge.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We would like to find a parallel algorithm for connectivity that has a
small span an all graphs.  To this end, we use the graph-contraction
technique with star partitions.  
%
To specify the algorithm, we use an edge-set representation for
graphs, where every edge is represented as a pair of vertices, in both
orders.  
%
This is effectively equivalent to a directed graph representation of
undirected graphs with two arcs per edge.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR5
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR5
</mlxLabel>
<mlxNo>
5
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR5:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR5:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The edge-set representation of an undirected graph is shown below.</p>
<p><img src="./media/contract-example1.jpg" alt="image" width="2" /></p>
<p><span class="math display">\[\begin{array}{lcl} 
V &amp; = &amp; {\left\{ {{\texttt{a}}},{{\texttt{b}}},{{\texttt{c}}},{{\texttt{d}}},{{\texttt{e}}},{{\texttt{f}}} \right\}}\\ 
E &amp; = &amp; 
\{({{\texttt{a}}},{{\texttt{b}}}),({{\texttt{b}}},{{\texttt{a}}}),({{\texttt{b}}},{{\texttt{d}}}),({{\texttt{b}}},{{\texttt{e}}}),({{\texttt{e}}},{{\texttt{b}}}),({{\texttt{d}}},{{\texttt{b}}}),({{\texttt{d}}},{{\texttt{f}}}),({{\texttt{a}}},{{\texttt{c}}}), 
\\ 
&amp; &amp; ~~({{\texttt{c}}},{{\texttt{a}}}),({{\texttt{c}}},{{\texttt{d}}}),({{\texttt{d}}},{{\texttt{c}}}),({{\texttt{d}}},{{\texttt{f}}}),({{\texttt{f}}},{{\texttt{d}}}),({{\texttt{e}}},{{\texttt{f}}}),({{\texttt{f}}},{{\texttt{e}}})\} 
\end{array}\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The edge-set representation of an undirected graph is shown below.

\begin{center}
  \includegraphics[width=2.2]{./media/contract-example1.jpg}
\end{center}

\[
\begin{array}{lcl}
V & = & \cset{\vname{a},\vname{b},\vname{c},\vname{d},\vname{e},\vname{f}}\\
E & = &
\{(\vname{a},\vname{b}),(\vname{b},\vname{a}),(\vname{b},\vname{d}),(\vname{b},\vname{e}),(\vname{e},\vname{b}),(\vname{d},\vname{b}),(\vname{d},\vname{f}),(\vname{a},\vname{c}),
\\
& & ~~(\vname{c},\vname{a}),(\vname{c},\vname{d}),(\vname{d},\vname{c}),(\vname{d},\vname{f}),(\vname{f},\vname{d}),(\vname{e},\vname{f}),(\vname{f},\vname{e})\}
\end{array}
\]
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR6
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomAlgorithm>
<mlxFieldTitle>
Counting Components using Graph Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Counting Components using Graph Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR6:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR6:AT1:alg:gc::cc
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; {\texttt{countComponents}}~(G = (V,E)) = 
\\  
2 &amp; ~~~{\texttt{if}}~|E| = 0~{\texttt{then}} 
\\ 
3 &amp; ~~~~~~|V| 
\\ 
4 &amp; ~~~{\texttt{else}} 
\\  
5 &amp; ~~~~~~{\texttt{let}} 
\\  
6 &amp; ~~~~~~~~~(V&#39;,P) = {\texttt{starPartition}}~(V,E) 
\\ 
7 &amp; ~~~~~~~~~E&#39; = {\left\{ ({P[u]},{P[v]}) : (u,v) \in  E \;|\; {P[u]} \neq {P[v]} \right\}} \\ 
8 &amp; ~~~~~~~~~R = {\texttt{countComponents}}~(V&#39;,E&#39;) 
\\ 
9 &amp; ~~~~~~{\texttt{in}} 
\\ 
10 &amp; ~~~~~~~~~R 
\\ 
11 &amp; ~~~~~~{\texttt{end}} 
\end{array}\]</span></p>
<p>The pseudo-code above shows a graph-contraction algorithm for determining the number of connected components in a graph. Each contraction on returns the set of (centers) super-vertices <span class="math inline">\(V&#39;\)</span> and a table <span class="math inline">\(P\)</span> mapping every <span class="math inline">\(v \in V\)</span> to a <span class="math inline">\(v&#39; \in V&#39;\)</span>. The set <span class="math inline">\(V&#39;\)</span> defines the super-vertices of the quotient graph. completes the computation of the quotient graph.</p>
<ul>
<li><p>it computes the edges of the quotient graph by routing the end points of each edge to the corresponding super-vertices in <span class="math inline">\(V&#39;\)</span>, which is specified by the table <span class="math inline">\(P\)</span>;</p></li>
<li><p>it removes all self edges via the filter <span class="math inline">\({P[u]} 
\neq {P[v]}\)</span>.</p></li>
</ul>
<p>Having computed the quotient graph, the algorithm recursively solves the problem on it. Recursion bottoms out when the graph contains no edges, in which case, each component has been contracted down to a singleton vertex, and thus the number of vertices in the contracted graph is equal to the number of components in the input graph.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
\[
\begin{array}{ll}
1 & \cd{countComponents}~(G = (V,E)) =
\\ 
2 & ~~~\cd{if}~|E| = 0~\cd{then}
\\
3 & ~~~~~~|V|
\\
4 & ~~~\cd{else}
\\ 
5 & ~~~~~~\cd{let}
\\ 
6 & ~~~~~~~~~(V',P) = \cd{starPartition}~(V,E)
\\
7 & ~~~~~~~~~E' = \csetf{(\cget{P}{u},\cget{P}{v}) : (u,v) \in  E}{\cget{P}{u} \neq \cget{P}{v}} %
\\
8 & ~~~~~~~~~R = \cd{countComponents}~(V',E')
\\
9 & ~~~~~~\cd{in}
\\
10 & ~~~~~~~~~R
\\
11 & ~~~~~~\cd{end}
\end{array}
\]

%% \[
%% \begin{lstlisting}
%% countComponents $(G = (V,E))$ = 
%%   if $|E| = 0$ then $
%%     |V|$
%%   else 
%%     let 
%%       $(V',P)$ = starPartition $(V,E)$ @\label{line:gc::cc::partition}@
%%       $E'$ = $\csetf{(\cget{P}{u},\cget{P}{v}) : (u,v) \in E}{\cget{P}{u} \neq \cget{P}{v}}$ @\label{line:gc::cc::edges}@
%%     in
%%       countComponents $(V',E')$
%%     end
%% \end{lstlisting}



The pseudo-code above shows a graph-contraction algorithm for
determining the number of connected components in a graph.
%
Each contraction on \lineref{gc::cc::partition} returns the set of
(centers) super-vertices $V'$ and a table $P$ mapping every $v \in V$
to a $v' \in V'$.
%
The set $V'$ defines the super-vertices of the quotient graph.
%
\lineref{gc::cc::edges} completes the computation of the quotient graph.
\begin{itemize}
\item it computes the edges of the quotient graph by 
routing the end points of each edge to the corresponding
super-vertices in $V'$, which is specified by the table $P$;
%
\item it  removes all self edges via the  filter $\cget{P}{u}
\neq \cget{P}{v}$.
%
\end{itemize}
%
Having computed the quotient graph, the algorithm recursively solves
the problem on it.
%
Recursion bottoms out when the graph contains no edges, in which case,
each component has been contracted down
to a singleton vertex, and thus the number of vertices in the
contracted graph is equal to the number of components in the input graph.
]]>
</mlxFieldBodyDex>
</mlxAtomAlgorithm>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR6:AT2
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR6:AT2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The values of <span class="math inline">\(V&#39;\)</span>, <span class="math inline">\(P\)</span>, and <span class="math inline">\(E&#39;\)</span> after each round of the contraction shown in . <span class="math display">\[\begin{array}{crcl} 
  &amp; V&#39; &amp; = &amp; {\left\{ {{\texttt{a}}},{{\texttt{d}}},{{\texttt{ef}}} \right\}}\\ 
\mbox{Round } 1 &amp; P&#39; &amp; = &amp;  
 {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}},  
       {{\texttt{b}}} \mapsto {{\texttt{a}}},  
       {{\texttt{c}}} \mapsto {{\texttt{a}}},  
       {{\texttt{d}}} \mapsto {{\texttt{d}}},  
       {{\texttt{e}}} \mapsto {{\texttt{e}}},  
       {{\texttt{f}}} \mapsto {{\texttt{e}}} \right\}}\\ 
  &amp; E&#39; &amp; = &amp; {\left\{ ({{\texttt{a}}},{{\texttt{e}}}), 
               ({{\texttt{e}}},{{\texttt{a}}}), 
               ({{\texttt{a}}},{{\texttt{d}}}), 
               ({{\texttt{d}}},{{\texttt{a}}}), 
               ({{\texttt{d}}},{{\texttt{e}}}), 
               ({{\texttt{e}}},{{\texttt{d}}}) \right\}}\\[.1in] 
  &amp; V&#39; &amp; = &amp; {\left\{ {{\texttt{a}}},{{\texttt{e}}} \right\}}\\ 
\mbox{Round } 2 &amp; P&#39; &amp; = &amp;  
 {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}},  
       {{\texttt{d}}} \mapsto {{\texttt{abcd}}},  
       {{\texttt{e}}} \mapsto {{\texttt{e}}} \right\}}\\ 
  &amp; E&#39; &amp; = &amp; {\left\{ ({{\texttt{a}}},{{\texttt{e}}}), 
               ({{\texttt{e}}},{{\texttt{a}}}) \right\}}\\[.1in] 
  &amp; V&#39; &amp; = &amp; {\left\{ {{\texttt{a}}} \right\}}\\ 
\mbox{Round } 3 &amp; P&#39; &amp; = &amp;  
 {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}},  
       {{\texttt{e}}} \mapsto {{\texttt{a}}} \right\}}\\ 
  &amp; E&#39; &amp; = &amp; {\left\{  \right\}} 
\end{array}\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The values of $V'$, $P$, and $E'$ after each round of the 
contraction shown in \exref{gc::contract-example}.
\[
\begin{array}{crcl}
  & V' & = & \cset{\vname{a},\vname{d},\vname{ef}}\\
\mbox{Round } 1 & P' & = & 
 \cset{\vname{a} \mapsto \vname{a}, 
       \vname{b} \mapsto \vname{a}, 
       \vname{c} \mapsto \vname{a}, 
       \vname{d} \mapsto \vname{d}, 
       \vname{e} \mapsto \vname{e}, 
       \vname{f} \mapsto \vname{e}}\\
  & E' & = & \cset{(\vname{a},\vname{e}),
               (\vname{e},\vname{a}),
               (\vname{a},\vname{d}),
               (\vname{d},\vname{a}),
               (\vname{d},\vname{e}),
               (\vname{e},\vname{d})}\\[.1in]
  & V' & = & \cset{\vname{a},\vname{e}}\\
\mbox{Round } 2 & P' & = & 
 \cset{\vname{a} \mapsto \vname{a}, 
       \vname{d} \mapsto \vname{abcd}, 
       \vname{e} \mapsto \vname{e}}\\
  & E' & = & \cset{(\vname{a},\vname{e}),
               (\vname{e},\vname{a})}\\[.1in]
  & V' & = & \cset{\vname{a}}\\
\mbox{Round } 3 & P' & = & 
 \cset{\vname{a} \mapsto \vname{a}, 
       \vname{e} \mapsto \vname{a}}\\
  & E' & = & \cset{}
\end{array}
\]
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR7
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExercise>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR7:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR7:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Express <span class="math inline">\({\texttt{countComponents}}\)</span> in terms of higher order function <span class="math inline">\({\texttt{starContract}}\)</span> by giving <span class="math inline">\({\texttt{base}}\)</span> and <span class="math inline">\({\texttt{expand}}\)</span> functions.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Express $\cd{countComponents}$ in terms of higher order function
  $\cd{starContract}$ by giving $\cd{base}$ and $\cd{expand}$ functions.
]]>
</mlxFieldBodyDex>
</mlxAtomExercise>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR8
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR8
</mlxLabel>
<mlxNo>
8
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR8:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR8:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We can modify the algorithm slightly to compute the components themselves instead of returning their count. To this end, we are going to construct the mapping from vertices to their components recursively. This is possible because we can obtain the mapping by composing the mapping from vertices to their super-vertices and the mapping from super-vertices to their components, which we obtain recursively. shows the algorithm.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We can modify the algorithm slightly to compute the components
themselves instead of returning their count. 
%
To this end, we are going to construct the mapping from vertices to
their components recursively. This is possible because we can obtain
the mapping by composing the mapping from vertices to their
super-vertices and the mapping from super-vertices to their
components, which we obtain recursively. \algref{gc::nc} shows the
algorithm.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR9
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR9
</mlxLabel>
<mlxNo>
9
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomAlgorithm>
<mlxFieldTitle>
Contraction-based graph connectivity
</mlxFieldTitle>
<mlxFieldTitleDex>
Contraction-based graph connectivity
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR9:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR9:AT1:alg:gc::nc
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p><span class="math display">\[\begin{array}{ll} 
1 &amp; {\texttt{connectedComponents}}~(G = (V,E)) =  
\\ 
2 &amp; ~~~{\texttt{if}}~|E| = 0~{\texttt{then}} 
\\  
3 &amp; ~~~~~~(V, {\left\{ v \mapsto v : v \in V \right\}}) 
\\ 
4 &amp; ~~~{\texttt{else}} 
\\  
5 &amp; ~~~~~~{\texttt{let}} 
\\ 
6 &amp; ~~~~~~~~~(V&#39;,P) = {\texttt{starPartition}}~(V,E) 
\\ 
7 &amp; ~~~~~~~~~E&#39; = {\left\{ ({P[u]},{P[v]}) : (u,v) \in E \;|\; {P[u]} \neq {P[v]} \right\}}$  
\\ 
8 &amp; ~~~~~~~~~(V&#39;&#39;,C) = {\texttt{connectedComponents}}~(V&#39;,E&#39;) 
\\ 
9 &amp; ~~~~~~{\texttt{in}} 
\\ 
10 &amp; ~~~~~~~~~(V&#39;&#39;, {\left\{ v \mapsto C[s] : (v \mapsto s) \in P \right\}}) \\ 
11 &amp; ~~~~~~{\texttt{end}} 
\end{array}\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
\[
\begin{array}{ll}
1 & \cd{connectedComponents}~(G = (V,E)) = 
\\
2 & ~~~\cd{if}~|E| = 0~\cd{then}
\\ 
3 & ~~~~~~(V, \cset{v \mapsto v : v \in V})
\\
4 & ~~~\cd{else}
\\ 
5 & ~~~~~~\cd{let}
\\
6 & ~~~~~~~~~(V',P) = \cd{starPartition}~(V,E)
\\
7 & ~~~~~~~~~E' = \csetf{(\cget{P}{u},\cget{P}{v}) : (u,v) \in E}{\cget{P}{u} \neq \cget{P}{v}}$ 
\\
8 & ~~~~~~~~~(V'',C) = \cd{connectedComponents}~(V',E')
\\
9 & ~~~~~~\cd{in}
\\
10 & ~~~~~~~~~(V'', \cset{v \mapsto C[s] : (v \mapsto s) \in P}) % @\label{line:gc::nc::back}@
\\
11 & ~~~~~~\cd{end}
\end{array}
\]
% old code : \cset{v \mapsto \cget{P'}{\cget{P}{v}} : v \in V}
]]>
</mlxFieldBodyDex>
</mlxAtomAlgorithm>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR10
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR10
</mlxLabel>
<mlxNo>
10
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR10:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR10:AT1:ex:concomp
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Applying <span class="math inline">\({\texttt{connectedComponents}}\)</span> to the following graph</p>
<p><img src="./media/contract-example1.jpg" alt="image" width="2" /></p>
<p>might return:</p>
<p><span class="math display">\[\begin{aligned}
({\left\{ {{\texttt{a}}} \right\}}, ~{\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{b}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{c}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{d}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{e}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{f}}} \mapsto {{\texttt{a}}} \right\}}) \end{aligned}\]</span></p>
<p>This is because there is a single component and all vertices will map to that component label. In this case <span class="math inline">\({{\texttt{a}}}\)</span> was picked as the representative, but any of the initial vertices is a valid representative, in which case all vertices would map to it.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Applying $\cd{connectedComponents}$ to the following graph

\begin{center}
\includegraphics[width=2.2]{./media/contract-example1.jpg}
\end{center}

might return:

\begin{eqnarray*}
(\cset{\vname{a}}, ~\cset{\vname{a} \mapsto \vname{a}, 
                          \vname{b} \mapsto \vname{a}, 
                          \vname{c} \mapsto \vname{a}, 
                          \vname{d} \mapsto \vname{a}, 
                          \vname{e} \mapsto \vname{a}, 
                          \vname{f} \mapsto \vname{a}})
\end{eqnarray*}

This is because there is a single component and all vertices will map
to that component label.  In this case $\vname{a}$ was picked as the
representative, but any of the initial vertices is a valid
representative, in which case all vertices would map to it.
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR11
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR11
</mlxLabel>
<mlxNo>
11
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR11:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR11:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The only differences from <span class="math inline">\({\texttt{countComponents}}\)</span> are a modification to the base case, and the extra line (Line <span>10</span>) after the recursive call. In the base case instead of returning the size of <span class="math inline">\(V\)</span> returns all vertices in <span class="math inline">\(V\)</span> along with a mapping from each one to itself. This is a valid answer since if there are no edges each vertex is its own component. In the inductive case, when returning from the recursion, Line <span>10</span> updates the mapping <span class="math inline">\(P\)</span> from vertices to super-vertices by looking up the component that the super-vertex belongs to, which is given by <span class="math inline">\(C\)</span>. This simply involves the look up <span class="math inline">\(C[s]\)</span> for every <span class="math inline">\((v \mapsto s) \in P\)</span>. Note that if you view a mapping as a function, then this is equivalent to function composition, i.e., <span class="math inline">\(C \circ P\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The only differences from $\cd{countComponents}$ are a modification
to the base case, and the extra line (Line~\linegcncback{}) after
the recursive call.  In the base case instead of returning the size of
$V$ returns all vertices in $V$ along with a mapping from each one to
itself.  This is a valid answer since if there are no edges each
vertex is its own component.  In the inductive case, when returning
from the recursion, Line~\linegcncback{} updates the mapping $P$
from vertices to super-vertices by looking up the component that the
super-vertex belongs to, which is given by $C$.  This simply involves
the look up $C[s]$ for every $(v \mapsto s) \in P$.  Note that if you
view a mapping as a function, then this is equivalent to function
composition, i.e., $C \circ P$.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR12
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR12
</mlxLabel>
<mlxNo>
12
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR12:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR12:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Consider the following example graph.</p>
<p><img src="./media/contract-example1.jpg" alt="image" width="2" /></p>
<p>Suppose that <span class="math inline">\({\texttt{starPartition}}\)</span> returns: <span class="math display">\[\begin{array}{lcl} 
V&#39; &amp; = &amp; {\left\{ {{\texttt{a}}},{{\texttt{d}}},{{\texttt{e}}} \right\}}\\ 
P &amp; = &amp;  
 {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}}, {{\texttt{b}}} \mapsto {{\texttt{a}}},  
       {{\texttt{c}}} \mapsto {{\texttt{a}}}, {{\texttt{d}}} \mapsto {{\texttt{d}}},  
       {{\texttt{e}}} \mapsto {{\texttt{e}}}, {{\texttt{f}}} \mapsto {{\texttt{e}}} \right\}}. 
\end{array}\]</span> This pairing corresponds to the case where <span class="math inline">\(a\)</span>, <span class="math inline">\(d\)</span> and <span class="math inline">\(e\)</span> are chosen an centers. Because the graph is connected, the recursive call to <span class="math inline">\({\texttt{connectedComponents}}~(V&#39;,E&#39;)\)</span> will map all vertices in <span class="math inline">\(V&#39;\)</span> to the same vertex. Lets say this vertex is <span class="math inline">\({{\texttt{a}}}\)</span> giving: <span class="math display">\[\begin{array}{lcl} 
V&#39;&#39; &amp; = &amp; {\left\{ {{\texttt{a}}} \right\}}\\ 
P&#39; &amp; = &amp; {\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}}, {{\texttt{d}}} \mapsto {{\texttt{a}}}, {{\texttt{e}}} \mapsto {{\texttt{a}}} \right\}}~. 
\end{array}\]</span> Now <span class="math inline">\({\left\{ v \mapsto P&#39;[s] : (v \mapsto s) \in P \right\}}\)</span> will for each vertex-super-vertex pair in <span class="math inline">\(P\)</span>, look up what that super-vertex got mapped to in the recursive call. For example, vertex <span class="math inline">\({{\texttt{f}}}\)</span> maps to vertex <span class="math inline">\({{\texttt{e}}}\)</span> in <span class="math inline">\(P\)</span> so we look up <span class="math inline">\({{\texttt{e}}}\)</span> in <span class="math inline">\(P&#39;\)</span>, which gives us <span class="math inline">\({{\texttt{a}}}\)</span> so we know that <span class="math inline">\({{\texttt{f}}}\)</span> is in the component <span class="math inline">\({{\texttt{a}}}.\)</span> Overall the result is: <span class="math display">\[{\left\{ {{\texttt{a}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{b}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{c}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{d}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{e}}} \mapsto {{\texttt{a}}},  
                          {{\texttt{f}}} \mapsto {{\texttt{a}}} \right\}}\;.\]</span></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Consider the following example graph.

\begin{center}
\includegraphics[width=2.2]{./media/contract-example1.jpg}
\end{center}

Suppose that $\cd{starPartition}$ returns:
\[
\begin{array}{lcl}
V' & = & \cset{\vname{a},\vname{d},\vname{e}}\\
P & = & 
 \cset{\vname{a} \mapsto \vname{a}, \vname{b} \mapsto \vname{a}, 
       \vname{c} \mapsto \vname{a}, \vname{d} \mapsto \vname{d}, 
       \vname{e} \mapsto \vname{e}, \vname{f} \mapsto \vname{e}}.
\end{array}
\]
%
This pairing corresponds to the case where $a$, $d$ and $e$ are chosen
an centers.
%

Because the graph is connected, the recursive call to
$\cd{connectedComponents}~(V',E')$ will map all vertices in $V'$ to
the same vertex.  Lets say this vertex is $\vname{a}$ giving:
\[
\begin{array}{lcl}
V'' & = & \cset{\vname{a}}\\
P' & = & \cset{\vname{a} \mapsto \vname{a}, \vname{d} \mapsto \vname{a}, \vname{e} \mapsto \vname{a}}~.
\end{array}
\]
%
Now $\cset{v \mapsto P'[s] : (v \mapsto s) \in P}$ will for each
vertex-super-vertex pair in $P$, look up what that super-vertex got
mapped to in the recursive call.  For example, vertex $\vname{f}$ maps
to vertex $\vname{e}$ in $P$ so we look up $\vname{e}$ in $P'$, which
gives us $\vname{a}$ so we know that $\vname{f}$ is in the component
$\vname{a}.$  Overall the result is:
%
\[\cset{\vname{a} \mapsto \vname{a}, 
                          \vname{b} \mapsto \vname{a}, 
                          \vname{c} \mapsto \vname{a}, 
                          \vname{d} \mapsto \vname{a}, 
                          \vname{e} \mapsto \vname{a}, 
                          \vname{f} \mapsto \vname{a}}\;.\]
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR13
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC5:UN7:GR13
</mlxLabel>
<mlxNo>
13
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExercise>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC5:UN7:GR13:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC5:UN7:GR13:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Express <span class="math inline">\({\texttt{countComponents}}\)</span> in terms of higher order function <span class="math inline">\({\texttt{starContract}}\)</span> by giving <span class="math inline">\({\texttt{base}}\)</span> and <span class="math inline">\({\texttt{expand}}\)</span> functions.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Express $\cd{countComponents}$ in terms of higher order function
  $\cd{starContract}$ by giving $\cd{base}$ and $\cd{expand}$ functions.
]]>
</mlxFieldBodyDex>
</mlxAtomExercise>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Forest Contraction and Tree Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Forest Contraction and Tree Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC6
</mlxLabel>
<mlxNo>
6
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC6:UN8
</mlxLabel>
<mlxNo>
8
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC6:UN8:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Contracting a Forest
</mlxFieldTitle>
<mlxFieldTitleDex>
Contracting a Forest
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC6:UN8:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>Suppose that we want to contract a forest (set of trees) instead of a general graph. Because forests are graphs, we can use the same <span class="math inline">\({\texttt{starContract}}\)</span> algorithm to contract the forest. Because a forest of <span class="math inline">\(n\)</span> vertices has at most <span class="math inline">\(n-1\)</span> edges, we obtain a better work bound than for general graphs, because the number of edges decrease geometrically (in expectation) in each round, as do the number of vertices. The overall expected work is therefore a geometric sum of the form: <span class="math display">\[{\mathbf{E}\left[{W(n,m)}\right]} = \sum_{i=0}^{\infty} \left(\frac{3}{4}\right)^i kn = 
O(n).\]</span> Span of the algorithm remains the same. For forests and thus trees, we thus obtain a much better work bound—recall that for general graphs, the work bound is <span class="math inline">\(O(m \lg 
n)\)</span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
Suppose that we want to contract a forest (set of trees) instead of a
general graph.
% 
Because forests are graphs, we can use the same $\cd{starContract}$
algorithm to contract the forest.
%
Because a forest of $n$ vertices has at most $n-1$ edges, we obtain a
better work bound than for general graphs, because the number of edges
decrease geometrically (in expectation) in each round, as do the
number of vertices.
%
The overall expected work is therefore a
geometric sum of the form: 
%
\[
\expct{W(n,m)} = \sum_{i=0}^{\infty} \left(\frac{3}{4}\right)^i kn =
O(n).
\] 
%
Span of the algorithm remains the same.
%
For forests and thus trees, we thus obtain a much better work
bound---recall that for general graphs, the work bound is $O(m \lg
n)$.
%
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC6:UN8:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
Tree Contraction
</mlxFieldTitle>
<mlxFieldTitleDex>
Tree Contraction
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC6:UN8:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>For a graph <span class="math inline">\(G = (V,E)\)</span> consider a subset of edges <span class="math inline">\(F \subset E\)</span> that forms a forest (i.e., has no cycles). Such a set of edges partitions the graph <span class="math inline">\(G\)</span>, where blocks are defined as the subgraphs induced by the trees in <span class="math inline">\(F\)</span>. We can thus contract a graph by identifying a forest <span class="math inline">\(F\)</span>, and then use <span class="math inline">\({\texttt{connectedComponents}}~(V,F)\)</span>, which does linear work as explained above, instead of our <span class="math inline">\({\texttt{starPartition}}\)</span> routine. This corresponds to <span> </span> instead of star partition, which is a special kind of tree. We can thus view this approach as a generalization of the star contraction technique and may call it <span> </span>.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
For a graph $G = (V,E)$ consider a subset of edges $F \subset E$ that
forms a forest (i.e., has no cycles).  Such a set of edges partitions
the graph $G$, where blocks are defined as the subgraphs induced by
the trees in $F$.
%% %
%% \begin{teachask}
%% How can we perform graph contraction by using trees for partitioning?
%% \end{teachask}
%
We can thus contract a graph by identifying a forest $F$, and then use
$\cd{connectedComponents}~(V,F)$, which does
linear work as explained above, instead of our $\cd{starPartition}$
routine.  
%
This corresponds to~\defn{tree partition} instead of star partition,
which is a special kind of tree.
%
We can thus view this approach as a generalization of the star
contraction technique and may call it \defn{tree contraction}.
%
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR3
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC6:UN8:GR3
</mlxLabel>
<mlxNo>
3
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR3:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC6:UN8:GR3:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>A graph and a subset of the edges <span class="math inline">\(F\)</span> (highligted) consisting of three disjoint trees illustrated in the middle diagram. Each tree induces a block in the original graph (red blobs).</p>
<p><img src="./media/tree-contract-example.jpg" alt="image" width="576" /></p>
<p>If we run <span class="math inline">\({\texttt{connectedComponents}}\)</span> on <span class="math inline">\(F\)</span>, then are left with the desired partitioning with super-vertices <span class="math inline">\({\left\{ {{\texttt{a}}},{{\texttt{g}}},{{\texttt{i}}} \right\}}\)</span> and the mapping: <span class="math display">\[{\left\{ {{\texttt{a}}}\mapsto{{\texttt{a}}},{{\texttt{b}}}\mapsto{{\texttt{a}}},{{\texttt{c}}}\mapsto{{\texttt{a}}},{{\texttt{d}}}\mapsto{{\texttt{a}}},{{\texttt{e}}}\mapsto{{\texttt{a}}},{{\texttt{f}}}\mapsto{{\texttt{a}}}, 
  {{\texttt{g}}}\mapsto{{\texttt{g}}}, 
  {{\texttt{h}}}\mapsto{{\texttt{i}}},{{\texttt{i}}}\mapsto{{\texttt{u}}},{{\texttt{j}}}\mapsto{{\texttt{i}}} \right\}}.\]</span></p>
<p>Using this partition, we can compute a quotient graph in the usual way by re-routing edges to the super-vertices. The resulting quotient graph is illustrated on the right.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
A graph and a subset of the edges $F$ (highligted) consisting of
three disjoint trees illustrated in the middle diagram.  Each tree
induces a block in the original graph (red blobs). 
 
\begin{center}
  \includegraphics[width=6in]{./media/tree-contract-example.jpg}
\end{center}
If we run $\cd{connectedComponents}$ on $F$, then are left with the desired partitioning with
super-vertices $\cset{\vname{a},\vname{g},\vname{i}}$ and the mapping:
%
\[
\cset{\vname{a}\mapsto\vname{a},\vname{b}\mapsto\vname{a},\vname{c}\mapsto\vname{a},\vname{d}\mapsto\vname{a},\vname{e}\mapsto\vname{a},\vname{f}\mapsto\vname{a},
  \vname{g}\mapsto\vname{g},
  \vname{h}\mapsto\vname{i},\vname{i}\mapsto\vname{u},\vname{j}\mapsto\vname{i}}.
\]

Using this partition, we can compute a quotient graph in the usual
way by re-routing edges to the super-vertices.  The resulting quotient graph is 
illustrated on the right.
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR4
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC6:UN8:GR4
</mlxLabel>
<mlxNo>
4
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomNote>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC6:UN8:GR4:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC6:UN8:GR4:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>We will use this idea in an algorithm for Minimum Spanning Trees described in .</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
We will use this idea in an algorithm for Minimum Spanning
Trees described in \chref{mst}.
]]>
</mlxFieldBodyDex>
</mlxAtomNote>
</mlxGroup>

</mlxUnit>
</mlxSection>

<mlxSection>
<mlxFieldTitle>
Concluding Remarks
</mlxFieldTitle>
<mlxFieldTitleDex>
Concluding Remarks
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7
</mlxFieldUnique>
<mlxLabel>
section:15210:S18:CH101:SEC7
</mlxLabel>
<mlxNo>
7
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxIntro>
<p>...NO.INTRO...</p>

</mlxIntro>
<mlxIntroDex>


...NO.INTRO...
</mlxIntroDex>

<mlxUnit>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7:UN9
</mlxFieldUnique>
<mlxLabel>
unit:15210:S18:CH101:SEC7:UN9
</mlxLabel>
<mlxNo>
9
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7:UN9:GR1
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC7:UN9:GR1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomGram>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7:UN9:GR1:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC7:UN9:GR1:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>In general the graph contraction techniques does not specify how to partition the graph. In this chapter, we considered two techniques for graph partitioning. Depending on the problem, other techniques can be used. For graph contraction to be applicable to a problem, however, it is important that the quotient graph satisfy certain properties. For example, when solving graph connectivity with the algorithms described here, we have to be careful that the graph partition maintains connectivity: a subgraph should be connected in the quotient graph, if and only if it was connected in the input graph. To ensure this, we will need to use a graph-partition algorithm that ensures that each block is connected in the input graph.</p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
In general the graph contraction techniques does not specify how to
  partition the graph.  In this chapter, we considered two techniques
  for graph partitioning.  Depending on the problem, other techniques
  can be used.  For graph contraction to be applicable to a problem,
  however, it is important that the quotient graph satisfy certain
  properties.  For example, when solving graph connectivity with the
  algorithms described here, we have to be careful that the graph
  partition maintains connectivity: a subgraph should be connected in
  the quotient graph, if and only if it was connected in the input
  graph.  To ensure this, we will need to use a graph-partition
  algorithm that ensures that each block is connected in the input
  graph.
]]>
</mlxFieldBodyDex>
</mlxAtomGram>
</mlxGroup>

<mlxGroup>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7:UN9:GR2
</mlxFieldUnique>
<mlxLabel>
group:15210:S18:CH101:SEC7:UN9:GR2
</mlxLabel>
<mlxNo>
2
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>

<mlxAtomExample>
<mlxFieldTitle>
...NO.TITLE...
</mlxFieldTitle>
<mlxFieldTitleDex>
...NO.TITLE...
</mlxFieldTitleDex>
<mlxFieldUnique>
15210:S18:CH101:SEC7:UN9:GR2:AT1
</mlxFieldUnique>
<mlxLabel>
atom:15210:S18:CH101:SEC7:UN9:GR2:AT1
</mlxLabel>
<mlxNo>
1
</mlxNo>
<mlxParents>
...NO.PARENTS...
</mlxParents>
<mlxFieldBody>
<![CDATA[
<p>The pictures below illustrate two graph partitions. The first graph partition maintains connectivity, the second one does not. The partitioning on the left is appropriate for graph contraction since each partition is connected. The partition on the right is not since <span class="math inline">\({\texttt{d}}\)</span> is not connected to <span class="math inline">\({\texttt{e}}\)</span> and <span class="math inline">\({\texttt{f}}\)</span>.</p>
<p><img src="./media/partition-example1.jpg" alt="image" width="192" /> <img src="./media/partition-example2.jpg" alt="image" width="211" /></p>
]]>
</mlxFieldBody>
<mlxFieldBodyDex>
<![CDATA[
The pictures below illustrate two graph partitions. The first graph
partition maintains connectivity, the second one does not.
%
The partitioning on the left is appropriate for graph contraction since
each partition is connected.    The partition on the right is not
since $\cd{d}$ is not connected to $\cd{e}$ and $\cd{f}$.


\begin{center}
\includegraphics[width=2.0in]{./media/partition-example1.jpg}
\hspace{1in}
\includegraphics[width=2.2in]{./media/partition-example2.jpg}

\end{center}
]]>
</mlxFieldBodyDex>
</mlxAtomExample>
</mlxGroup>

</mlxUnit>
</mlxSection>
</mlxChapter>
</mlxBook>
</mlxCourse>
